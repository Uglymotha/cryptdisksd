#!/bin/bash

# Function Definitions. All functions for serialized commands shall have their nemae prefixed by do_ all others shall not.

do_init_conf()
{
	# Initialize System Variables. Default config in /etc/cryptdisks.d/cryptdisksd.conf. Systemd env CONF(DIR) will override.
	local var val _conf _keylife IFS=$'\n'
	declare -gA conf keyserverconf keylife
	[[ -z "${CONFDIR}" ]] && CONFDIR="/etc/${MYNAME:0:-1}.d"
	if [[ ! -d "${CONFDIR}" && "$1" != "keyserver" ]]; then
		do_log error "${myname} ${CONFDIR} not found"
		return 1
	fi
	[[ -z "${CONF}" ]] && CONF="${CONFDIR}/${MYNAME}.conf"
	if [[ -s ${CONF} ]]; then for var in $(cat ${CONF} |grep -ve "^\s*#"); do
		val=${var#*=} var=${var%%=*}
		conf[${var^^}]="${val}"
   	done fi
	[[ -z "${conf[LOGLEVEL]}" ]] && conf[LOGLEVEL]=0
	[[ -z "${conf[DEBUGSHELL]}" ]] && conf[DEBUGSHELL]=0
	[[ -z "${conf[RUNDIR]}" ]] && conf[RUNDIR]="/run"
	[[ -z "${conf[LOGDIR]}" ]] && conf[LOGDIR]="/var/log/${MYNAME}"
	[[ -z "${conf[LOGFILE]}" ]] && conf[LOGFILE]="/var/log/${MYNAME}.log"
	[[ -z "${conf[CRYPTDISKSDDIR]}" ]] && conf[CRYPTDISKSDDIR]=${conf[RUNDIR]}/${MYNAME}
	[[ -z "${conf[PIDFILE]}" ]] && conf[PIDFILE]="${conf[CRYPTDISKSDDIR]}/${MYNAME}.pid"
	[[ -z "${conf[CRYPTDISKSD_GROUP]}" ]] && conf[CRYPTDISKSD_GROUP]="disk"
	[[ -z "${conf[CRYPTDISKSDDIR_MODE]}" ]] && conf[CRYPTDISKSDDIR_MODE]=700
	[[ -z "${conf[FIFO]}" ]] && conf[FIFO]="${conf[CRYPTDISKSDDIR]}/${MYNAME}.queue"
	[[ -z "${conf[FIFO_MODE]}" ]] && conf[FIFO_MODE]=600
	[[ -z "${conf[CRYPTTAB]}" ]] && conf[CRYPTTAB]="${CONFDIR}/crypttab"
	[[ -z "${conf[BLOCKDEVSDIRS]}" ]] && conf[BLOCKDEVSDIRS]="/dev/disk/by-id"
	[[ -z "${conf[START_TIMEOUT]}" ]] && conf[START_TIMEOUT]=5
	[[ -z "${conf[LOCK_TIMEOUT]}" ]] && conf[LOCK_TIMEOUT]=5
	[[ -z "${conf[PP_TIMEOUT]}" ]] && conf[PP_TIMEOUT]=3
	[[ -z "${conf[QUEUE_TIMEOUT]}" ]] && conf[QUEUE_TIMEOUT]=2
	[[ -z "${conf[CLEANUP_TIMER]}" ]] && conf[CLEANUP_TIMER]=60
	[[ -z "${conf[FWDIR]}" ]] && conf[FWDIR]="/sys/firmware/efi/efivars"
	[[ -z "${conf[FWGUID]}" ]] && conf[FWGUID]="ca25478a-acb8-44ac-8c55-d5d45dfe25c5"
	[[ -z "${conf[FWBOOTCONF]}" ]] && conf[FWBOOTCONF]="${conf[FWDIR]}/UglyLinuxBootCFG-${conf[FWGUID]}"
	[[ -z "${conf[BOOTCONF]}" ]] && conf[BOOTCONF]="${CONFDIR}/boot.conf"
	[[ -z "${conf[NET_ONLINE]}" ]] && conf[NET_ONLINE]=1
	[[ -z "${conf[NET_RETRIES]}" ]] && conf[NET_RETRIES]=2
	[[ -z "${conf[USER_TIEMOUT]}" ]] && conf[USER_TIMEOUT]=10
	conf[START_TIMEOUT]=$((conf[START_TIMEOUT]*60))
	conf[PP_TIMEOUT]=$((conf[PP_TIMEOUT]*60))
	if [[ "$1" == "keyserver" ]]; then
		[[ ! -z "${KEYSERVERDIR}" ]] && CONFDIR="${HOME}/${KEYSERVERDIR}" || CONFDIR="${HOME}/${MYNAME}-keyserver"
		CONF="${CONFDIR}/${MYNAME}-keyserver.conf"
		if [[ -s ${CONF} ]]; then for var in $(cat ${CONF} |grep -ve "^\s*#"); do
			val=${var#*=} var=${var%%=*}
			keyserverconf[${var^^}]="${val}"
	   	done fi
		conf[FIFO]="${CONFDIR}/queue"
		[[ ! -z "${keyserverconf[LOGDIR]}" ]] && conf[LOGDIR]="${HOME}/${keyserverconf[LOGDIR]}" || conf[LOGDIR]="${CONFDIR}"
		[[ ! -z "${keyserverconf[LOGFILE]}" ]] && conf[LOGFILE]="${conf[LOGDIR]}/${keyserverconf[LOGFILE]}" || conf[LOGFILE]="${conf[LOGDIR]}/${MYNAME}-keyserver.log"
		[[ ! -z "${keyserverconf[LOGLEVEL]}" ]] && conf[LOGLEVEL]="${keyserverconf[LOGLEVEL]}"
		[[ ! -z "${keyserverconf[PP_TIMEOUT]}" ]] && conf[PP_TIMEOUT]="${keyserverconf[PP_TIMEOUT]}"
		[[ ! -z "${keyserverconf[USER_TIEMOUT]}" ]] && conf[USER_TIMEOUT]=${keyserverconf[USER_TIEMOUT]}
		[[ ! -z "${keyserverconf[CLEANUP_TIMER]}" ]] && conf[CLEANUP_TIMER]="${keyserverconf[CLEANUP_TIMER]}"
		[[ ! -z "${keyserverconf[KEYDIR]}" ]] && conf[KEYDIR]="${HOME}/${keyserverconf[KEYDIR]}" || conf[KEYDIR]="${CONFDIR}/keys"
		[[ ! -z "${keyserverconf[KEYSRV_TIMEOUT]}" ]] && conf[KEYSRV_TIMEOUT]="${keyserverconf[KEYSRV_TIMEOUT]}" || conf[KEYSRV_TIMEOUT]=5
	fi
	if [[ -n "${conf[KEYLIFE]}" || -n "${keyserverconf[KEYLIFE]}" ]]; then
		IFS=' '; for _conf  in conf[KEYLIFE] keyserverconf[KEYLIFE]; do 
			_keylife=""; for var in ${!_conf}; do
				if [[ "${var}" =~ ^[0-9]+$ && -n "${_keylife}" ]]; then
					do_log error "${myname} can only specify default keylife once"
					return 1
				elif [[ "${var}" =~ ^[0-9]+$ ]]; then
					_keylife=${var}
					continue
				else
					val=${var#*=} var=${var%%=*}
					if [[ -z "${val}" || ! ${val} =~ ^[0-9]+$ ]]; then
						do_log error "${myname} invalid keylife ${var}=${val}"
						return 1
					fi
					keylife[$(do_eval_pp ${var})]=$((val*60))
				fi
			done
			[[ "${_conf}" == "conf[KEYLIFE]" ]] && conf[KEYLIFE]=${_keylife} || keyserverconf[KEYLIFE]=${_keylife}
		done
		[[ -n "${keyserverconf[KEYLIFE]}" ]] && conf[KEYLIFE]=${keyserverconf[KEYLIFE]}
	fi
	conf[KEYLIFE]=$((conf[KEYLIFE]*60))

	# Initialize formatting parameters for console output.
	RED="\033[91m" GREY="\033[94m" YEL="\033[93m" GRN="\033[92m" BOLD="\033[1m" UL="\033[4m" NOR="\033[0m" RES="\0332J"
	PR="\033[s" PD="\033[u\033[16C\033[s" PE="\033[u\033[62C\033[s" PP="\033[u\033[6C\033[s" PT="\033[u\033[22C\033[s" PS="\033[u\033[21C"
	return 0
}

# [BEGIN OF LOGGING FUNCTIONS]

trap_term_logwriter()
{
	trap 'logger -p daemon.warning "${MYNAME}: ${_myname} unclean finish after $(do_timer ${_time_start})s"; exit 1;' SIGINT SIGTERM

	# When the log writer is killed, set the read timeout to 1s (no exit) to allow the writer to parse remaining log messages.
	logger -p daemon.info "${MYNAME}: ${_myname} terminating"
	[[ ${conf[LOGLEVEL]} -gt 0 ]] && echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${myname} terminating after $(do_timer ${_time_start})s" >>${conf[LOGFILE]}
	exit 0
}

logwriter()
{
	trap 'trap_term_logwriter' SIGINT SIGTERM

	# The log write will parse lines from stdin, sent by various workers. The lines are written to log and sent to syslog.
	local myname="logger (${BASHPID}):" _time_start=$(do_timer) lf line

	# Initialize the log file. Set the correct access rights.
	if [[ ! -z "$1" ]]; then
		conf[LOGFILE]=${conf[LOGDIR]}/$1
		touch ${conf[LOGFILE]}
		chmod 640 ${conf[LOGFILE]}
	fi
	[[ ${conf[LOGLEVEL]} -gt 0 ]] && echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${myname} initialized" >>${conf[LOGFILE]}

	# Prepend every line recieved with date and time and write to logfile.
	while read -r lf line; do
		local _date="$(date '+%d-%m %H:%M:%S.%3N')"
		if [[ "${lf}" == "debug" && ${conf[LOGLEVEL]} -ge 1 ]]; then
			echo "${_date} ${hostname} ${line}" >>${conf[LOGFILE]}
		elif [[ "${lf}" == "debug2" && ${conf[LOGLEVEL]} -ge 3 ]]; then
			echo "${_date} ${hostname} ${line}" >>${conf[LOGFILE]}
		elif [[ ${lf} == "info" || ${lf} == "warning" || ${lf} == "error" ]]; then
			logger -p daemon.${lf} "${MYNAME}: ${line}"
			[[ ${conf[LOGLEVEL]} -ge 1 ]] && echo "${_date} ${hostname} ${line}" >>${conf[LOGFILE]}
		elif [[ ${conf[LOGLEVEL]} -ge 3 ]]; then
			echo "${_date} ${hostname} ${lf} ${line}" >>${conf[LOGFILE]}
		fi
	done
	echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${myname} finished after $(do_timer ${_time_start})s ($?)" >>${conf[LOGFILE]}
}

do_log()
{
	# Send a message to the log writer, or to systemd if that fails.
	echo "$@" >&${fd_logwriter} || echo "$@" >&${fd_journal}
}

do_timer()
{
	# Start a timer for debugging purposes. We will track to the ms.
	if [[ $# -eq 0 ]]; then
		# Started with no args, start a timer, echo the start time.
		echo ${EPOCHREALTIME:0:-3}
	elif [[ ${1,,} == "date" ]]; then
		# Output the exact date of the timestamp.
		echo "$(date --date @$2 +%Y-%m-%d.%H:%M:%S)"
	else
		# Started with start time as args, calculate and echo the time difference.
		echo "$(bc <<<"x=${EPOCHREALTIME:0:-3}-$1; if (x<1) print 0; x")"
	fi
}

# [END OF LOGGING FUNCTIONS]

# [BEGIN OF MAIN DAEMON FUNCTIONS]

trap_term_daemon()
{
	trap 'systemd-notify --pid=$$ --stopping --status="${MYNAME}: unclean finish after $(do_timer ${time_start})s"; exit 1;' SIGINT SIGTERM

	# Main process received SIGTERM or SIGINT, shutdown reader and logwriter processes.
	do_log warning "${myname} terminating after $(do_timer ${time_start})s"
	do_daemon_check_conf
	for _pid in ${pid_ctrl[@]}; do
		if [[ "$(cat /proc/${pid_ctrl[${_pid}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${pid_ctrl[${_pid}]}
			wait ${pid_ctrl[${_pid}]}
			do_log debu2 "${myname} killed control process (PID: ${pid_ctrl[${_pid}]})"
		fi
	done
	if [[ ! -z "${pid_reader}" && "$(cat /proc/${pid_reader}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_reader}
		wait ${pid_reader}
	fi
	if [[ ! -z "${pid_logwriter}" && "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_logwriter}
		wait ${pid_logwriter}
	fi
	rm -f ${conf[PIDFILE]} ${conf[CRYPTDISKSDDIR]}/*.sock

	systemd-notify --pid=$$ --stopping --status="${MYNAME}: terminating after $(do_timer ${time_start})s"
	exit $1 
}

trap_hup_daemon()
{
	# Received reload request from systemd. Reload the config asap (no active commands/workers). confok, contains status.
	# 0 - Config is ok.
	# 1 - Config changed, or SIGHUP received
	# 2 - Notified reader of reload
	# When the reader is ready to reload it will notify us and we can reload the config and restart the reader.
	if [[ ${starting} -eq 0 && ${confok} -eq 0 ]]; then
		do_log warning "${myname} received SIGHUP, reload config asap"
		confok=2
		kill -SIGHUP ${pid_reader}
		do_log debug2 "${myname} notified reader (PID: ${pid_reader}) of config reload"
	fi
}

systemd_daemon()
{
	trap 'trap_term_daemon' SIGINT SIGTERM
	trap 'trap_hup_daemon' SIGHUP

	# The reader and all workers will be started with the following fds:
	# 1 (stdout) 2 (stderr) and {fd_logwriter} (for subshells) point to a log writer.
	# {fd_journal} systemd journal messages which can be viewed with systemctl status and journalctl -xe
	# {fd_daemon} the daemon process.
	local time_active=0.000 cleanup=0.000 msg="" confok=0 fd_daemon pid_reader fd_reader reader_alive=0 readerr=0 pid_putkey key passphrase read_to res _time_start
	declare -A active_mnt pid_ctrl fd_ctrl time_ctrl cached_pp

	# If we are booting up the master passphrase may be in the user keyring, revoke and cache in session keyring.
	key="$(keyctl search @u user "system:master" 2>/dev/null)"; passphrase="$(keyctl pipe "${key}" 2>/dev/null)"
	if [[ ! -z "${key}" ]]; then
		do_log debug "${myname} removed system:master passphrase from user keyring"
		keyctl revoke "${key}" 2>/dev/null
		keyctl unlink "${key}" @u 2>/dev/null
		key_clnt "PUT" "system:master" "${passphrase}" & pid_putkey=$!
		do_cache_pp "${myname}" "system:master" "-1" "${passphrase}" && cached_pp[system:master]=1
	fi
	
	# The readers and will send us messages about events, we need to keep track of time for (debug) logging and cleanup.
	# If we are starting up, read time-out is start timeout so cleanup etc will be done only after start
	# If we are in normal op, keep cleanup timer (60secs). The timeouts will be evaluated every command iteration.
	systemd-notify --pid=$$ --status="${MYNAME}: Starting Up, Timeout $((conf[START_TIMEOUT]+conf[QUEUE_TIMEOUT]*2))s"
	systemd-notify EXTEND_TIMEOUT_USEC=$(((conf[START_TIMEOUT]+conf[QUEUE_TIMEOUT]*2)*1000000))
	do_daemon_start_reader
	do_log debug "${myname} started reader (PID: ${pid_reader})"

	while true; do	
		# If we are starting up, read time-out when initial queue is empty so we can notify parent. If we are in normal operation, keep cleanup timer (60secs).
		do_log debug2 "${myname} running since $(do_timer date ${time_start})"
		time_active=$(do_timer ${time_start}) read_to=$([[ ${starting} -eq 0 ]] && echo ${conf[CLEANUP_TIMER]} || echo ${conf[START_TIMEOUT]})
	
		# Set the new queue read timeout, we will run a cleanup every conf[CLEANUP_TIMER]. Cleanup will not run before we are started.
		# Make sure the read timeout is never 0 as this will complicate things (read will not read if to = 0).
		# Parse the message into an arry the first element will be reader second the pid of the reader, rest is the message.
		[[ ${starting} -eq 0 && ${time_active:0:-4} -gt $((${cleanup:0:-4}+${conf[CLEANUP_TIMER]}-${conf[QUEUE_TIMEOUT]})) ]] && do_daemon_cleanup
		read_to="$(((read_to+conf[QUEUE_TIMEOUT])-(${time_active:0:-4}%read_to)))"
		read -t${read_to} -ru${fd_reader} -a msg
		res=$?
		
		# Evaluate the exit status of the message queue read and act accordingly.
		time_active=$(do_timer ${time_start})
		if [[ ${res} -eq 142 ]]; then 
			do_log debug2 "${myname} waking up from slumber"
			[[ ${starting} -eq 0 && ${read_to##* } -gt $((conf[CLEANUP_TIMER]/2)) ]] && do_daemon_cleanup
			if [[ ${starting} -ne 0 && ${time_active:0:-4} -ge ${conf[START_TIMEOUT]} ]]; then 
				# Start timeout reached, notify systemd.
				do_log warning "${myname} start timeout reached, notifying reader and systemd"
				starting=0 start_status=3
				do_daemon_notify_systemd
			fi
			continue
		elif [[ ${res} -gt 128 ]]; then
			# Should not happen, daemon process received unhandled signal from somewhere.
			do_log debug "${myname} read result ${res}, may have been trapped"
			do_daemon_cleanup 
			continue
		elif [[ ${res} -ne 0 ]]; then
			# Reader has terminated unexpectedly or fd has somehow been closed from reader end.
			do_log error "${myname} read error ${res} \"${msg[@]}\""
			reader_alive=2
			do_daemon_cleanup
			continue
		fi

		# Evaluate the start status. Check if we have a start timeout. If so we are started and will notify systemd.
		if [[ ${starting} -ne 0 && ${time_active:0:-4} -ge ${conf[START_TIMEOUT]} ]]; then
			# Check if we have a start timeout. If so we are started and will notify systemd.
			starting=0 start_status=3
			do_daemon_notify_systemd
			continue
		elif [[ -z "${msg[@]}" || ! ( "${msg[0],,}" == "reader" && ${msg[1]} -eq ${pid_reader} ) ]]; then
			# Should not occur, run cleanup if it does, if reader has exited next read will fail, see above.
			do_log error "${myname} received invalid message \"${msg[@]}\""
			reader_alive=2
			do_daemon_cleanup
			continue
		fi

		# Process the message sent by the reader.
		do_log debug "${myname} processing \"${msg[@]}\"" 
		reader_alive=0 _time_start=$(do_timer)

		case ${msg[2],,} in
		started|control|notify)
			do_daemon_${msg[2],,};;
		active)
			do_log debug "${myname} reader (PID: ${pid_reader}) ping received";;
		remove)
			do_daemon_unmount_crypt "${msg[3]}";;
		add)
			do_daemon_mount_crypt "${msg[3]}" "${msg[4]}" "${msg[5]}" "${msg[6]}";;
		passphrase)
			[[ ${msg[4]} -eq 1 ]] && cached_pp[${msg[3]}]=1 || unset cached_pp[${msg[3]}];;
		reload)
			[[ ${confok} -lt 2 ]] && do_log warning "${myname} incorrect reload request from reader";
			[[ -e /proc/self/fd/${fd_reader} ]] && exec {fd_reader}>&-
			unset pid_reader
			do_daemon_cleanup;;
		*)	
			do_log debug "${myname} received invalid command from reader \"${msg[@]}\"";;
		esac

		do_log debug2 "${myname} processing \"${msg[@]}\" took $(do_timer ${_time_start})s total"
	done

	# We should never get here, exit with error if we do.
	do_log error "${myname} terminated unexpectedly after $(do_timer {time_start})s"
	systemd-notify --pid=$$ --stopping --status="${MYNAME}: Daemon Terminated Unexpectedly After $(do_timer {time_start})s (PID: ${BASHPID}))"
	trap_term_daemon 1
}

do_daemon_start_logwriter()
{
	# LOGLEVEL 0, log only to syslog (daemon facility). 
	# LOGLEVEL 1, log to syslog and debug to dedicated logfile.
	# LOGLEVEL 2 is loglevel 1 with components having dedicated log file.
	# LOGLEVEL 3, extra debug logging, stdout and stderr of processes also sent to log.
	# BEWARE PASSPHRASES WILL BE LOGGED ALSO!!!!
	# LOGLEVEL 4, sames as level 3 with components having dedicated log file.
	[[ -n "${fd_logwriter}" ]] && exec {fd_logwriter}>&-
	case ${conf[LOGLEVEL]} in
		0|1)  exec {fd_logwriter}> >(logwriter);;
		2)    exec {fd_logwriter}> >(logwriter daemon-${pid_daemon}.log);;
		3)    exec {fd_logwriter}> >(logwriter) 1>&${fd_logwriter} 2>&1;;
		4)    exec {fd_logwriter}> >(logwriter daemon-${pid_daemon}.log) 1>&${fd_logwriter} 2>&1;;
	esac
	pid_logwriter=$!
}

do_daemon_start_reader()
{
	# Set the group and mode for the rundir and queue.
	[[ ! -z ${fd_reader} ]] && exec {fd_reader}>&-
	chgrp ${conf[CRYPTDISKSD_GROUP]} ${conf[CRYPTDISKSDDIR]} ${conf[FIFO]}
	chmod ${conf[CRYPTDISKSDDIR_MODE]} ${conf[CRYPTDISKSDDIR]}
	chmod ${conf[FIFO_MODE]} ${conf[FIFO]}
	if [[ ${conf[LOGLEVEL]} -le 2 ]]; then
		# Start the reader with stdout and stderr redirected to /dev/null (silent).
		exec {fd_reader}< <(udev_reader {fd_daemon}>&1- 1>/dev/null 2>&1)
	else
		# Start the reader with stdout and stderr redirected to the logwriter.
		exec {fd_reader}< <(udev_reader {fd_daemon}>&1- 1>&${fd_logwriter} 2>&1)
	fi
	pid_reader=$!
}

do_daemon_notify_systemd()
{
	# Daemon notify about startup status.
	systemd-notify --ready --pid=$$
	case ${start_status} in 
	0)
		do_log info "${myname} startup completed succesfully in ${time_active}s"
		systemd-notify --pid=$$ --status="${MYNAME}: Startup completed succesfully in ${time_active}s (PID: ${BASHPID})";;
	1)
		do_log warning "${myname} startup completed with errors in ${time_active}s"
		systemd-notify --pid=$$ --status="${MYNAME}: Startup completed with errors in ${time_active}s (PID: ${BASHPID})";;
	2)
		do_log warning "${myname} startup completed with warnings in ${time_active}s"
		systemd-notify --pid=$$ --status="${MYNAME}: Startup completed with warnings in ${time_active}s (PID: ${BASHPID})";;
	3)
		do_log warning "${myname} startup timed out after ${time_active}s"
		systemd-notify --pid=$$ --status="${MYNAME}: Startup timed out after ${time_active}s (PID: ${BASHPID})"
		kill -SIGHUP ${pid_reader};;
	esac
}

do_daemon_check_conf()
{
	# Parse the configuration from firmware and compare it to the config stored in the confdir.
	# If there are any differences, the configuration in confidir will take precedence and overwrite the firmware.
	local diff _diff fwsrvvar fwsrvkey fwusrvar fwusrkey srvkey usrkey
	do_log debug "${myname} checking config"

	if [[ -s ${conf[FWBOOTCONF]} && ! -s ${conf[BOOTCONF]} ]]; then
		# Config in firware, not in confdir, copy fw to confdir.
		[[ ${confok} -eq 0 ]] && confok=1
		do_log debug "${myname} copying ${conf[FWBOOTCONF]} config to ${CONFDIR}"
		cat ${conf[FWBOOTCONF]} | tail -c +5 >${conf[BOOTCONF]} || return 1
	elif [[ -s ${conf[FWBOOTCONF]} && -s ${conf[BOOTCONF]} ]]; then
		# Compare the firmware config to confdir.
		diff="$(cat ${conf[FWBOOTCONF]} | tail -c +5)" _diff="$(cat ${conf[BOOTCONF]})"
		if ! diff -q <(echo "${diff}") <(echo "${_diff}") >/dev/null; then
			# Configs are different, overwrite confdir on startup firmware config otherwise.
			[[ ${confok} -eq 0 ]] && confok=1
			if [[ ${starting} -eq 0 ]]; then
				do_log warning "${myname} ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} differ, replacing ${conf[FWBOOTCONF]}"
				[[ -e ${conf[FWBOOTCONF]} ]] && chattr -i ${conf[FWBOOTCONF]}
				printf "\x07\x00\x00\x00\x00" >${conf[FWBOOTCONF]} || do_log error "${myname} error creating ${conf[FWBOOTCONF]}"
				efivar -n ${conf[FWGUID]}-UglyLinuxBootCFG -w -f ${conf[BOOTCONF]} 2>&1 || do_log error "${myname} error copying ${conf[BOOTCONF]} to ${conf[FWBOOTCONF]}"
				chattr +i ${conf[FWBOOTCONF]}
			else
				do_log warning "${myname} ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} differ, replacing ${conf[BOOTCONF]}"
				cat ${conf[FWBOOTCONF]} | tail -c +5 >${conf[BOOTCONF]}
			fi
		else
			do_log debug2 "${myname} ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} equal"
		fi
	elif [[ ! -s ${conf[FWBOOTCONF]} && -s ${conf[BOOTCONF]} ]]; then
		# No fwconfig store confdir.
		[[ ${confok} -eq 0 ]] && confok=1
		do_log debug "${myname} no firmware config, copying from ${conf[BOOTCONF]}"
		[[ -e ${conf[FWBOOTCONF]} ]] && chattr -i ${conf[FWBOOTCONF]}
		printf "\x07\x00\x00\x00\x00" >${conf[FWBOOTCONF]} || do_log error "${myname} error creating ${conf[FWBOOTCONF]}"
		efivar -n ${conf[FWGUID]}-UglyLinuxBootCFG -w -f ${conf[BOOTCONF]} || do_log error "${myname} error copying ${conf[BOOTCONF]} to ${conf[FWBOOTCONF]}"
		chattr +i ${conf[FWBOOTCONF]}
	else
		# No bootconf at all.
		do_log warning "${myname} no boot config found"
		bootconf[BOOTSERVERS]=""
	fi

	# If we are starting up, now is the time to load the config.	
	[[ ${starting} -eq 1 ]] && do_daemon_reload_conf	

	# Check if the service config or crypttab has changed on disk.
	if [[ ${starting} -eq 0 && ${confok} -eq 0 ]]; then
		if [[ ! -f ${conf[CRYPTTAB]} ]]; then
			do_log warning "${myname} ${conf[CRYPTTAB]} disappeared, reloading asap"
			[[ ${confok} -eq 0 ]] && confok=1
		fi
		if [[ ! -f ${CONF} ]]; then
		 	do_log error "${myname} ${CONF} disappeared, terminating"
			return 1
		fi
		diff="$(cat ${CONF} |grep -ve "^\s*#")"
		if ! diff -q <(echo "${diff}") <(echo "${systemdconf}") >/dev/null; then
			do_log error "${myname} ${CONF} changed, terminating"
			return 1
		fi
		diff="$(cat ${conf[CRYPTTAB]} |grep -ve "^\s*#" |tr "\t" " " |tr -s " ")"
		if ! diff -q <(echo "${diff}") <(echo "${crypttab}") >/dev/null; then
			do_log debug "${myname} crypttab changed, reloading asap"
			[[ ${confok} -eq 0 ]] && confok=1
		fi
	fi

	# Check the bootserver and user keys if present.
	[[ -z ${bootconf[BOOTSERVERS]} ]] && return
	fwsrvvar="${conf[FWGUID]}-UglyLinux${bootconf[BOOTSERVERKEYS]}" fwsrvkey="${conf[FWDIR]}/UglyLinux${bootconf[BOOTSERVERKEYS]}-${conf[FWGUID]}"
	fwusrvar="${conf[FWGUID]}-UglyLinux${bootconf[BOOTUSERKEY]}"    fwusrkey="${conf[FWDIR]}/UglyLinux${bootconf[BOOTUSERKEY]}-${conf[FWGUID]}"
	srvkey="${CONFDIR}/${bootconf[BOOTSERVERKEYS]}"                 usrkey="${CONFDIR}/${bootconf[BOOTUSERKEY]}"
	if [[ -s ${fwsrvkey} && -s ${srvkey} ]]; then
		# compare the keys, overwrite if necessary
		diff="$(cat ${fwsrvkey} | tail -c +5)" _diff="$(cat ${srvkey})"
		if ! diff -q <(echo "${diff}") <(echo "${_diff}") >/dev/null; then
			# Configs are different, overwrite firmware config
			do_log warning "${myname} ${fwsrvkey} and ${srvkey} differ, replacing ${fwsrvkey}"
			[[ -e ${fwsrvkey} ]] && chattr -i ${fwsrvkey}
			printf "\x07\x00\x00\x00\x00" >${fwsrvkey} || do_log error "${myname} error creating ${fwsrvkey}"
			efivar -n ${fwsrvvar} -w -f ${srvkey} || do_log error "${myname} error copying ${srvkey} to ${fwsrvkey}"
			chattr +i ${fwsrvkey}
		else
			do_log debug2 "${myname} ${fwsrvkey} and ${srvkey} equal"
		fi
	elif [[ -s ${fwsrvkey} && ! -s ${srvkey} ]]; then
		# Keys in fw not in confdir, copy
		do_log debug "${myname} copying ${fwsrvkey} to ${srvkey}"
		cat ${fwsrvkey} | tail -c +5 > ${srvkey} || return 1
	elif [[ ! -s ${fwsrvkey} && -s ${srvkey} ]]; then
		# No fwbootkeys, copy from confdir.
		do_log debug "${myname} no firmware bootserver keys, copying from ${srvkey}"
		[[ -e ${fwsrvkey} ]] && chattr -i ${fwsrvkey}
		printf "\x07\x00\x00\x00\x00" >${fwsrvkey} || do_log error "${myname} error creating ${fwsrvkey}"
		efivar -n ${fwsrvvar} -w -f ${srvkey} || do_log error "${myname} error copying ${srvkey} to ${fwsrvkey}"
		chattr +i ${fwsrvkey}
	else
		# No bootserverkeys at all
		do_log error "${myname} no bootserver keys found"
		bootconf[BOOTSERVERS]=""
	fi

	# No need to check user key, if server key not present.
	[[ -z ${bootconf[BOOTSERVERS]} ]] && return
	if [[ -s ${fwusrkey} && ! -s ${usrkey} ]]; then
		# Key in fw not in confdir, copy
		do_log debug "${myname} copying ${fwusrkey} to ${usrkey}"
		chattr -i ${fwusrkey}; chmod 400 ${fwusrkey}; chattr +i ${fwusrkey}
		cat ${fwusrkey} | tail -c +5 > ${usrkey} || return 1
		chmod 400 ${usrkey}
	elif [[ -s ${fwusrkey} && -s ${usrkey} ]]; then
		# compare the keys, overwrite if necessary
		diff="$(cat ${fwusrkey} | tail -c +5)" _diff="$(cat ${usrkey})"
		if ! diff -q <(echo "${diff}") <(echo "${_diff}") >/dev/null; then
			# Configs are different, overwrite firmware config
			do_log warning "${myname} ${fwusrkey} and ${usrkey} differ, replacing ${fwusrkey}"
			[[ -e ${fwusrkey} ]] && chattr -i ${fwusrkey}
			printf "\x07\x00\x00\x00\x00" >${fwusrkey} || do_log error "${myname} error creating ${fwusrkey}"
			efivar -n ${fwusrvar} -w -f ${usrkey} || do_log error "${myname} error copying ${usrkey} to ${fwusrkey}"
			chattr -i ${fwusrkey}; chmod 400 ${fwusrkey}; chattr +i ${fwusrkey}
		else
			do_log debug2 "${myname} ${fwusrkey} and ${usrkey} equal"
			chattr -i ${fwusrkey}; chmod 400 ${fwusrkey}; chattr +i ${fwusrkey}
			chmod 400 ${usrkey}
		fi
	elif [[ ! -s ${fwusrkey} && -s ${usrkey} ]]; then
		# No fwbootuserkey, copy from confdir
		do_log debug "${myname} no firmware bootuser key, copying from ${usrkey}"
		[[ -e ${fwusrkey} ]] && chattr -i ${fwusrkey}
		printf "\x07\x00\x00\x00\x00" >${fwusrkey} || do_log error "${myname} error creating ${fwusrkey}"
		efivar -n ${fwusrvar} -w -f ${usrkey} || do_log error "${myname} error copying ${usrkey} to ${fwusrkey}"
		chattr -i ${fwusrkey}; chmod 400 ${fwusrkey}; chattr +i ${fwusrkey}
	else
		# No bootuserkeys at all
		bootconf[BOOTSERVERS]=""
	fi
	return 0
}

do_daemon_reload_conf()
{
	do_log debug "${myname} loading configuration"
	local var val IFS=$'\n'
	unset bootconf crypttab systemdconf
	declare -gA bootconf

	# Load the crypttab and systemd conf into memory.
	[[ -s ${conf[CRYPTTAB]} ]] && crypttab="$(cat ${conf[CRYPTTAB]} |grep -ve "^\s*#"| tr "\t" " " |tr -s " ")" 
	[[ -s ${CONF} ]] && systemdconf="$(cat ${CONF} |grep -ve "^\s*#")"

	# Source the boot config if necessary.
	if [[ -s ${conf[BOOTCONF]} ]]; then for var in $(cat ${conf[BOOTCONF]} |grep -ve "^\s*#"); do
		val=${var#*=} var=${var%%=*}
		bootconf[${var^^}]="${val}"
   	done fi
}

do_daemon_cleanup()
{
	# Readers should not ever exit, the is an error / bug. Restart the reader
	local myname="daemon cleanup (${BASHPID}):" _time_start=$(do_timer) tab_crypt="" pp crypt_arr crypt _crypt dev trim time pid mnt_crypt
	cleanup=$(do_timer ${time_start})
	do_log debug "${myname} cleanup starting at ${time_active}"

	# Ping systemd.
	systemd-notify WATCHDOG=1 WATCHDOG_USEC=$(((2*conf[CLEANUP_TIMER])*1000000))

	# Check if the log writer is still active, restart it and the reader if necessary.
	[[ ${FOREGROUND} -eq 0 ]] && if [[ "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" != "${MYNAME}" ]] || ! kill -0 ${pid_logwriter}; then
		[[ "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]] && kill -SIGTERM ${pid_logwriter}
		pid=pid_logwriter
		do_daemon_start_logwriter
		systemd-notify "${MYNAME}: logwriter (PID: ${pid}) terminated after $(do_timer ${time_start})s"
		do_log error "${myname} logwriter (PID: ${pid}) terminated after $(do_timer ${time_start})s"
		if [[ ${conf[LOGLEVEL]} -ne 2 && ${conf[LOGLEVEL]} -ne 4 ]]; then
			kill -SIGTERM ${pid_reader} && unset pid_reader
			[[ -e /proc/self/fd/${fd_reader} ]] && exec {fd_reader}>&-
			do_log debug2 "${myname} killed reader (PID: ${pid_reader})"
		fi
	fi

	# Kill too long running control conections.
	for pid in ${!pid_ctrl[@]}; do
		time=$(do_timer ${time_ctrl[${pid}]})
		if [[ ${time:0:-4} -ge $((2*conf[PP_TIMEOUT])) ]]; then 
			do_log debug "${myname} cleanup removed control worker (PID: ${pid_ctrl[${pid}]})"
			if [[ ! -z "${pid_ctrl[${pid}]}" && "$(cat /proc/${pid_ctrl[${pid}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
				kill -SIGKILL ${pid_ctrl[${pid}]}
				do_log debug2 "${myname} killed ${pid_ctrl[${pid}]}"
			fi
			exec {fd_ctrl[${pid}]}>&-
			unset pid_ctrl[${pid}] fd_ctrl[${pid}] time_ctrl[${pid}]
		fi
	done
	[[ -z ${!pid_ctrl[@]} ]] && rm -f ${conf[CRYPTDISKSDDIR]}/*.sock

	# Check the config.
	if ! do_daemon_check_conf; then
		do_log error "${myname} failed to check config, terminating"
		systemd-notify --pid=$$ --stopping --status="${MYNAME}: Failed to Load Configuration"
		trap_term_daemon 0
	fi
		
	if [[ ${starting} -eq 0 && ${confok} -eq 1 ]]; then
		# Config has changed, needs to be reloaded.
		confok=2
		kill -SIGHUP ${pid_reader}
		do_log debug2 "${myname} notified reader (PID: ${pid_reader}) of config reload"
	fi

	# Check if the reader is still alive and restart it if necessary.	
	if [[ -z ${pid_reader} || ${reader_alive} -eq 2 || "$(cat /proc/${pid_reader}/comm 2>/dev/null)" != "${MYNAME}" ]] || ! kill -0 ${pid_reader}; then
		[[ ${reader_alive} -eq 2 ]] && do_log error "${myname} reader (PID: ${pid_reader}) not functioning after ${time_active}s"
		systemd-notify --pid=$$ --status="${MYNAME}: reader (PID: ${pid_reader}) terminated after ${time_active}s"
		if [[ "$(cat /proc/${pid_reader}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${pid_reader}
			do_log debug2 "${myname} killed reader (PID: ${pid_reader})"
		fi
		[[ -e /proc/self/fd/${fd_reader} ]] && exec {fd_reader}>&-
		do_daemon_reload_conf
		confok=0 reader_alive=0
		do_daemon_start_reader
		# Check if any crpyts have been removed from the crypttab and try to remove then. Then trigger udev to add new devices.
		# We will set a list with all crypts in the crypttab and will check that list against active mounts later.
		tab_crypt="$(tr "\t" " " <<<"${crypttab}" |cut -d" " -f1)"
	elif [[ ${reader_alive} -eq 1 ]]; then
		do_log warning "${myname} have not received ping from reader (PID: ${pid_reader})"
		reader_alive=2
	fi
	reader_alive=$((reader_alive+1))

	# Check the active crypts and add to active list if not already present.
	mnt_crypt="$(dmsetup ls --target crypt |cut -f1 |grep -vi "No devices found" 2>/dev/null)"
	for crypt in ${mnt_crypt}; do if [[ -z "${active_mnt[${crypt}]}" ]]; then
		crypt_arr=($(do_xcrypt_fromtab "${myname}" "${crypt}"))
		[[ "$(lsblk -rD /dev/mapper/${crypt} |head -n2 |tail -n1 |cut -d" " -f3 2>/dev/null)" == "0B" ]] && trim=0 || trim=1
		if [[ ! -z "${crypt_arr[@]}" ]]; then
			dev="${crypt_arr[1]}" pp="$(do_eval_pp "${crypt_arr[2]}")"
			active_mnt[${crypt}]="${dev} ${pp} ${trim} $(do_timer)"
		else
			dev=/dev/"$(dmsetup deps ${crypt} -o blkdevname |cut -d: -f2 |tr -d " ()" |cut -d: -f2 2>/dev/null)"
			active_mnt[${crypt}]="${dev} - ${trim} $(do_timer)"
		fi
		do_log debug "${myname} found ${dev} as ${crypt} TRIM ${trim} passphrase ${pp} adding to active list"
	fi done

	# Check for removed crypts and remove the from active list.
	for crypt in ${!active_mnt[@]}; do
		for _crypt in ${mnt_crypt}; do
			[[ "${crypt}" == "${_crypt}" ]] && continue 2
		done
		crypt_arr=(${active_mnt[${crypt}]})
		do_log warning "${myname} ${crypt_arr[0]} as ${crypt} TRIM ${crypt_arr[2]} passphrase ${crypt_arr[1]} mounted since $(do_timer date ${crypt_arr[3]}) dissapeared"
		unset active_mnt[${crypt}]
	done

	# If we have reloaded look up any managed crypts removed from crypttab and make them unmanaged.
	if [[ ! -z "${tab_crypt}" ]]; then for crypt in ${!active_mnt[@]}; do
		crypt_arr=(${active_mnt[${crypt}]})
		[[ "${crypt_arr[1]}" == "-" ]] && continue
		for _crypt in ${tab_crypt}; do
			[[ "${crypt}" == "${_crypt}" ]] && continue 2
		done
		do_log warning "${myname} ${crypt_arr[0]} as ${crypt} TRIM ${crypt_arr[2]} passphrase ${crypt_arr[1]} mounted since $(do_timer date ${crypt_arr[3]}) removed from crypttab"
		active_mnt[${crypt}]="${crypt_arr[0]} - ${crypt_arr[2]} ${crypt_arr[3]}"
	done fi

	# Check Cached Passphrases
	for _pp in ${!cached_pp[@]}; do if ! keyctl request user "${_pp}" @s >/dev/null 2>&1; then
		do_log info "${myname} ${_pp} passphrase no longer cached"
		unset cached_pp[${_pp}]
	fi done

	do_log debug2 "${myname} cleanup took $(do_timer ${_time_start})s, cached passphrases: ${!cached_pp[@]} - active mounts: ${!active_mnt[@]}"
}

# [END OF MAIN DAEMON FUNCTIONS]

# [BEGIN OF DAEMON READER FUNCTIONS]

do_daemon_started()
{
	# Process the start status, sent by the reader and our own.
	[[ ${start_status} -eq 0 && ${msg[4]} -eq 0 ]] && start_status=0
	[[ ${start_status} -eq 2 || ${msg[4]} -eq 2 ]] && start_status=2
	[[ ${start_status} -eq 1 || ${msg[4]} -eq 1 ]] && start_status=1

	# Set the new starting status, will need to wait for active workers, or notify systemd we are started
	case ${msg[3]} in
	0)
		# Reader has completed startup succesfully
		do_log debug "${myname} reader has started succesfully"
		do_daemon_notify_systemd
		do_daemon_cleanup
		starting=0;;
	2)
		# We are in inital startup. The reader notifies us the queue is empty and is still waiting for passphrases..
		starting=2
		do_log debug "${myname} reader has processed queue and is awaiting passphrases";;
	*)
		# Incorrect
		do_log warning "${myname} received incorrect start status from reader";;
	esac
}

do_daemon_notify()
{
	local myname="daemon-notify (${BASHPID}):" _time_start=$(do_timer) pid_ctrl=${msg[3]} cmd="${msg[4],,}"
	do_log debug "${myname} processing \"${msg[@]:4}\""

	# Process a command received from a control sub-process and notify about the result.
	case ${cmd} in
	add)
		do_daemon_mount_crypt "${msg[5]}" "${msg[6]}" "${msg[7]}" "${msg[8]}"
		echo $? >&${fd_ctrl[${pid_ctrl}]}
		do_log debug "${myname} active mounts: ${!active_mnt[@]}" ;;
	del)
		do_daemon_unmount_crypt "${msg[5]}"
		echo $? >&${fd_ctrl[${pid_ctrl}]}
		do_log debug "${myname} active mounts: ${!active_mnt[@]}" ;;
	*)
		do_log debug "${myname} received invalid notify command \"${msg[@]:2}\"" ;;
	esac
	do_log debug2 "${myname} processing \"${msg[@]:4}\" took $(do_timer ${_time_start})s"
}

do_daemon_control()
{
	# Daemon received control command from cryptdisksd command line. Initialize common variables for control process (__*)
	local myname="daemon-control (${BASHPID}):" _time_start=$(do_timer) _pid_ctrl=${msg[3]%%,*}
	local pid_socat=${msg[3]##*,} cmd="${msg[4],,}" _cmd="${msg[4],,}" sock_ctrl="${conf[CRYPTDISKSDDIR]}/${MYNAME}-${_pid_ctrl}.sock"
	local _myname _crypt_arr _pid_logwriter _pid_putkey _confirm=0 _crypttab=0 _trim=0 _smartall=0 _smarttest=0 _cache="" _fw=0 _srv="" add="" _socat
	do_log debug "${myname} processing \"${msg[@]:4}\""
	[[ "${cmd}" =~ ^(smart|erase)$ ]] && _cmd=smarterase
	[[ "${cmd}" =~ ^(putkey|rmkey)$ ]] && _cmd=putrmkey 

	# Process the command received and start the according control worker process.
	case ${cmd} in
	finished)
		do_log debug "${myname} control connection (PID: ${pid_ctrl[${_pid_ctrl}]}) finished"
		exec {fd_ctrl[${_pid_ctrl}]}>&-
		unset pid_ctrl[${_pid_ctrl}] fd_ctrl[${_pid_ctrl}] time_ctrl[${_pid_ctrl}]
		[[ -e ${sock_ctrl} ]] && rm -f ${sock_ctrl};;
	add|del|putkey|rmkey|status|smart|erase)
		exec {fd_ctrl[${_pid_ctrl}]}> >(daemon_control_${_cmd}) 
		pid_ctrl[${_pid_ctrl}]=$!
		time_ctrl[${_pid_ctrl}]=$(do_timer);;
	*)
		do_log debug "${myname} invalid control command \"${msg[@]:4}\"";;
	esac
	
	do_log debug2 "${myname} processing \"${msg[@]:4}\" took $(do_timer ${_time_start})s"
}

do_daemon_mount_crypt()
{
	local add_crypt="$1" add_dev="$2" add_pp="$3" add_trim="$4" add_time=$(do_timer) crypt_arr=() key="$(keyctl request user "$3" @s 2>/dev/null)" passphrase="" res=0
	do_log debug "${myname} mounting ${add_dev} as ${add_crypt} TRIM ${add_trim} with ${add_pp} passphrase"

	# The passphrase should be cached by now, error exit if not.
	if [[ -z "${key}" ]]; then
		do_log error "${myname} passphrase ${add_pp} not cached!" 
		unset cached_pp[${add_pp}]
		return 4
	fi
	passphrase="$(keyctl pipe "${key}" 2>/dev/null)"
	cached_pp[${add_pp}]=1

	# First check if the crypt is already mounted. If so, check if it's on the active list and add if not.	
	if dmsetup info "${add_crypt}" >/dev/null 2>&1; then
		[[ "$(lsblk -rD /dev/mapper/${add_crypt} |head -n2 |tail -n1 |cut -d" " -f3)" == "0B" ]] && add_trim=0 || add_trim=1
		if [[ -z "${active_mnt[${add_crypt}]}" ]]; then
			active_mnt[${add_crypt}]="${add_dev} ${add_pp} ${add_trim} ${add_time}"
			do_log debug "${myname} added ${add_dev} as ${add_crypt} TRIM ${add_trim} passphrase ${add_pp} to active list"
			return 0
		else
			crypt_arr=(${active_mnt[${add_crypt}]})
			do_log info "${myname} ${crypt_arr[0]} already active as ${add_crypt} TRIM ${crypt_arr[2]} passphrase ${crypt_arr[1]} since $(do_timer date ${crypt_arr[3]})"
			return 2
		fi
	else
		if [[ "$(lsblk -rD ${add_dev} |head -n2 |tail -n1 |cut -d" " -f3)" == "0B" ]]; then
			add_trim=0 res=3
			do_log info "${myname} requested TRIM for ${add_crypt} but device ${add_dev} does not support it"
		fi
		if cryptsetup open --type plain $([[ ${add_trim} -eq 1 ]] && echo "--allow-discards") "${add_dev}" "${add_crypt}" <<<"${passphrase}"; then
			# Mounted, add to active list.
			do_log info "${myname} mounted ${add_dev} as ${add_crypt} TRIM ${add_trim} passphrase ${_dd_pp}"
			do_log debug2 "${myname} mounting ${add_dev} as ${add_crypt} TRIM ${add_trim} passphrase \"${passphrase}\" took $(do_timer ${add_time})s"
			active_mnt[${add_crypt}]="${add_dev} ${add_pp} ${add_trim} ${add_time}"
			return ${res}
		else
			do_log error "${myname} error mounting ${add_dev} as ${add_crypt} TRIM ${add_trim} after $(do_timer ${add_time})s"
			start_status=1
			return 1
		fi
	fi
}

do_daemon_unmount_crypt()
{
	local _time_start=$(do_timer) del_crypt="$1" crypt_arr=()

	if dmsetup info "${del_crypt}" >/dev/null 2>&1; then
		crypt_arr=(${active_mnt[${del_crypt}]})
		if kpartx -d /dev/mapper/${del_crypt} && cryptsetup remove "${del_crypt}"; then
			do_log info "${myname} removed ${crypt_arr[0]} as ${del_crypt} TRIM ${crypt_arr[2]} passphrase ${crypt_arr[1]} mounted since $(do_timer date ${crypt_arr[3]})"
			do_log debug2 "${myname} removing ${del_crypt} took $(do_timer ${_time_start})s \"${!active_mnt[@]}\" \"${active_mnt[@]}\""
			unset active_mnt[${del_crypt}]
			do_log debug2 "${myname} removing ${del_crypt} took $(do_timer ${_time_start})s \"${!active_mnt[@]}\" \"${active_mnt[@]}\""
			return 0
		else
			do_log warning "${myname} failed to remove ${crypt_arr[0]} as ${del_crypt} TRIM ${crypt_arr[2]} passphrase ${crypt_arr[1]} mounted since $(do_timer date ${crypt_arr[3]})"
			[[ ${start_status} -eq 0 ]] && start_status=2
			return 1
		fi
	else
		do_log debug "${myname} crypt ${del_crypt} not present, skipping"
		unset active_mnt[${del_crypt}]
		[[ ${start_status} -eq 0 ]] && start_status=2
		return 2
	fi
}

# [END OF DAEMON READER FUNCTIONS]

# [BEGIN OF DAEMON CONTROL FUNCTIONS]
trap_term_control()
{
	trap 'do_log warning "${_myname} unclean exit after ${_time_start})s"; exit 1;' SIGINT SIGTERM

	[[ "$(cat /proc/${pid_socat}/comm)" == "socat" ]] && kill -SIGTERM ${pid_socat}
	[[ $1 -eq 0 ]] && do_log debug2 "${_myname} finished after $(do_timer ${_time_start})s"
	if [[ $1 -ne 0 ]]; then
		do_log debug2 "${_myname} terminating after $(do_timer ${_time_start})s"
		if [[ ! -z "${_socat_PID}" && "$(cat /proc/${_socat_PID}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_socat_PID}
			wait ${_socat_PID}
			do_log debug2 "${_myname} killed socat coproc (PID: ${_socat_PID})"
		fi
		if [[ ! -z "${_pid_putkey}" && "$(cat /proc/${_pid_putkey}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_putkey}
			wait ${_pid_putkey}
			do_log debug2 "${_myname} killed putkey worker (PID: ${_pid_putkey})"
		fi
		if [[ ! -z "${_pid_getpp}" ]]; then
			kill -SIGTERM ${_pid_getpp}
			wait ${_pid_getpp}
			do_log debug2 "${_myname} killed getpp worker (PID: ${_pid_getpp})"
		fi
		if [[ ! -z "${_pid_logwriter}" &&"$(cat /proc/${_pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			exec {fd_logwriter}>&-
			#kill -SIGTERM ${_pid_logwriter}
			wait ${_pid_logwriter}
		fi
	fi
	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}

	exit $1
}

daemon_control_status()
{
	# Connect to control socket and blurt status in some form of a pretty fashion.
	do_control_init "status" "Status Report"
	local _key _passphrase="" _waiting_mnt=${msg[5]} _tab_crypt __crypt_arr=() _crypt __crypt _pp _trim _time _status

	# Output the status to the coproc, which will transfer it to stdout of the requestor. First al active mounts.
	echo -e "\r${GREY}${BOLD}${PR}CRYPT${PD}DEVICE${PE}TRIM${PP}PASSPHRASE${PT}ACTIVE SINCE${PS}STATUS${NOR}\r" >&${_socat[1]}
	[[ -n "${bootconf[STORAGEPREFIX]}" ]] && __storageprefix="${bootconf[STORAGEPREFIX]}" || __storageprefix="storage"
	for _crypt in ${!active_mnt[@]}; do
		_status="" __crypt_arr=(${active_mnt[${_crypt}]}); _pp=${__crypt_arr[1]}
		[[ "${__crypt_arr[2]}" == "1" ]] && _trim="On" || _trim="Off"
		[[ "${__crypt_arr[1]}" == "-" && "${_crypt}" =~ ^${__storageprefix}[0-9]{1,2}$ && -n "${bootconf[STORAGEPP]}" ]] && _pp="$(do_eval_pp "${bootconf[STORAGEPP]}")" 
		[[ "${__crypt_arr[1]}" == "-" && "${_crypt}" =~ ^${__storageprefix}[0-9]{1,2}$ && -z "${bootconf[STORAGEPP]}" ]] && _pp="system:master" 
		[[ "${__crypt_arr[1]}" == "-" ]] && _status="${YEL}Online (U)" || _status="${GRN}Online (M)"
		echo -e "${PR}${_crypt}${PD}${__crypt_arr[0]##*/}${PE}${_trim}${PP}${_pp}${PT}$(do_timer date ${__crypt_arr[3]})${PS}${_status}${NOR}\r" >&${_socat[1]}
	done

	# Output all unmounted and waiting crypts.
	_tab_crypt="$(tr "\t" " " <<<"${crypttab}" |cut -d" " -f1)"
	for _crypt in ${_tab_crypt}; do
		for __crypt in ${!active_mnt[@]}; do
			[[ "${_crypt}" == "${__crypt}" ]] && continue 2
		done
		for __crypt in $(IFS=','; echo ${_waiting_mnt}); do
			__crypt_arr=($(IFS='|'; echo ${__crypt}))
			if [[ "${_crypt}" == "${__crypt_arr[1]}" ]]; then
				_status="${YEL}Waiting" _time=$(do_timer date ${__crypt_arr[4]})
				break
			fi
		done
		[[ ! "${_status}" == "${YEL}Waiting" ]] && _status="${RED}Offline" _time="-"
		__crypt_arr=($(do_xcrypt_fromtab "${_myname}" "${_crypt}"))
		[[ "${__crypt_arr[3]}" == "1" ]] && _trim="On" || _trim="Off"
		echo -e "${PR}${_crypt}${PD}${__crypt_arr[1]}${PE}${_trim}${PP}$(do_eval_pp ${__crypt_arr[2]})${PT}${_time}${PS}${_status}${NOR}\r" >&${_socat[1]}
	done
	echo >&${_socat[1]}

	# Output cached passphrases.
	[[ ${conf[LOGLEVEL]} -ge 1 ]] && echo -e "${PR}${GREY}${BOLD}Cached Passphrases:${PS}${NOR}${!cached_pp[@]}\r\n" >&${_socat[1]}
	if [[ ${conf[LOGLEVEL]} -ge 3 ]]; then
		# Output passphrases.
		echo -e "${PR}${GREY}${BOLD}PASSPHRASE${PS}VALUE${NOR}\r" >&${_socat[1]}
		for _pp in ${!cached_pp[@]}; do
			_key="$(keyctl request user "${_pp}" @s 2>/dev/null)"; _passphrase="$(keyctl pipe "${_key}" 2>/dev/null)"
			echo -ne "${PR}${_pp}:${PS}" >&${_socat[1]}
			if [[ -z "${_key}" ]]; then
				echo -e "${RED}${BOLD}FAIL${NOR}\r" >&${_socat[1]}
				echo "passphrase ${_pp} daemon 0" >${conf[FIFO]}
			else
				echo -e "\"${_passphrase}\"${NOR}\r" >&${_socat[1]}
			fi
		done
		echo >&${_socat[1]}
	fi
	echo -e "${UL}${myname} Running Since $(do_timer date ${time_start}) ($(do_timer ${time_start})s)${NOR}\r" >&${_socat[1]}

	trap_term_control 0
}

daemon_control_smarterase()
{
	# Secure Erase Device.
	[[ "${cmd}" == "smart" ]] && do_control_init "smart" "S.M.A.R.T." || do_control_init "erase" "Secure Erase"
	local _crypt="${_crypt_arr[0]}" _dev="$(do_find_dev "${_myname}" "${_crypt_arr[1]}")" _res=""

	if [[ -z "${_crypt_arr[@]}" ]]; then
		echo -e "\r${RED}${BOLD}${msg[5]} not Found on Crypttab.${NOR}\r" >&${_socat[1]}
		do_log debug "${_myname} ${msg[5]} not found on crypttab"
		trap_term_control 1
	elif [[ -z "${_dev}" ]]; then
		echo -e "\r${RED}${BOLD}Device ${_dev} not Found in ${conf[BLOCKDEVSDIRS]}.${NOR}\r" >&${_socat[1]}
		do_log debug "${_myname} ${_dev} not Found in ${conf[BLOCKDEVSDIRS]}"
		trap_term_control 1
	fi

	[[ ${_smartall} -eq 1 ]] && smartctl -x ${_dev} >&${_socat[1]} 2>&1 || smartctl -A ${_dev} >&${_socat[1]} 2>&1
	if [[ ${_smarttest} -eq 1 || "${cmd}" == "erase" ]] && dmsetup info "${_crypt}" >/dev/null 2>&1; then
		echo -e "\r${RED}${BOLD}${_crypt} Still Active.${NOR}\r" >&${_socat[1]}
		do_log debug "${_myname} ${_crypt} still active"
		trap_term_control 1
	fi

	if [[ "${cmd}" == "smart" && ${_smarttest} -eq 1 ]]; then
		smartctl -t long ${_dev} >&${_socat[1]} 2>&1
		do_log debug "${_myname} smart test started on ${_crypt}"
		echo -e "\r${GRN}${BOLD}Started SMART test on ${_dev}.${NOR}\r" >&${_socat[1]}
	elif [[ "${cmd}" == "erase" ]]; then
		do_control_confirm "This Will Wipe all Data on ${_dev}, Are You Sure? (y/N)" "n"
		if [[ "${_res}" == "y" ]]; then
			echo -e "${RED}${BOLD}Secure Erasing ${_dev} ${YEL}password: $(hostname)${NOR}\r" >&${_socat[1]}
			hdparm -I ${_dev} |grep "ENHANCED SECURITY ERASE UNIT" >/dev/null 2>&1 && _res="--security-erase-enhanced" || _res="--security-erase"
			hdparm --security-set-pass "$(hostname)" ${_dev}
			hdparm ${_res} "$(hostname)" ${_dev} &
			do_log debug "${_myname} secure erasing ${_crypt}"
		fi
	fi

	trap_term_control 0
}

daemon_control_putrmkey()
{
	# Remove the key file for the passphrase.
	[[ "${cmd}" == "rmkey" ]] && do_control_init "rmkey" "Removing Key File" || do_control_init "putkey" "Putting Key File"
	do_log debug "${_myname} YOYOYOYO f: ${_fw} c: ${_cache} s: ${_srv} add: ${_add} i: ${_confirm}"
	local _pp="$(do_eval_pp "${msg[5]}")" _res=0; local _keyfile="${conf[FWDIR]}/UglyLinux${_pp}.key-${conf[FWGUID]}" _key="$(keyctl request user "${_pp}" @s 2>/dev/null)" _passphrase _t _s
	if [[ ${_fw} -eq 0 && ${_cache} -eq -2 && "${_srv}" == "0" && ${_add} -eq -3 && ${_confirm} -eq 0 ]]; then
		[[ -n "${keylife[${_pp}]}" ]] && _cache="${keylife[${_pp}]}" || _cache=${conf[KEYLIFE]}
		_fw=1 _srv=${bootconf[BOOTSERVERS]} _add=-1 _confirm=1
	elif [[ ${_fw} -eq 0 && ${_cache} -eq -2 && "${_srv}" == "0" && ${_add} -eq -3 && ${_confirm} -eq 1 ]]; then
		[[ -n "${keylife[${_pp}]}" ]] && _cache="${keylife[${_pp}]}" || _cache=${conf[KEYLIFE]}
		_fw=1 _srv=${bootconf[BOOTSERVERS]} _add=-1 _confirm=0
	fi
	[[ "${_srv}" == "1" ]] && _srv=${bootconf[BOOTSERVERS]}
	[[ "${cmd}" == "rmkey" ]] && _s="Removing" _t="from" || _s="Putting" _t="to"
	do_log debug "${_myname} YOYOYOYO1 f: ${_fw} c: ${_cache} s: ${_srv} add: ${_add} i: ${_confirm}"
	do_log debug "${_myname} ${_s,,} ${_pp} ${_t,,} $([[ ${_cache} -ne -2 ]] && echo "cache ")$([[ ${_fw} -eq 1 ]] && echo "firmware ")$([[ "${_srv}" != "0" ]] && echo "${_srv}")"
	echo -e "\r${BOLD}${_s} ${_pp} ${_t}: $([[ ${_cache} -ne -2 ]] && echo "cache ")$([[ ${_fw} -eq 1 ]] && echo "firmware ")$([[ "${_srv}" != "0" ]] && echo "${_srv}")${NOR}\r" >&${_socat[1]}

	# Add or remove key to/from firmware
	[[ "${cmd}" == "putkey" ]] && ! do_control_get_passphrase "${_pp}" && trap_term_control 1
	if [[ "${cmd}" == "rmkey" && ${_fw} -eq 1 && ! -e ${_keyfile} ]]; then
		echo -e "\r${BOLD}${RED}${_keyfile} Does not Exist.${NOR}\r" >&${_socat[1]}
		do_log debug "${_myname} ${_keyfile} does not exist"
	elif  [[ ${_fw} -eq 1 ]]; then
		[[ ${_confirm} -eq 1 ]] && do_control_confirm "Continue ${_s} ${_pp} ${_t} Firmware? (Y/n)" "y" || _res="y"
		if [[ ${_res} == "y" ]]; then
			if [[ "${cmd}" == "rmkey" ]] && chattr -i ${_keyfile} && rm -f ${_keyfile}; then
				echo -e "\r${BOLD}${GRN}Removed ${_keyfile} Succesfully.${NOR}\r" >&${_socat[1]}
				do_log debug "${_myname} removed ${_keyfile}"
			elif [[ "${cmd}" == "putkey" ]] && do_write_keyfile "${_myname}" "${_pp}" "${_passphrase}"; then
				echo -e "\r${BOLD}${GRN}Wrote ${_keyfile} Succesfully.${NOR}\r" >&${_socat[1]}
				do_log debug "${_myname} wrote ${_keyfile}"
			else
				echo -e "\r${BOLD}${RED}Failed to $([[ "${cmd}" == "putkey" ]] && echo Write || echo Remove) ${_keyfile}.${NOR}\r" >&${_socat[1]}
				[[ "${cmd}" == "rmkey" ]] && do_log debug "${_myname} failed to remove ${_keyfile}"
			fi
		fi
	fi

	# Add or remove key to/from keyring.
	if [[ "${cmd}" == "rmkey" && ${_cache} -ne -2 && -z "${_key}" ]]; then
		do_log debug "${_myname} ${_pp} not cached"
		echo -e "\r${BOLD}${RED}${_pp} not Cached.${NOR}\r" >&${_socat[1]}
	elif [[ ${_cache} -ne -2 ]]; then
		[[ ${_confirm} -eq 1 ]] && do_control_confirm "Continue ${_s} ${_pp} ${_t} Cache? (Y/n)" "y" || _res="y"
		if [[ ${_res} == "y" ]]; then
			if [[ "${cmd}" == "rmkey" ]] && keyctl revoke "${_key}" >dev/null 2>&1 && keyctl unlink "${_key}" @s >/dev/null 2>&1; then
				echo "passphrase ${_pp} daemon 0" >${conf[FIFO]}
				echo -e "\r${BOLD}${GRN}Removed ${_pp} from Cache.${NOR}\r" >&${_socat[1]}
				do_log debug "${_myname} removed ${_pp} from cache"
			elif [[ "${cmd}" == "putkey" ]] && do_cache_pp "${_myname}" "${_pp}" "${_cache}" "${_passphrase}"; then
				echo "passphrase ${_pp} daemon 1" >${conf[FIFO]}
				echo -e "\r${BOLD}${GRN}Cached ${_pp} Passphrase.${NOR}\r" >&${_socat[1]}
			else
				echo -e "\r${BOLD}${RED}Failed to $([[ "${cmd}" == "rmkey" ]] && echo Remove || echo Cache) ${_pp} Passphrase$([[ "${cmd}" == "rmkey" ]] && echo " from Cache").${NOR}\r" >&${_socat[1]}
				[[ "${cmd}" == "rmkey" ]] && do_log debug "${_myname} failed to remove ${_pp} from cache"
			fi
		fi
	fi

	# Add or remove key to/from servers (cache).
	if [[ "${_srv}" != "0" ]]; then
		exec {__fd_user}>&${_socat[1]}
		[[ ${_confirm} -eq 1 ]] && do_control_confirm "Continue ${_s} ${_pp} ${_t} Boot Servers: ${NOR}${GREY}${_srv}${RED}${BOLD}? (Y/n)" "y" || _res="y"
		if [[ "${_res}" == "y" ]]; then
			echo -e "\r${BOLD}${GRN}${_s} ${_pp} Key ${_t} Boot Servers: ${GREY}${_srv}.${NOR}\r" >&${_socat[1]}
			do_log debug "${_myname} ${_s,,} ${_pp} key ${_t,,} boot servers: ${_srv}"
			[[ "${cmd}" == "putkey" ]] && key_clnt "PUT" "${_pp}" "${_passphrase}" ${_srv} & __pid_putkey=$!; wait ${__pid_putkey}
			[[ "${cmd}" == "rmkey" ]] && key_clnt "DEL" "${_pp}" ${_srv} & __pid_putkey=$!; wait ${__pid_putkey}
			echo -e "\r" >&${_socat[1]}
		fi
		[[ ${_add} -ne -3 && ${_confirm} -eq 1 ]] && do_control_confirm "Continue Adding ${_pp} ${_t} Boot Servers Cache: ${NOR}${GREY}${_srv}${RED}${BOLD}? (Y/n)" "y" || _res="y"
		if [[ "${_res}" == "y" && ${_add} -ne -3 ]]; then
			[[ ${_add} -eq -2 && -n "${keylife[${_pp}]}" ]] && _add=${keylife[${_pp}]}
			[[ ${_add} -eq -2 ]] && _add=${conf[KEYLIFE]}
			[[ "${cmd}" == "putkey" ]] && _s="Adding" _t="to" || _s="Deleting" _t="from"
			echo -e "\r${BOLD}${GRN}${_s} ${_pp} Key ${_t} Boot Servers Cache: ${GREY}${_srv}.${NOR}\r" >&${_socat[1]}
			do_log debug "${_myname} ${_s,,} ${_pp} key ${_t,,} boot servers cache: ${_srv}"
			[[ "${cmd}" == "putkey" ]] && key_clnt "ADD" "${_pp}" "${_add}" "${_passphrase}" ${_srv} & __pid_putkey=$!; wait ${__pid_putkey}
			[[ "${cmd}" == "rmkey" ]] && key_clnt "REM" "${_pp}" ${_srv} & __pid_putkey=$!; wait ${__pid_putkey}
			echo -e "\r" >&${_socat[1]}
		fi
	fi

	trap_term_control 0
}

daemon_control_del()
{
	# Remove and delete crypt from crypttab if requested.
	do_control_init "del" "Removing Crypt"
	local _del_crypt="${_crypt_arr[0]}" _del_dev="${_crypt_arr[1]}" _del_pp="${_crypt_arr[2]}" _del_trim="${_crypt_arr[3]}" _del_time="$(do_timer)" _res=""

	# Check if specified crypt is on tab, user decides to exit or continue if it's not.
	if [[ -z "${_crypt_arr[@]}" ]]; then
		_del_crypt=${msg[5]} _del_dev="?" _del_pp="?" _del_trim="?"
		do_log debug "${_myname} ${msg[5]} not found in Crypttab.${NOR}"
		echo -ne "\r${RED}${BOLD}${_del_crypt} not on Crypttab, Continue Removing (y/N)? ${NOR}" >&${_socat[1]}
		read -t${conf[USER_TIMEOUT]} -rsn1 -u ${_socat[0]} _res
		[[ "${_res,,}" == $'\r' || -z "${_res,,}" ]] && _res=n
		echo -e "${BOLD}${_res}${NOR}\r" >&${_socat[1]}
		[[ "${_res,,}" != "y" ]] && trap_term_control 0
		_crypttab=0 _del_dev="-" _del_pp="-"
	fi
	echo "notify ${_pid_ctrl} ${cmd} ${_del_crypt}" >${conf[FIFO]}
	read -t${conf[USER_TIMEOUT]} -r _res
	case ${_res} in
	0)
		do_log debug "${_myname} removed ${_del_dev##*/} as ${_del_crypt} using ${_del_pp} passphrase trim ${_del_trim}"
		echo -e "\r${BOLD}${GRN}Removed ${_del_dev##*/} as ${_del_crypt} Using ${_del_pp} TRIM ${_del_trim} Passphrase, Active Since $(do_timer date ${_del_time})${NOR}\r" >&${_socat[1]};;
	2)
		do_log debug "${_myname} ${_del_crypt} not active"
		echo -e "\r${BOLD}${YEL}${_del_crypt} not active${NOR}\r" >&${_socat[1]};;
	*)
		do_log debug "${_myname} failed to remove ${_del_dev##*/} as ${_del_crypt} using ${_del_pp} passphrase trim ${_del_trim}"
		echo -e "\r${BOLD}${RED}Failed to Remove ${_del_dev##*/} as ${_del_crypt} Using ${_del_pp} Passphrase TRIM ${_del_trim}${NOR}\r" >&${_socat[1]};;
	esac

	# Remove from crypttab.
	[[ ${_crypttab} -eq 1 && ( ${_res} -ne 0 || ${_confirm} -eq 1 ) ]] && do_control_confirm "Continue Removing ${_del_crypt} from Crypttab? (Y/n)" "y" || _res="y"
	if [[ ${_crypttab} -eq 1 && "${_res}" == "y" ]]; then
		sed -i "/^${_del_crypt}\\s/D" ${conf[CRYPTTAB]}
		kill -SIGHUP ${pid_daemon}
		do_log debug "${_myname} removed ${_del_dev##*/} as ${_del_crypt} using ${_del_pp} passphrase trim ${_del_trim} from crypttab"
		echo -e "\r${BOLD}${GRN}Removed ${_del_dev} as ${_del_crypt} TRIM ${_del_trim} from Crypttab${NOR}\r" >&${_socat[1]}
		kill -SIGHUP {pid_daemon}
	fi

	trap_term_control 0
}

daemon_control_add()
{
	# Add the crypt received on the cryptdiskd command line and to crypttab if requested.
	do_control_init "add" "Adding Crypt"
	local _add_crypt="${_crypt_arr[0]}" _add_dev="${msg[5]}" _add_dev2="${msg[6]}" _add_pp="${msg[7]}" _add_trim="${msg[8]}" _res="" __crypt_arr _passphrase=""
	
	if [[ ${_crypttab} -eq 0 && -z "${_crypt_arr[0]}" ]]; then
		# Recevied add with just a crypt, if it's not on the tab exit.
		echo -e "\r${BOLD}${RED}${msg[5]} not Found on Crypttab${NOR}\r" >&${_socat[1]}
		do_log debug "${_myname} ${msg[5]} not found on crypttab"
		trap_term_control 1
	elif [[ ${_crypttab} -eq 0 ]]; then
		_add_dev="$(do_find_dev "${_myname}" "${_crypt_arr[1]}")" _add_pp="$(do_eval_pp "${_crypt_arr[2]}")" _add_trim="${_crypt_arr[3]}"
	elif [[ ${_crypttab} -eq 1 ]]; then
		# Crypt should be added to tab, check if specified crypt and dev are already on tab.
		__crypt_arr=($(do_xcrypt_fromtab "${_myname}" "${_add_dev2}"))
		if [[ -z "${_crypt_arr[@]}" && -z "${__crypt_arr[@]}" ]]; then
			# Crypt and dev not on tab, find device.
			_add_dev="$(do_find_dev "${_myname}" "${_add_dev}")" _add_dev2="$(do_find_dev "${_myname}" "${_add_dev2}")"
			if [[ -z "${_add_dev}" && -z "${_add_dev2}}" ]]; then
				do_log debug "${_myname} neither ${_add_crypt} nor ${_add_dev} is a valid block device in ${conf[BLOCKDEVDIRS]}"
				echo -e "\r${BOLD}${RED}Neither ${_add_crypt} nor ${_add_dev} is a Valid Block Device in ${conf[BLOCKDEVDIRS]}.${NOR}\r" >&${_socat[1]}
				trap_term_control 1
			elif [[ ! -z "${_add_dev}" && ! -z "${_add_dev2}" ]]; then
				do_log debug "${_myname} both ${_add_crypt} and ${_add_dev} are valid block devices in ${conf[BLOCKDEVDIRS]}"
				echo -e  "\r${BOLD}${RED}Both ${_add_crypt} and ${_add_dev} are Valid Block Devices in ${conf[BLOCKDEVDIRS]}'.${NOR}\r" >&${_socat[1]}
				trap_term_control 1
			fi
			[[ ! -z "${_add_dev}" ]] && _add_crypt="${msg[6]}" || _add_crypt="${msg[5]}" _add_dev="${_add_dev2}"
		else
			# Crypt and/or dev already on tab.
			if [[ ! -z "${_crypt_arr[@]}" && ! -z "${__crypt_arr[@]}" ]]; then
				do_log debug "${_myname} both ${_add_crypt} and ${_add_dev} already on crypttab"
				echo -e "\r${BOLD}${RED}Both ${_add_crypt} and ${_add_dev} Already on Crypttab.${NOR}\r" >&${_socat[1]}
			elif [[ ! -z "${_crypt_arr[@]}" ]]; then
				do_log debug "${_myname} ${_add_dev} already on crypttab"
				echo -e "\r${BOLD}${RED}${_add_dev} Already on Crypttab.${NOR}\r" >&${_socat[1]}
			else
				do_log debug "${_myname} ${_add_dev2} already on crypttab"
				echo -e "\r${BOLD}${RED}${_add_dev2} Aready on Crypttab.${NOR}\r" >&${_socat[1]}
			fi
			trap_term_control 1
		fi
	fi
	if [[ ${_add_crypt}${_add_dev}${_add_pp} =~ ( |,|\||\$) || ( ${_crypttab} -eq 0 && -z "${_add_dev}" ) ]]; then
		do_log debug "${_myname} incorrect crypt or dev"
		[[ ${_crypttab} -eq 0 && -z "${_add_dev}" ]] && echo -e "\r${BOLD}${RED}${_crypt_arr[1]} not Found in \"${conf[BLOCKDEVDIRS]}\"${NOR}\r" >&${_socat[1]}
		[[ ! -z "${_add_dev}" ]] && echo -e "\r${BOLD}${RED}Illegal Characters \" $,|\" in Crypt or Dev.${NOR}\r" >&${_socat[1]}
		trap_term_control 1
	elif ! do_control_get_passphrase "${_add_pp}"; then
		# if we do not get a passphrase we cannot mount, continue to add on tab after confirmation.
		echo -e "\r${BOLD}${RED}No Passphrase Received, Cannot Mount ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase.${NOR}\r" >&${_socat[1]}
		_confirm=1
	elif ! do_cache_pp "${_myname}" "${_add_pp}" "-1" "${_passphrase}"; then
		echo -e "\r${BOLD}${RED}Failed to Cache ${_add_pp} Passphrase.${NOR}\r" >&${_socat[1]}
		trap_termcontrol 1
	else
		echo "notify ${_pid_ctrl} ${cmd} ${_add_crypt} ${_add_dev} ${_add_pp} ${_add_trim}" >${conf[FIFO]}
		echo "passphrase ${_add_pp} daemon 1" >${conf[FIFO]}
		read -t${conf[USER_TIMEOUT]} -r _res
		case ${_res} in
		0)
			do_log debug "${_myname} mounted ${_add_dev} as ${_add_crypt} trim ${_add_trim} using ${_add_pp} passphrase"
			echo -e "\r${BOLD}${GRN}Mounted ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase${NOR}\r" >&${_socat[1]};;
		1)
			do_log debug "${_myname} failed to mount ${_add_dev} as ${_add_crypt} trim ${_add_trim} using ${_add_pp} passphrase"
			echo -e "\r${BOLD}${RED}Failed to Mount ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase${NOR}\r" >&${_socat[1]};;
		2)
			do_log debug "${_myname} ${_add_dev} as ${_add_crypt} trim ${_add_trim} using ${_add_pp} passphrase already active"
			echo -e "\r${BOLD}${YEL}${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase Already Active${NOR}\r" >&${_socat[1]};;
		3)
			do_log debug "${_myname} mounted ${_add_dev} as ${_add_crypt} trim ${_add_trim} using ${_add_pp} passphrase"
			echo -e "\r${BOLD}${YEL}Mounted ${_add_dev} as ${_add_crypt} ${BOLD}${RED}TRIM ${_add_trim} ${BOLD}${YEL}Using ${_add_pp} Passphrase${NOR}\r" >&${_socat[1]};;
		*)
			do_log debug "${_myname} failed to mount ${_add_dev} as ${_add_crypt} trim ${_add_trim} using ${_add_pp} passphrase"
			echo -e "\r${BOLD}${RED}TIMEOUT or ERROR! (${_res})${NOR}\r" >&${_socat[1]}
			trap_term_control 1;;
		esac
	fi

	if [[ ${_crypttab} -eq 1 ]]; then
		# Crypt should be added to tab, ask for confirmation if necessary (error or request by user).
		[[ ${_res} -ne 0 || ${_confirm} -eq 1 ]] && do_control_confirm "Continue Adding ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase to Crypttab? (Y/n)" || _res="y"
		if [[ "${_res}" == "y" ]]; then
			# Add the crypt to the crypttab and send reload signal to daemon.
			echo -e "${_add_crypt}\t${_add_dev##*/}\t${_add_pp}\t${_add_trim}" >>${conf[CRYPTTAB]}
			do_log debug "${_myname} added ${_add_dev} as ${_add_crypt} passphrase ${_add_pp} trim ${_add_trim} to crypttab"
			echo -e "\r${BOLD}${GRN}Added ${_add_dev} as ${_add_crypt} Passphrase ${_add_pp} TRIM ${_add_trim} to Crypttab.${NOR}\r" >&${_socat[1]}
			kill -SIGHUP ${pid_daemon}
		fi
	fi
	[[ ${_confirm} -eq 1 ]] && do_control_confirm "Put ${_add_pp} Passphrase to Bootservers? (Y/n)" y || _res="y"
	if [[ "${_res}" == "y" ]]; then
		echo -e "\r${BOLD}${GRN}Putting ${_add_pp} Key to Boot Servers: ${GREY}${bootconf[BOOTSERVERS]}.${NOR}\r" >&${_socat[1]}
		exec {__fd_user}>&${_socat[1]}
		key_clnt "PUT" "${_add_pp}" "${_passphrase}" & _pid_putkey=$!; wait ${_pid_putkey}
		echo -e "\r" >&${_socat[1]}
	fi

	trap_term_control 0
}

do_control_init()
{
	trap 'trap_term_control' SIGINT SIGTERM

	_myname="daemon-$1 (${BASHPID}:${_pid_ctrl}):"
	# Start logwriter with dedicated logfile when LOGLEVEL=2 or = 4. When level = 4 redirect out stdout and stderr to the logwriter.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && _pid_logwriter="1>&${fd_logwriter} 2>&1"
		exec {fd_logwriter}> >(logwriter control-$1-${BASHPID}.log ${_pid_logwriter})
		_pid_logwriter=$!
	fi
	[[ "${cmd,,}" =~ ^(add|del|smart|erase)$ ]] && _crypt_arr=($(do_xcrypt_fromtab "${_myname}" "${msg[5]}"))
	
	# Check if socket exists first.
	if [[ ! -S ${sock_ctrl} ]]; then
		do_log error "${_myname} ${sock_ctrl} is not a socket, pocket rocket or a locket"
		trap_term_control 1
	fi

	# Open the client socket.
	do_log debug "${_myname} connecting to ${sock_ctrl}"
	coproc _socat ( socat - UNIX-CONNECT:${sock_ctrl} )
	[[ ${conf[LOGLEVEL]} -ge 3 ]] && echo -e "\r${_myname} Connected for $2.\r" >&${_socat[1]}

	# Check the command line, it should contain crypt, device and passphrase and two options (confirm / crypttab) for add or del.
	if [[ "${cmd}" == "smart" ]]; then
		_smartall=${msg[$((${#msg[@]}-2))]} _smarttest=${msg[$((${#msg[@]}-1))]}
	elif [[ "${cmd}" =~ ^(putkey|rmkey)$ ]]; then
		_confirm=${msg[$((${#msg[@]}-5))]} _add=${msg[$((${#msg[@]}-4))]} _cache=${msg[$((${#msg[@]}-3))]} _fw=${msg[$((${#msg[@]}-2))]} _srv=$(IFS=','; echo ${msg[$((${#msg[@]}-1))]})
	elif [[ "${cmd}" =~ ^(add|del)$ ]]; then
		_trim=${msg[$((${#msg[@]}-3))]} _confirm=${msg[$((${#msg[@]}-2))]} _crypttab=${msg[$((${#msg[@]}-1))]} 
	fi
	do_log debug "${_myname} control connection initialized (PID: ${_socat_PID} SOCK:${sock_ctrl})"
}

do_control_confirm()
{
	echo -ne "\r${RED}${BOLD}$1 ${NOR}" >&${_socat[1]}
	read -t${conf[USER_TIMEOUT]} -rsn1 -u ${_socat[0]} _res 
	[[ $? -ne 0 && $? -ne 142 ]] && trap_term_control 1
	[[ "${_res,,}" != "y" && "${_res,,}" != "n" ]] && _res=${2,,} || _res=${_res,,}
	echo -e "${BOLD}${_res}${NOR}\r" >&${_socat[1]}
}

do_control_get_passphrase()
{
	# Ask to get passphrase from network, if not cached, or query the user for the passphrase.
	local _key="$(keyctl request user "$1" @s 2>/dev/null)" _pp=$1 _res _fd_getpp _pid_getpp __fd_up __fd_user
	if [[ -n "${_key}" ]]; then
		# Passphrase is still cached, use it and notify the daemon about the crypt.
		_passphrase="$(keyctl pipe "${_key}" 2>/dev/null)"
		do_log "${_myname} found cached ${_pp} passphrase"
		echo -e "\r${BOLD}${GRN}Found Cached ${_pp} Passphrase${NOR}\r" >&${_socat[1]}
	else
		do_log "${_myname} ${_pp} passphrase not cached"
		echo -e "\r${BOLD}${RED}Passphrase ${_pp} not Cached.${NOR}\r" >&${_socat[1]}
	fi

	# If confirm option is specified ask to retreive passphrase from boot servers.
	if [[ -z "${_key}" && ( ${conf[NET_ONLINE]} -eq 0 || "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ (online|partial)$ ) ]]; then
		[[ ${_confirm} -eq 1 ]] && do_control_confirm "${_pp} Passphrase Not Cached, Get Passphrase from Boot Servers? (Y/n)" "y" || _res="y"
		if [[ "${_res}" == "y" ]]; then
			do_log debug "${_myname} getting ${_pp} passphrase from boot servers: ${bootconf[BOOTSERVERS]}"
			echo -e "\r${BOLD}Getting ${_pp} Passphrase from Boot Servers: ${NOR}${GREY}${bootconf[BOOTSERVERS]}${NOR}\r" >&${_socat[1]}
			exec {_fd_getpp}< <(key_clnt "GET" "${_pp}" {__fd_up}>&1- {__fd_user}>&${_socat[1]}-)
			_pid_getpp=$!
			read -t$((conf[PP_TIMEOUT]/conf[NET_RETRIES]+1)) -ru${_fd_getpp} _passphrase && _key=1 || echo -e "\r\n${RED}${BOLD}Failed to Get ${_pp} Passphrase from Boot Servers${NOR}\r" >&${_socat[1]}
			exec {_fd_getpp}>&-
			[[ "$(cat /proc/${_pid_getpp}/comm 2>/dev/null)" == "${MYNAME}" ]] && kill -SIGTERM ${_pid_getpp}
		fi
	fi

	# Query the user for the passphrase.
	if [[ -z "${_key}" ]]; then
		exec {_fd_getpp}< <(query_passphrase "${_pp}" {__fd_up}>&1- {__fd_user[0]}<&${_socat[0]}- {__fd_user[1]}>&${_socat[1]}-)
		_pid_getpp=$!
		if read -t${conf[PP_TIMEOUT]} -ru${_fd_getpp} _passphrase; then
			_key=1
		else
			do_log debug "${_myname} failed to get ${_pp} passphrase from user"
			echo -e "\r\n${RED}${BOLD}Failed to Get ${_pp} Passphrase from Your Yourself and You${NOR}\r" >&${_socat[1]}
		fi
		exec {_fd_getpp}>&-
		[[ "$(cat /proc/${_pid_getpp}/comm 2>/dev/null)" == "${MYNAME}" ]] && kill -SIGTERM ${_pid_getpp}
	fi

	# Got passphrase, put and cache it.
	if [[ -n "${_key}" ]]; then
		do_log debug "${_myname} got ${_pp} passphrase"
		[[ -z "${_passphrase}" ]] && echo -e "\r${BOLD}${YEL}Your ${_pp} Passphrase Has no Character, Just Like You.${NOR}\r" >&${_socat[1]}
		return 0
	else
		do_log debug "${_myname} ${_pp} passphrase error or timeout"
		return 1
	fi
}

# [END OF DAEMON CONTROL FUNCTIONS]

# [BEGIN OF DAEMON & READER SHARED FUNCTIONS]

do_xcrypt_fromtab()
{
	# Extract the line for the device received in the udev command from the crypttab into crypt_arr array.
	# Element 1 = cryptdisk name
	# Element 2 = cryptdisk block device
	# Element 3 = passphrase
	# Element 4 = TRIM
	local myname=$1 crypt_arr i
	for ((i=2;i<=$#;i++)); do
		crypt_arr=($(grep -iE "(^|\s)${!i}\s" <<<"${crypttab}" 2>/dev/null)) 
		[[ "${#crypt_arr[@]}" -eq 3 ]] && crypt_arr[3]=0
		if [[ "${#crypt_arr[@]}" -eq 0 ]]; then
			do_log debug "${myname} device ${!i} not found on crypttab"
		elif [[ "${#crypt_arr[@]}" -ne 4 || ${crypt_arr[0]}${crypt_arr[1]}${crypt_arr[2]} =~ (,| |\|\$) ]]; then
			do_log warning "${myname} incorrect crypttab entry ${crypt_arr[@]}"
			_status=2
		else
			do_log debug2 "${myname} device ${!i} found on crypttab"
			[[ "${crypt_arr[3]}" == "1" || "${crypt_arr[3],,}" == "y" || "${crypt_arr[3],,}" == "yes" ]] && crypt_arr[3]=1 || crypt_arr[3]=0
			echo "${crypt_arr[@]}"
			break
		fi
	done
}

do_eval_pp()
{
	# Evaluate the passphrase and prepend cryptdisks: or make system:master. 
  	if [[ ${1,,} =~ ^(1|master|system|system:master)$ ]]; then
   		echo "system:master"
	elif [[ ! ${1,,} =~ ^cryptdisks: ]]; then
		echo "cryptdisks:${1,,}"
	else 
		echo "${1,,}"
	fi
}

do_find_dev()
{
	local myname=$1 blockdevdir dev=$2
	for blockdevdir in ${conf[BLOCKDEVSDIRS]}; do if [[ -b ${blockdevdir}/${dev} ]]; then
		do_log debug "${myname} found ${blockdevdir}/${dev} for ${dev}"
		echo "${blockdevdir}/${dev}"
		return
	fi done
	do_log debug "${myname} ${dev} not found in ${conf[BLOCKDEVSDIRS]}"
}

do_check_passphrase()
{
	# Check the received passphrase against the stored key in firmware. Write key if it doesn't exist.
	local myname="$1" pp="$2" passphrase="$3" rmkey="$4"
	if [ -s ${conf[FWDIR]}/UglyLinux${pp}.key-${conf[FWGUID]} ]; then
		if  $(cat ${conf[FWDIR]}/UglyLinux${pp}.key-${conf[FWGUID]} | tail -c +5 | openssl aes-256-cbc -d -salt -pbkdf2 -in - -out /dev/null -k "${passphrase}" 2>/dev/null); then
			do_log debug "${myname} passphrase check ok"
			return 0
		else
			do_log debug "${myname} passphrase check fail"
			if [[ "${rmkey}" == "rmkey" ]]; then 
				chattr -i ${conf[FWDIR]}/UglyLinux${pp}.key-${conf[FWGUID]} 
				rm -f ${conf[FWDIR]}/UglyLinux${pp}.key-${conf[FWGUID]}
			fi
			return 1
		fi
	else
		do_write_keyfile "${myname}" "${pp}" "${passphrase}" || return 3
		do_log debug "${myname} passphrase not checked"
		return 2
	fi
}

do_write_keyfile()
{
	# Write a keyfile for key received to firmware.
	local myname=$1 pp="$2" passphrase="$3" srv="$4" keydir="$([[ -n "$4" ]] && echo ${conf[KEYDIR]} || echo ${conf[CRYPTDISKSDDIR]})" res
	if ! head -c256 /dev/urandom |openssl aes-256-cbc -e -salt -pbkdf2 -in - -out ${keydir}/${pp}.key -k "${passphrase}"; then
		res=1
		do_log error "${myname} error creating ${keydir}/${pp}.key"
	elif [[ -z "${srv}" ]] && ! efivar -n ${conf[FWGUID]}-UglyLinux${pp}.key -w -f ${conf[CRYPTDISKSDDIR]}/${pp}.key; then
		res=2
		do_log error "${myname} error writing ${conf[FWDIR]}/UglyLinux${pp}.key-${conf[FWGUID]}"
	else
		res=0
		do_log debug "${myname} wrote $([[ -z "${srv}" ]] && echo ${conf[FWDIR]}/UglyLinux${pp}.key-${conf[FWGUID]} || echo ${keydir}/${pp}.key)"
	fi
	[[ -z "${srv}" ]] && rm -f ${conf[CRYPTDISKSDDIR]}/${pp}.key
	return ${res}
}

do_cache_pp()
{
	local myname=$1 pp=$2 key="$(keyctl request user "$2" @s 2>/dev/null)" timeout="$3" passphrase="$4"
	[[ ${timeout} -eq -1 && -n "${keylife[$2]}" ]] && timeout=${keylife[$2]}
	[[ ${timeout} -eq -1 ]] && timeout=${conf[KEYLIFE]}
	
	# Cache if the passphrase is already cached.
	if [[ -z "${key}" ]]; then
		key="$(keyctl padd user "${pp}" @s <<<"${passphrase}" 2>/dev/null)"
		[[ ${timeout} -ne 0 ]] && keyctl timeout "${key}" "${timeout}"
	else
		do_log info "${myname} ${pp} passphrase already cached"
		return 2
	fi
	if [[ -z "${key}" ]]; then
		do_log warning "${myname} failed to cache ${pp} passphrase"
		return 1
	fi

	do_log debug "${myname} cached ${pp} passphrase $([[ ${timeout} -eq 0 ]] && echo indefinitely || echo "for $((timeout/60)) minutes")"
	return 0
}

# Query the user for a passphrase. We get called with 1 parameter, the passphrase to query.
# Also a fd redirection for {__fd_up} to relay the passphrase and {__fd_user[]} when interactively querying for cli.
trap_term_query_passphrase()
{
	trap 'do_log warning "${myname} unclean finish after $(do_timer ${_time_start})s"; exit 1;' SIGINT SIGTERM

	# Close the fd to the reader, we don't need it and should not keep it.
	if [[ ! -z "${pid_askpp}" && "$(cat /proc/${pid_askpp}/comm 2>/dev/null)" == "systemd-ask-pas" ]]; then
		kill -SIGKILL ${pid_askpp}
		do_log debug2 "${myname} killed ask worker (PID: ${pid_askpp})"
	fi

	do_log debug2 "${myname} terminating after $(do_timer ${_time_start})s"

	exit 0
}

query_passphrase()
{
	trap 'trap_term_query_passphrase' SIGINT SIGTERM

	# Ask for a pssphrase input by user through systemd-ask-password
	local myname="query:$1 (${BASHPID}):" _time_start=$(do_timer) pp=$1 pid_askpp fd_askpp passphrase _passphrase ppchk
	do_log debug "${myname} query for ${pp} passphrase started"

	do_ask_passphrase "Enter ${pp} Passphrase: " || trap_term_query_passphrase

	# Received a passphrase from the user check it against key stored in firmware.
	local ppchk=$(do_check_passphrase "${myname}" "${pp}" "${passphrase}")$?
	case ${ppchk} in
	3)
		do_log error "${myname} Unable to confirm passphrase due to key error, giving up"
		trap_term_query_passphrase;;
	2)
		# Key not present in firmware, ask for confirmation from the user.
		_passphrase="${passphrase}"
		do_ask_passphrase "Created key file. Confirm ${pp} Passphrase: " || trap_term_query_passphrase
		# If the passphrase does not match, enter a loop until it does and wirte the keyfile if ok.
		until [[ "${_passphrase}" == "${passphrase}" ]]; do
			do_ask_passphrase "Passphrases do not Match. Enter ${pp} Passphrase: " || trap_term_query_passphrase
			_passphrase="${passphrase}"
			do_check_passphrase "${myname}" "${pp}" "${passphrase}" rmkey
			do_ask_passphrase "Confirm ${pp} Passphrase: " || trap_term_query_passphrase
			[[ "${_passphrase}" == "${passphrase}" ]] && do_write_keyfile "${myname}" "${pp}" "${passphrase}"
		done
		do_log debug "${myname} received passphrase after $(do_timer ${_time_start})s";;
	1)
		# Passphrase entered does not match stored key, keep asking until it does.
		until [[ ${ppchk} -eq 0 ]]; do
			do_log debug2 "${myname} query passphrase check failed"
			do_ask_passphrase "Incorrect Passphrase. Enter ${pp} Passphrase: " || trap_term_query_passphrase
			ppchk=$(do_check_passphrase "${myname}" "${pp}" "${passphrase}")$?
		done
		do_log debug "${myname} received passphrase after $(do_timer ${_time_start})s";;
	0)
		# Passphrase received is ok.
		do_log debug "${myname} received passphrase after $(do_timer ${_time_start})s";;
	esac
 
 	# Notify the reader, so it knows passphrase worker has finished.
	echo "${passphrase}" >&${__fd_up}
	
	do_log debug2 "${myname} took $(do_timer ${_time_start})s total"
}

do_ask_passphrase()
{
	local CHAR DEL="$(printf "\x7F")"
	if [[ -z "${__fd_user[@]}" ]]; then
		# Query for the passphrase in the background, record pid so we can kill if passphrase is received from server.
		exec {fd_askpp}< <(NOTIFY_SOCKET= systemd-ask-password --timeout=0 --id=${pp} "$1" {__fd_up}>&-)
		pid_askpp=$!
		read -ru${fd_askpp} passphrase || exit 1
	else
		passphrase="" CHAR=""
		echo -ne "\r${BOLD}$1: ${NOR}" >&${__fd_user[1]}
		until [[ "${CHAR}" == $'\r' || "${CHAR}" == $'\n' ]]; do
		   	read -t${conf[USER_TIMEOUT]} -rsN1 -u${__fd_user[0]} CHAR || return 1
			if [[ "${CHAR}" == "${DEL}" && "${#passphrase}" -ge 1 ]]; then
				echo -ne "\b \b" >&${__fd_user[1]}
				passphrase="${passphrase::-1}"
			elif [[ "${CHAR}" != $'\r' && "${CHAR}" != $'\n' && "${CHAR}" != "${DEL}" ]]; then
				passphrase+="${CHAR}"
				echo -n "*" >&${__fd_user[1]}
			fi
		done
		echo -e "\r" >&${__fd_user[1]}
	fi
}

# [END OF DAEMON & READER SHARED FUNCTIONS]

# [BEGIN OF UDEV QUEUE READER FUNCTIONS

trap_term_reader()
{
	trap 'do_log warning "${_myname} unclean exit after $(do_timer ${_time_start})s"; exit 1;' SIGINT SIGTERM

	# Reader received SIGTERM or SIGINT. See if we have any workers to kill and remove the queue.
	_time_active="$(do_timer ${_time_start})"
	do_log debug2 "${_myname} terminating after ${_time_active}s"

	# Kill all active passphrase workers.
	local _pp
	for _pp in ${!_pid_ppwrk[@]}; do
		if [[ ! -z "${_pid_ppwrk[${_pp}]}" && "$(cat /proc/${_pid_ppwrk[${_pp}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_ppwrk[${_pp}]}
			wait ${_pid_ppwrk[${_pp}]}
			do_log debug2 "${_myname} killed passphrase worker for ${_pp} (PID: ${_pid_ppwrk[${_pp}]})"
		fi
	done
	for _pp in ${!_pid_putkey[@]}; do
		if [[ ! -z "${_pid_putkey[${_pp}]}" && "$(cat /proc/${_pid_putkey[${_pp}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_putkey[${_pp}]}
			wait ${_pid_putkey[${_pp}]}
			do_log debug2 "${_myname} killed putkey worker for ${_pp} (PID: ${_pid_putkey[${_pp}]})"
		fi
	done
	for _pp in ${!_pid_shell[@]}; do
		if [[ "$(cat /proc/${_pid_shell[${_pp}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_shell[${_pp}]}
			wait ${_pid_shell[${_pp}]}
		fi
	done
	# If we are in startup we should not be terminated, exit with error. Otherwise exit with current status.
	if [[ "${_starting}" -ne 0 ]]; then
		do_log error "${_myname} terminated while in startup"
	fi
	if [[ "$(cat /proc/${_pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${_pid_logwriter}
		wait ${_pid_logwriter}
	fi

	exit 0
}

trap_hup_reader()
{
	# Received reload request from systemd. Reload the config when not handling command and no active workers.
	_time_active=$(do_timer ${_time_start})
	if [[ ${_starting} -eq 0 && ${_confok} -eq 0 ]]; then
		do_log warning "${_myname} received SIGHUP, reload config asap"
		if [[ -z "${_cmd}" ]]; then
			do_reader_cleanup
			if [[ -z "${!_waiting_mnt[@]}" ]]; then
				do_reader_notify_daemon "reload"
				trap_term_reader
			fi
		fi
		_confok=1
	elif [[ ${_starting} -ne 0 ]]; then
		do_log warning "${_myname} start timeout reached after ${_time_active}s, running cleanup"
		_starting=0
		do_reader_cleanup
		echo "ping" >${conf[FIFO]}
	fi
}

udev_reader()
{
	trap 'trap_term_reader' SIGINT SIGTERM
	trap 'trap_hup_reader' SIGHUP

	# The reader process will read commands from the queue. When command is read some atomical stuff needs to be done
	# At the very least we should check for any running password workers, start worker process and keep track of them all.
	# Just like the daemon process the reader will run a cleanup timer and do cleanup every conf[CLEANUP_TIMER].
	local _pid_reader=${BASHPID} _myname="reader (${BASHPID}):" _time_start=$(do_timer) _time_active=0.000 _read_to __myname _cmd=() __waiting_mnt IFS
 	local _nr_cmds=0 _start_status=0 _cleanup=0.000 _pid_logwriter _key= _fd_fifo _pp _confok=0 _starting=${starting} _crypt_arr _crypt _dev _trim _time _res
	declare -A _pid_ppwrk _pid_putkey _pid_shell _waiting_mnt
	
	# Start logwriter with dedicated logfile when LOGLEVEL=2 or = 4. When level = 4 redirect out stdout and stderr to the logwriter.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && exec {fd_logwriter}> >(logwriter reader-${_pid_reader}.log {fd_daemon}>&-) 1>&${fd_logwriter} 2>&1 \
									  || exec {fd_logwriter}> >(logwriter reader-${_pid_reader}.log {fd_daemon}>&-)
		_pid_logwriter=$!
	fi
	do_log info "${_myname} initializing"
	[[ ${_starting} -eq 0 ]] && udevadm trigger -s block

	exec {_fd_fifo}<>${conf[FIFO]}
	while true; do
		# If we are starting up, read time-out when initial queue is empty so we can notify parent.
		# If we are in normal op, keep cleanup timer (60secs).
		do_log debug2 "${_myname} running since $(do_timer date ${_time_start})"
		time_active=$(do_timer ${time_start})

		# Rceived SIGHUP. Do a config reload (restart the reader), when no active workers.
		if [[ ${_starting} -eq 0 && ${_confok} -eq 1 && -z "${!_waiting_mnt[@]}" ]]; then
			do_reader_notify_daemon "reload"
			trap_term_reader
		fi

		# Evaluate the queue read timeout, to see at which point in time we are.
		[[ ${_confok} -eq 1 || ${time_active:0:-4} -gt $((${_cleanup:0:-4}+${conf[CLEANUP_TIMER]}-${conf[QUEUE_TIMEOUT]})) ]] && do_reader_cleanup
		[[ ${_confok} -eq 1 || ${_starting} -eq 1 ]] && _read_to=${conf[QUEUE_TIMEOUT]} \
													 || _read_to=$(((conf[CLEANUP_TIMER]+conf[QUEUE_TIMEOUT])-((${time_active:0:-4}+conf[CLEANUP_TIMER]/2)%conf[CLEANUP_TIMER])))
        
		# Start reading from the queue.
		unset IFS
		read -t${_read_to} -ru${_fd_fifo} -a _cmd
		_res=$?

		if [[ ${_res} -eq 142 ]]; then
			# Read timed out. Set the starting status if we are starting up, or run cleanup.
			# Cleanup will start after conf[START_TIMEOUT] to give all initial workers the chance to finish.
			[[ ${_starting} -ne 1 && ${_read_to##* } -gt $((conf[CLEANUP_TIMER]/2)) ]] && do_reader_cleanup
			if [[ ${_starting} -ne 0 ]]; then
				local __starting=${_starting}
				[[ -z "${!_waiting_mnt[@]}" ]] && _starting=0 || _starting=2
				[[ ${_starting} -eq 0 ]] && do_reader_cleanup 
				[[ ${__starting} != ${_starting} ]] && do_reader_notify_daemon "started ${_starting} ${_start_status}"
			fi
			continue
		elif [[ ${_res} -gt 128 ]]; then
			# Should not happen, only if we received signal during read.
			do_log debug "${_myname} read result ${_res} may have been trapped"
			[[ ${_cleanup} -eq 0 ]] && do_reader_cleanup
		elif [[ ${_res} -ne 0 || -z "${_cmd[@]}" ]]; then
			do_log error "${_myname} read error, terminating after $(do_timer ${_time_start})s"
			do_reader_notify_daemon "reload"
			trap_term_reader
		fi

		# Parse the command, the first element in the array is the command itself, the other elements the arguments to the command.
		# From UDEV we will receive add and remove commands with one paramter only, the disk.
		__myname="${_myname} ${_nr_cmds} -" __time_start=$(do_timer) _nr_cmds=$((_nr_cmds+1))
		do_log debug "${__myname} new command received \"${_cmd[@]}\""
		case ${_cmd[0],,} in
		add|change)
			_crypt_arr=($(do_xcrypt_fromtab "${__myname}" "${_cmd[@]:1}"))
			[[ ! -z "${_crypt_arr[@]}" ]] && do_reader_add_crypt;;
		remove)
			_crypt_arr=($(do_xcrypt_fromtab "${__myname}" "${_cmd[1]}"))
			[[ ! -z "${_crypt_arr[@]}" ]] && do_reader_notify_daemon "remove ${_crypt_arr[0]}";;
		passphrase)
			[[ ${_cmd[2]} == 0 ]] && do_log warning "${__myname} passphrase ${_cmd[1]} failed" || do_log info "${__myname} passphrase ${_cmd[1]} success"
			IFS=','
			for _key in ${_waiting_mnt[${_cmd[1]}]}; do
				IFS=' ' _crypt_arr=(${_key})
				if [[ ${_cmd[2]} == 0 ]]; then
					do_log info "${__myname} removed ${_crypt_arr[1]} as ${_crypt_arr[0]} TRIM ${_crypt_arr[2]} using ${_cmd[1]} passphrase, waited for $(do_timer ${_crypt_arr[3]})s"
				else
					do_log debug2 "${__myname} daemon can mount ${_crypt_arr[1]} as ${_crypt_arr[0]} TRIM ${_crypt_arr[2]} using ${_cmd[1]} passphrase, waited for $(do_timer ${_crypt_arr[3]})s"
					do_reader_notify_daemon "add ${_crypt_arr[0]} ${_crypt_arr[1]} ${_cmd[1]} ${_crypt_arr[2]}"
				fi
			done
			if [[ "${_cmd[2],,}" == "daemon" && -z "${_waiting_mnt[${_cmd[1]}]}" ]]; then
				do_reader_notify_daemon "passphrase ${_cmd[1]} ${_cmd[3]}"
				do_log info "${__myname} got ${_cmd[1]} passphrase from cli user, telling daemon"
			fi
			[[ -n "${_pid_ppwrk[${_cmd[1]}]}" && "$(cat /proc/${_pid_ppwrk[${_cmd[1]}]}/comm)" == "${MYNAME}" ]] && kill -SIGTERM ${_pid_ppwrk[${_cmd[1]}]}
			unset _waiting_mnt[${_cmd[1]}] _pid_ppwrk[${_cmd[1]}]
			if [[ ${_starting} -ne 0 && -z ${!_waiting_mnt[@]} ]]; then
				_starting=0
				do_reader_cleanup
				do_reader_notify_daemon "started ${_starting} ${_start_status}"
			fi;;
		control|notify)
			case ${_cmd[2],,} in
			status)
				__waiting_mnt=""
				for _pp in ${!_waiting_mnt[@]}; do IFS=','; for _key in ${_waiting_mnt[${_pp}]}; do
					IFS=' ' _crypt_arr=(${_key})
					do_log debug2 "${__myname} adding waiting crypt ${_crypt_arr[0]} to status report"
					__waiting_mnt+="${_pp}|${_crypt_arr[0]}|${_crypt_arr[1]}|${_crypt_arr[2]}|${_crypt_arr[3]},"
				done; done
				do_reader_notify_daemon "${_cmd[@]} ${__waiting_mnt}";;
			smart|erase|finished|add|del|putkey|rmkey)
				do_reader_notify_daemon "${_cmd[@]}";;
			shell)
				local pid_socat=${_cmd[1]##*,}
				reader_control_shell &
				_pid_shell[${_cmd[1]}]=$!;;
			*) 
				do_log debug "${__myname} received invalid control command \"${_cmd[@]:2}\"";;
			esac;;
		ping)
			do_log debug2 "${__myname} pong";;
		*)
			do_log debug "${__myname} received invalid command: \"${_cmd[@]}\"";;
		esac
		do_log debug2 "${__myname} processing command \"${_cmd[@]}\" took $(do_timer ${__time_start})s total"
	done

	# We should never get here, exit with error if we do.
	do_log error "${_myname} terminated unexpectedly after $(do_timer ${_time_start})s"
	trap_term_reader
}

do_reader_add_crypt()
{
	# The add command received from UDEV will contain 1 argument, the block device that is added.
	# At least a mount worker for adding the cryptdisk A passphrase worker process is spawned if there is not already 
	# one running for the passphrase. We will keep a list of passhrase workers and mount workers using that passphrase.
	local _add_crypt="${_crypt_arr[0]}"  _add_dev="$(do_find_dev "${__myname}" "${_crypt_arr[1]}")" _add_pp="$(do_eval_pp "${_crypt_arr[2]}")" _add_trim="${_crypt_arr[3]}" _key="" _passphrase="" _user=1
	_key="$(keyctl search @u user "${_add_pp}" 2>/dev/null)" && _passphrase="$(keyctl pipe "${_key}" 2>/dev/null)"
	
	# Set the variables for the crypt to be added, search for the backing device in conf[BLOCKDEVSDIRS].	
	do_log debug "${__myname} adding ${_crypt_arr[1]} as ${_add_crypt} TRIM ${_add_trim} using ${_add_pp} passphrase"
	if [[ -z "${_add_dev}" ]]; then
		do_log warning "${__myname} ${_crypt_arr[1]} not found in ${conf[BLOCKDEVSDIRS]}"
		[[ _start_status -eq 0 ]] && _start_status=2
		return
	elif [[ ! -z "${_key}" ]]; then
		do_log info "${__myname} found cached ${_add_pp} passphrase in user keyring"
		keyctl revoke "${_key}" 2>/dev/null
		keyctl unlink "${_key}" @u 2>/dev/null
		key_clnt "PUT" "${_add_pp}" "${_passphrase}" & _pid_putkey[${_add_pp}]=$!
		do_cache_pp "${__myname}" "${_add_pp}" "-1" "${_passphrase}"
		do_reader_notify_daemon "add ${_add_crypt} ${_add_dev} ${_add_pp} ${_add_trim}"
		return 
	elif [[ ! -z "$(keyctl request user "${_add_pp}" @s 2>/dev/null)" ]]; then
		# Passphrase is still cached, uotify the daemon about the crypt.
		do_log info "${__myname} found cached ${_add_pp} passphrase" 
		do_reader_notify_daemon "add ${_add_crypt} ${_add_dev} ${_add_pp} ${_add_trim}"
		return 
	elif grep -e "${_add_crypt} ${_add_dev} ${__app_trim} " <<<${_waiting_mnt[${_add_pp}]}; then
		# Check if crypt is already waiting
		do_log debug "${__myname} ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} already on waiting list"
		return
	fi

	# No worker and no passphrase cached, start new worker. If the crypt is already active the user will not be asked for passphrase.
	dmsetup info "${_add_crypt}" >/dev/null 2>&1 && _user=0
	do_log debug "${__myname} adding ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} to waiting list for ${_add_pp} passphrase"
	_waiting_mnt[${_add_pp}]+="${_add_crypt} ${_add_dev} ${_add_trim} $(do_timer),"
	do_log debug2 "${__myname} waiting mnt for ${_add_pp}: ${_waiting_mnt[${_add_pp}]:0:-1}"
	if [[ -z "${_pid_ppwrk[${_add_pp}]}" ]]; then
		do_log debug "${__myname} no cached passphrase or active worker for ${_add_pp}, starting"
		udev_reader_ppwrk "${_user}" &
		_pid_ppwrk[${_add_pp}]=$!
	fi

	do_log debug2 "${__myname} ${_cmd[0],,} ${_crypt_arr[@]} took $(do_timer ${__time_start})s"
}

do_reader_notify_daemon()
{
	[[ -z "${__myname}" ]] && local __myname="${_myname}"
	echo "reader ${_pid_reader} $@" >&${fd_daemon}
	do_log debug "${__myname} sent message \"$@\" to daemon (PID: ${pid_daemon})"
}

do_reader_cleanup()
{
	# Reader cleanup routine. Check all the active workers, se if they're still running, terminate after timeout.
	local __myname="reader cleanup (${BASHPID}):" __time_start=$(do_timer) __waiting_mnt="" IFS _crypt_arr _pp _mnt
	_cleanup=$(do_timer ${time_start}) _time_active=$(do_timer ${_time_start})
	do_log debug "${__myname} cleanup starting at ${_time_active}"

	# Check logwriter status, restart if necessary.
	[[ ! -z ${_pid_logwriter} ]] && if [[ "$(cat /proc/${_pid_logwriter}/comm 2>/dev/null)" != "${MYNAME}" ]] || ! kill -0 ${_pid_logwriter} && kill -SIGKILL ${_pid_logwriter}; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && exec {fd_logwriter}> >(logwriter reader-${_pid_reader}.log) {_fd_fifo}>&- 1>&${fd_logwriter} 2>&1 || exec {fd_logwriter}> >(logwriter reader-${_pid_reader}.log)
		do_log error "${__myname} logwriter (PID: ${_pid_logwriter}) terminated after ${_time_active}s, restarted"
		_pid_logwriter=$!
	fi

	# Cleanup shells.
	if [[ ! -z "${!_pid_shell[@]}" ]]; then for	_pp in ${!_pid_shell[@]}; do
		[[ "$(cat /proc/${_pid_shell[${_pp}]}/comm 2>/dev/null)" != "${MYNAME}" ]] && unset _pid_shell[${_pp}]
	done fi

	# Remove too long outstanding mounts and passphrase workers.
	for _pp in ${!_waiting_mnt[@]}; do
		IFS=',' __waiting_mnt=""
		for _mnt in ${_waiting_mnt[${_pp}]}; do
			IFS=" " _crypt_arr=(${_mnt})
			if [[ $(do_timer ${_crypt_arr[3]} |cut -d. -f1) -ge $([[ ${_starting} -eq 0 ]] && echo ${conf[PP_TIMEOUT]} || echo ${conf[START_TIMEOUT]}) ]]; then
				do_log debug "${__myname} cleanup removed waiting mount for ${_pp}: ${_crypt_arr[0]} - ${_crypt_arr[1]} - ${_crypt_arr[2]}"
			else
				do_log debug2 "${__myname} cleanup readded waiting mount for ${_pp}: ${_crypt_arr[0]} - ${_crypt_arr[1]} - ${_crypt_arr[2]}"
				__waiting_mnt+="${_crypt_arr[0]} ${_crypt_arr[1]} ${_crypt_arr[2]} ${_crypt_arr[3]},"
			fi
		done
		if [[ ! -z "${__waiting_mnt}" ]]; then
			_waiting_mnt[${_pp}]="${__waiting_mnt}"
		elif [[ -n "${_pid_ppwrk[S{_pp}]}" && "$(cat /proc/${_pid_ppwrk[${_pp}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_ppwrk[S{_pp}]}
			do_log debug "${__myname} killed passphrase worker for ${_pp} (PID: ${_pid_ppwrk[S{_pp}]})"
		else
			unset _waiting_mnt[${_pp}] _pid_ppwrk[${_pp}]
		fi
	done
	
	# Notify daemon we are still active.
	do_reader_notify_daemon "active"

	[[ -z "${!_pid_ppwrk[@]}" ]] && _pp="no active workers" || _pp="active workers for ${!_pid_ppwrk[@]}"	
	do_log debug2 "${__myname} cleanup done in $(do_timer ${__time_start})s, ${_pp}"
}

trap_term_ppwrk()
{
	trap 'do_log warning "${__myname} unclean exit after $(do_timer ${__time_start})s"; exit 1;' SIGINT SIGTERM

	# Kill the workers and exit.
	do_log debug2 "${__myname} terminating after $(do_timer ${__time_start})s"
	if [[ ! -z ${__pid_getpp} && "$(cat /proc/${__pid_getpp}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_getpp}
		wait ${__pid_getpp}
		do_log debug2 "${__myname} killed get worker (PID: ${__pid_getpp})"
	fi
	if [[ ! -z ${___pid_keyclnt} && "$(cat /proc/${___pid_keyclnt}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${___pid_keyclnt}
		wait ${___pid_keyclnt}
		do_log debug2 "${__myname} killed key client worker (PID: ${___pid_keyclnt})"
	fi
	if [[ ! -z ${___pid_querypp} && "$(cat /proc/${___pid_querypp}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${___pid_querypp}
		wait ${___pid_querypp}
		do_log debug2 "${__myname} killed query worker (PID: ${___pid_querypp})"
	fi
	if [[ ! -z "${__pid_logwriter}" && "$(cat /proc/${__pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_logwriter}
		wait ${__pid_logwriter}
		do_log debug2 "${__myname} killed log writer (PID: ${__pid_logwriter})"
	fi
	if [[ ! -z ${__pid_putkey} && "$(cat /proc/${__pid_putkey}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		[[ $1 -ne 0 ]] && kill -SIGTERM ${__pid_putkey}
		wait ${__pid_putkey}
		do_log debug2 "${__myname} killed put key worker (PID: ${__pid_putkey})"
	fi
	if [[ ! -z ${__pid_sleep} && "$(cat /proc/${__pid_sleep}/comm 2>/dev/null)" == "sleep" ]]; then
		[[ $1 -ne 0 ]] && kill -SIGTERM ${__pid_sleep}
		do_log debug2 "${__myname} killed sleep (PID: ${__pid_sleep})"
	fi

	exit $1
}

udev_reader_ppwrk()
{
	trap 'trap_term_ppwrk' SIGINT SIGTERM

	# We need to get a passphrase. We will start a worker to get the passphrase from the boot servers
	# and a worker to ask for the passphrase using systemd-ask-password after a few seconds.
	# We call ourselves first to provide the two workors with a common {__fd_up} to relay the passphrase.
	# If first parameter is 0 wel will not bother the user for a passphrase.
	local __pid_ppwrk=${BASHPID} __myname="passphrase:${_add_pp} (${BASHPID}):" __time_start=$(do_timer) __time_active

	if [[ $# -eq 2 ]]; then
		# Start key client, wait for a little bit if appropriate, start the query worker and wait.
		local ___pid_keyclnt ___pid_querypp __pid_getpp __pid_logwriter __pid_putkey __pid_sleep
		if [[ ${conf[NET_ONLINE]} -eq 0 || "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ (online|partial)$ ]]; then 
			key_clnt "GET" "${_add_pp}" & ___pid_keyclnt=$!
			do_log debug "${__myname} started key client (PID: ${___pid_keyclnt})"
			sleep $((2*conf[QUEUE_TIMEOUT])) & __pid_sleep=$!; wait ${__pid_sleep}
		fi
		if [[ $1 -eq 1 ]]; then
			query_passphrase ${_add_pp} & ___pid_querypp=$!
			do_log debug "${__myname} started query user (PID: ${___pid_querypp})"
		fi
		wait ${___pid_keyclnt} ${___pid_querypp}
		trap_term_ppwrk 0
	fi
		
	# Start a logwriter when LOGLEVEL = 2 or 4, redirect our stdout and stderr to that logwiter whenn level = 4.
	local __fd_up __fd_getpp __pid_getpp __pid_logwriter __pid_putkey __passphrase=""
	[[ ${FOREGROUND} -eq 0 && ${conf[LOGLEVEL]} -eq 2 ]] && exec {fd_logwriter}> >(logwriter passphrase-${_add_pp}-${__pid_ppwrk}.log)
	[[ ${FOREGROUND} -eq 0 && ${conf[LOGLEVEL]} -eq 4 ]] && exec {fd_logwriter}> >(logwriter passphrase-${_add_pp}-${__pid_ppwrk}.log) 1>&${fd_logwriter} 2>&1
	__pid_logwriter=$!
	do_log debug "${__myname} started"

	# When starting we will wait max PP_TIMEOUT for the network to come up, or fail.
	[[ ${conf[NET_ONLINE]} -eq 1 && ${_starting} -ne 0 ]] && until [[ "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ (online|partial)$ ]]; do
		sleep ${conf[QUEUE_TIMEOUT]} & __pid_sleep=$!; wait ${__pid_sleep}
		__time_active=$(do_timer ${__time_start})
		[[ ${__time_active%%.*} -ge ${conf[PP_TIMEOUT]} || "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ offline$ ]] && break
	done

	# Start the worker to get the passphrase from the boot servers or from the user. fd 4 will point back to us.
	exec {__fd_getpp}< <(udev_reader_ppwrk "$1" 1 {__fd_up}>&1-)
	__pid_getpp=$!
	do_log debug "${__myname} started get passphrase worker (PID: ${__pid_getpp})"

	# We should get a pssphrase or an empty response from the workers or timeout.
	[[ ${_starting} -ne 0 ]] && __to=${conf[START_TIMEOUT]} || __to=${conf[PP_TIMEOUT]}
	if ! read -t${__to} -u${__fd_getpp} __passphrase; then
		do_log warning "${__myname} $([[ $? -eq 142 ]] && echo timeout || echo failed) after $(do_timer ${__time_start})s"
		echo "passphrase ${_add_pp} 0" >${conf[FIFO]}
		trap_term_ppwrk 1
	fi

	# Put key (back) to servers, cache and send to reader.
	key_clnt "PUT" "${_add_pp}" "${__passphrase}" & __pid_putkey=$!
	do_cache_pp "${__myname}" "${_add_pp}" "-1" "${__passphrase}" || trap_term_ppwrk 1
	echo "passphrase ${_add_pp} 1" >${conf[FIFO]}

	do_log debug2 "${__myname} took $(do_timer ${__time_start})s"
	trap_term_ppwrk 0
}

reader_control_shell()
{
	trap 'trap_term_control' SIGINT SIGTERM 

	# Open a debug shell, will run under root so be careful with this.
	local __myname="reader-shell (${BASHPID}:${__pid_ctrl},${_pid_socat}):" __time_start=$(do_timer)
	local __socat_PID __pid_logwriter="" __pid_ctrl="${_cmd[1]%%,*}" __sock_ctrl="${conf[CRYPTDISKSDDIR]}/${MYNAME}-${_cmd[1]%%,*}.sock"

	# Start logwriter with dedicated logfile when LOGLEVEL=2 or = 4. When level = 4 redirect out stdout and stderr to the logwriter.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]]	&& exec {fd_logwriter}> >(logwriter shell-${_pid_reader}.log {_fd_fifo}>&- {fd_daemon}>&-) 1>&${fd_logwriter} 2>&1 \
										|| exec {fd_logwriter}> >(logwriter shell-${_pid_reader}.log {_fd_fifo}>&- {fd_daemon}>&-)
		__pid_logwriter=$!
	fi
	
	if [[ ! conf[DEBUGSHELL] -eq 1 ]]; then
		do_log error "${__myname} debug shell not enabled"
		kill -SIGTERM ${__pid_ctrl}
		trap_term_control 1
	fi
	
	# Open a connection to the listening socket. Check if it exists first.
	export LC_ALL=en_US.UTF-8
	TERM=xterm socat exec:"/bin/bash --login",pty,ctty,raw,stderr,sigint,setsid,sane UNIX-CONNECT:${__sock_ctrl} & __socat_PID=$!
	do_log warning "${__myname} debug shell started"
	wait ${__socat_PID}
	do_log warning "${__myname} debug shell ended"
	trap_term_control 0
}

# [END OF UDEV QUEUE READER FUNCTIONS]

# [BEGIN OF KEY SERVER & CLIENT FUNCTIONS]

# A simple keyserver for caching passphrases so that booting systems can get passphrases here.
# The server runs under a user account correspnding to the host they are for.
# All confi etc. is in that users home directory. Key life can be set as default and per passphrase in the config.
trap_term_systemd_keysrv()
{
	trap 'do_log warning "${myname} unclean exit after $(do_timer ${time_start})s"; exit 1;' SIGINT SIGTERM

	do_log warning "${myname} terminating after $(do_timer ${time_start})s"
	if [[ ! -z "${pid_logwriter}" && "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_logwriter}
		wait ${pid_logwriter}
		do_log debug2 "${myname} killed log writer (PID: ${pid_logwriter})"
	fi
	rm -f ${CONFDIR}/*.res

	exit 0
}

do_systemd_keysrv()
{
	trap 'trap_term_systemd_keysrv' SIGINT SIGTERM SIGHUP
	local fd_fifo pid msg cmd pp passphrase key timeout _conf="$(cat ${CONF})" res=0 IFS=' '
	declare -A cached_pp
	systemd-notify --ready --status="${myname}: Started on $(do_timer date ${time_start})"
	
	do_log debug "${myname} started on $(do_timer date ${time_start})"
	exec {fd_fifo}<>${conf[FIFO]}
	while true; do 
		do_log debug "${myname} running since $(do_timer date ${time_start})"
		systemd-notify WATCHDOG=1 WATCHDOG_USEC=$(((2*conf[CLEANUP_TIMER])*1000000))
		[[ "$(cat ${CONF})" != "${_conf}" ]] && break
		
		read -t${conf[CLEANUP_TIMER]} -ru${fd_fifo} -a msg
		case $? in
			142) continue;;
			0)   do_log debug "${myname} new command \"${msg[@]}\"";;
			*)   break
		esac
		for pp in ${!cached_pp[@]}; do if ! keyctl request user "${pp}" @s >/dev/null 2>&1; then
			do_log info "${myname} ${pp} passphrase has expired"
			unset cached_pp[${pp}]
		fi done

		pid="${msg[0]}" cmd="${msg[1]}" pp="$(do_eval_pp ${msg[2]})" timeout="${msg[3]}"
		if [[ ! ${pid} =~ ^[0-9]+$ || ! ${cmd} =~ ^(add|rem|get|put|del|status)$ || $((${#msg[@]}-3)) -gt 2 || ! -p ${cmd}.${pid}.res ]]; then
			do_log error "${myname} invalid command \"${msg[@]}\""
			continue
		fi

		case ${cmd} in
		add)
			passphrase="${msg[4]}"
			do_log debug "${myname} adding ${pp} key"
			[[ ! -f ${conf[KEYDIR]}/${pp}.key ]] && res=$(do_write_keyfile "${myname}" "${pp}" "${passphrase}" 1)$?
			[[ ${res} -ne 1 ]] && res=$(do_cache_pp "${myname}" "${pp}" "${timeout}" "${passphrase}" $timeout)$?
			[[ ${res} -eq 0 ]] && cached_pp[${pp}]="$(do_timer),${timeout}" && do_keysrv_send "OK"
			[[ ${res} -eq 1 ]] && do_keysrv_send "NOK"
			[[ ${res} -eq 2 ]] && do_keysrv_send "SAME";;
		rem)
			do_log debug "${myname} removing ${pp} key"
			key="$(keyctl request user "${pp}" @s 2>/dev/null)"
			if [[ -z "${key}" ]]; then
				do_log warning "${myname} REM of ${pp} passphrase not cached"
				do_keysrv_send "SAME"
			#elif ! keyctl revoke "${_key}" >/dev/null 2>&1 || ! keyctl unlink "${_key}" @s >/dev/null 2>&1; then
			elif ! keyctl revoke "${key}" || ! keyctl unlink "${key}" @s; then
				do_log warning "${myname} REM of ${pp} passphrase from cache failed"
				do_keysrv_send "NOK"
			else
				do_log info "${myname} REM of ${pp} passphrase from cache succeeded"
				unset cached_pp[${pp}]
				do_keysrv_send "OK"
			fi;;
		get)
			do_log debug "${myname} getting ${pp} key"
			key="$(keyctl request user ${pp} @s 2>/dev/null)"
			[[ ! -z "${key}" ]] && passphrase="$(keyctl pipe ${key} 2>/dev/null)"
			if [[ -z "${key}" ]] || ! openssl aes-256-cbc -d -salt -pbkdf2 -in ${conf[KEYDIR]}/${pp}.key -out /dev/null -k "${passphrase}"; then
				if [[ -z "${key}" ]]; then
					do_log info "${myname} did not find ${pp} passphrase for ${host}"
				else
					#The requstor has probably updated the key since it was loaded, revoke it.
					do_log warning "${myname} ${pp} passphrase for ${host} does not match stored key file, revoking."
					keyctl revoke ${key}
					keyctl unlink ${key} @s
				fi
				do_keysrv_send "NOK"
			else
				do_log info "${myname} found ${pp} passphrase for ${host}"
				do_keysrv_send "OK"
				do_keysrv_send "${passphrase}"
			fi;;
		put)
			passphrase="${msg[3]}"
			do_log debug "${myname} putting ${pp} key"
			if openssl aes-256-cbc -d -salt -pbkdf2 -in ${conf[KEYDIR]}/${pp}.key -out /dev/null -k "${passphrase}"; then
				do_log info "${myname} recevied $? passphrase ${pp} equal to stored passphrase"
				do_keysrv_send "SAME"
			elif ! do_write_keyfile "${myname}" "${pp}" "${passphrase}" 1; then
				do_log warning "${myname} PUT of passphrase ${pp} failed."
				do_keysrv_send "NOK"
			else
				do_log info "${myname} PUT of papssphrase ${pp} succeeded."
				do_keysrv_send "OK"
			fi;;
		del)
			do_log debug "${myname} deleting ${pp} key"
			if [[ ! -e ${conf[KEYDIR]}/${pp}.key ]]; then
				do_log warning "${myname} Key of Passphrase ${pp} does not exist"
				do_keysrv_send "SAME"
			elif rm ${conf[KEYDIR]}/${pp}.key; then
				do_log info "${myname} DEL of passphrase ${pp} succeeded"
				do_keysrv_send "OK"
			else
				do_log warning "${myname} DEL of passphrase ${pp} failed"
				do_keysrv_send "NOK"
			fi;;
		status)
			do_keysrv_send "${BOLD}${myname} Running Since $(do_timer date ${time_start})${NOR}"
			do_keysrv_send "${BOLD}Cached Passphrases: ${!cached_pp[@]}${NOR}"
			[[ ${conf[LOGLEVEL]} -ge 1 ]] && for pp in ${!cached_pp[@]}; do
				timeout=${cached_pp[${pp}]#*,}
				[[ ${timeout} -eq -1 && -n "${keylife[${pp}]}" ]] && timeout=${keylife[${pp}]}
				[[ ${timeout} -eq -1 ]] && timeout=${conf[KEYLIFE]}
				do_keysrv_send "${BOLD}${pp}: ${RED}\"$([[ ${conf[LOGLEVEL]} -ge 3 ]] && keyctl pipe "$(keyctl request user "${pp}" @s)")\"${NOR}${BOLD}, timeout: $((timeout-$(do_timer ${cached_pp[${pp}]%%,*} |cut -d'.' -f1)))s${NOR}"
			done
			do_keysrv_send ".";;
		esac
		rm -f ${cmd}.${pid}.res
	done

	systemd-notify --stopping --status="${myname}: Read Error ($?), terminating after $(do_timer ${time_start})s"
	trap_term_keysrv
}

do_keysrv_send()
{
	echo $@ >${cmd}.${pid}.res
}

# Key client executes commands on keyservers and relays the result back to caller, which may be user on cli.
# We expect to be called with two or three parameters, depending on the command. And optionally a list of servers.
# 1. The command (GET / PUT / DEL)
# 2. The passphrase name
# 3. In case of PUT, the passphrase
# In case of GET we also need a redirection for {__fd_up} and for cli a {__fd_user} to relay the passphrase / status.
trap_term_key_clnt()
{
	trap 'do_log warning "${myname} unclean exit after $(do_timer ${_time_start})s"; exit 1;' SIGINT SIGTERM

	# Reader received SIGTERM or SIGINT. See if we have any workers to kill and remove the queue.
	do_log debug2 "${myname} terminating after $(do_timer ${_time_start})s"

	for ts in ${pid_cmd}; do if [[ "$(cat /proc/${ts}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${ts}
		do_log debug2 "${myname} killed ${cmd} (PID: ${ts})"
		wait ${ts}
	fi done
	if [[ -n "${_pid_ssh}" && "$(cat /proc/${_pid_ssh}/comm 2>/dev/null)" == "ssh" ]]; then
		kill -SIGTERM ${_pid_ssh}
		do_log debug2 "${myname} killed ssh (PID: ${_pid_ssh})"
		wait ${_pid_ssh}
	fi
	if [[ -n "${pid_sleep}" && "$(cat /proc/${pid_sleep}/comm 2>/dev/null)" == "sleep" ]]; then
		kill -SIGTERM ${pid_sleep}
		do_log debug2 "${myname} killed sleep (PID: ${pid_sleep})"
	fi
	if [[ "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_logwriter}
		wait ${pid_logwriter}
	fi

	exit 0
}

key_clnt()
{
	trap 'trap_term_key_clnt' SIGINT SIGTERM

	local myname="${1,,}:$2 (${BASHPID}):" _time_start=$(do_timer) cmd="${1,,}" pp="$2" timeout kto to ts pid_logwriter pid_cmd pid_sleep passphrase="" srv res ret
	[[ "${cmd}" == "add" ]] && kto="$3" passphrase="$4" srv="$5" to="to"
	[[ "${cmd}" == "put" ]] && passphrase="$3" srv="$4" to="to"
	[[ ! ${cmd} =~ ^(put|add)$ ]] && srv="$3" to="from"
	[[ ${starting} -eq 0 ]] && timeout=${conf[PP_TIMEOUT]} || timeout=${conf[START_TIMEOUT]}
	[[ "${cmd}" == "get" ]] && timeout=$((timeout/(conf[NET_RETRIES]+1)))

	# If we are called with exactly one server, execute the command on that server.
	if [[ ( "${cmd}" == "add" && $# -eq 5 ) || ( "${cmd}" == "put" && $# -eq 4 ) || ( ! "${cmd}" =~ ^(put|add)$ && $# -eq 3 ) ]]; then
		local _pid_ssh pid_cmd pid_logwriter
		do_log debug "${myname} ${cmd} ${pp} key ${to} ${srv}"
		exec {fd_ssh}< <(ssh -i ${CONFDIR}/${bootconf[BOOTUSERKEY]} -o UserKnownHostsFile=${CONFDIR}/${bootconf[BOOTSERVERKEYS]} ${bootconf[BOOTUSER]}@${srv} "${cmd^^}" "${pp}" "${kto}" "${passphrase}")
		_pid_ssh=$!
		if ! read -t${timeout} -ru${fd_ssh} res || [[ "${cmd}" != "get" && ! "${res,,}" =~ ^(ok|same)$ ]]; then
			[[ $? -eq 142 ]] && ts="timeout" || ts="failed"
			[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${RED}${srv}${NOR} " >&${__fd_user}
			do_log warning "${myname} ${cmd} ${pp} key ${to} ${srv} for ${bootconf[BOOTUSER]} ${ts}"
		elif [[ "${cmd,,}" != "get" && "${res,,}" == "same" ]]; then
			[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${YEL}${srv}${NOR} " >&${__fd_user}
			do_log info "${myname} ${cmd} ${pp} key ${to} ${srv} for ${bootconf[BOOTUSER]} equal"
		elif [[ ( "${cmd,,}" != "get" && "${res,,}" == "ok" ) || ( "${cmd,,}" == "get" && $(do_check_passphrase "${myname}" "${pp}" "${res}")$? -ne 1 ) ]]; then
			[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${GRN}${srv}${NOR} " >&${__fd_user}
			do_log debug "${myname} ${cmd} ${pp} key ${to} ${srv} for ${bootconf[BOOTUSER]} succeeded"
			[[ "${cmd}" == "get" ]] && echo "${res}" >&${__fd_up}
		fi
		exit
	fi

	# When starting wait for network before trying to connect to servers.
	if [[ ${FOREGROUND} -eq 0 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && exec {fd_logwriter}> >(logwriter ${cmd}-${pp}-${BASHPID}.log) 1>&${fd_logwriter} 2>&1 || exec {fd_logwriter}> >(logwriter ${cmd}-${pp}-${BASHPID}.log)
		pid_logwriter=$!
	fi
	if [[ ${starting} -ne 0 && ${conf[NET_ONLINE]} -eq 1 ]]; then
		ts=$(do_timer) ret=0
		until [[ ${ret} -ge ${conf[START_TIMEOUT]} || "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ (online|partial)$ ]]; do
			sleep ${conf[QUEUE_TIMEOUT]} & pid_sleep=$!; wait ${pid_sleep}
			ret=$((ret+$(do_timer ${ts} |cut -d. -f1)))
		done
	fi

	# For every boot server on command line start a command sub shell. If no list of servers was specified use all.
	# We will not retry PUT or DEL as this should just work if the other side is set up. Also no retry for getting the passphrase for cli user.
	[[ ${cmd} == "add" ]] && srv="${@:5}" 
	[[ ${cmd} == "put" ]] && srv="${@:4}"
	[[ ! ${cmd} =~ ^(put|add)$ ]] && srv="${@:3}"
	[[ -z "${srv}" ]] && srv="${bootconf[BOOTSERVERS]}"
	do_log debug "${myname} ${cmd} ${pp} key ${to} boot servers: ${srv}"
	ret=0
	while [[ -n "${srv}" && ${ret} -le ${conf[NET_RETRIES]} ]]; do
		to=$(do_timer)
		for ts in ${srv}; do
			[[ "${cmd}" == "add" ]] && key_clnt "${cmd}" "${pp}" "${kto}" "${passphrase}" "${ts}" & pid_cmd+="$! "
			[[ "${cmd}" == "put" ]] && key_clnt "${cmd}" "${pp}" "${passphrase}" "${ts}" & pid_cmd+="$! "
			[[ ! ${cmd} =~ ^(put|add)$ ]] &&  key_clnt "${cmd}" "${pp}" "${ts}" & pid_cmd+="$! "
		done
		wait ${pid_cmd}
		[[ "${cmd}" != "get" || -n "${__fd_user}" ]] && unset srv || ret=$((ret+1))
		[[ "${cmd}" == "get" && -z "${__fd_user}" && ${ret} -le ${conf[NET_RETRIES]} ]] && sleep $((timeout-$(do_timer ${to} |cut -d'.' -f1))) & pid_sleep=$!; wait ${pid_sleep}
	done

	do_log debug2 "${myname} finished after $(do_timer ${_time_start})s"
}

do_sanboot()
{
	local myname="${MYNAME}-boot-${USER}" cmd="${1,,}" pp="$2" timeout="$([[ "${1,,}" == "add" ]] && echo $3)" passphrase="$([[ "${1,,}" == put ]] && echo "$3" || echo "$4")" fd_fifo res r
	if ! do_init_conf keyserver || ! mkfifo ${CONFDIR}/${cmd}.$$.res; then
		logger -p user.error "${myname}: initialization failed"
		return 1
	fi
	exec {fd_fifo}<>${CONFDIR}/${cmd}.$$.res
	echo "$$ ${cmd}" "${pp}" "${timeout}" "${passphrase}" >${conf[FIFO]}
	if ! read -t${conf[KEYSRV_TIMEOUT]} -ru${fd_fifo} res; then
		logger -p user.error "${myname}: no response received from keyserver"
		r=1
	elif [[ "${cmd}" == "get" && "${res,,}" == "nok" ]] || ! read -t${conf[KEYSRV_TIMEOUT]} -ru${fd_fifo} passphrase; then
		[[ $? -ne 0 ]]            && logger -p user.error "${myname}: no ${pp} passphrase received from keyserver"
		[[ "${res,,}" == "nok" ]] && logger -p user.error "${myname}: ${pp} passphrase not cached by keyserver"
		kill -SIGTERM ${PPID}
		r=1
	elif [[ "${cmd}" == "get" ]]; then
		logger -p user.info "${myname}: received ${pp} passphrase from keyserver"
		echo "${passphrase}" >&${out}
	elif [[ "${cmd}" == "put" ]]; then
		[[ "${res,,}" == "same" ]] && r=2 && logger -p user.info "${myname}: ${pp} passphrase equal to stored passphrase on keyserver"
		[[ "${res,,}" == "nok" ]]  && r=1 && logger -p user.warning "${myname}: failed to put ${pp} passphrase to keyserver"
		[[ "${res,,}" == "ok" ]]   && r=0 && logger -p user.info "${myname}: put ${pp} passphrase to keyserver succeeded"
	elif [[ "${cmd}" == "del" ]]; then
		[[ "${res,,}" == "same" ]] && r=2 && logger -p user.info "${myname}: ${pp} passphrase not stored on keyserver"
		[[ "${res,,}" == "nok" ]]  && r=1 && logger -p user.warning "${myname}: failed to remove ${pp} passphrase from keyserver"
		[[ "${res,,}" == "ok" ]]   && r=0 && logger -p user.info "${myname}: removing ${pp} passphrase from keyserver succeeded"
	elif [[ "${cmd}" == "add" ]]; then
		[[ "${res,,}" == "same" ]] && r=2 && logger -p user.info "${myname}: ${pp} passphrase already cached on keyserver"
		[[ "${res,,}" == "nok" ]]  && r=1 && logger -p user.warning "${myname}: failed to cache ${pp} passphrase on keyserver"
		[[ "${res,,}" == "ok" ]]   && r=0 && logger -p user.info "${myname}: adding ${pp} passphrase to keyserver cache succeeded"
	elif [[ "${cmd}" == "add" ]]; then
		[[ "${res,,}" == "same" ]] && r=2 && logger -p user.info "${myname}: ${pp} passphrase already cached on keyserver"
		[[ "${res,,}" == "nok" ]]  && r=1 && logger -p user.warning "${myname}: failed to cache ${pp} passphrase on keyserver"
		[[ "${res,,}" == "ok" ]]   && r=0 && logger -p user.info "${myname}: adding ${pp} passphrase to keyserver cache succeeded"
	fi

	[[ "${cmd}" != "get" ]] && echo "${res}" >&${out}
	rm -f ${CONFDIR}/${cmd}.$$.res
	return ${r}
}

do_bootsan()
{
	# Set HOME to host(user) homedir and initialize config.
	local HOME=$(getent passwd $2 |cut -d':' -f6 2>/dev/null) host=$2 passphrase pp key f fd_fifo res r=0
	if [[ -z "${HOME}" ]] || ! do_init_conf keyserver; then
		echo -e "${RED}${BOLD}Unable to Initialize$([[ -z "${HOME}" ]] && echo ", ${host} is not a Valid Host" || echo " Config").${NOR}"
		exit 1
	fi
	cd ${CONFDIR}
	[[ -f host.conf ]] && . host.conf

	# Ask the passphrase for every key present. And send add command to keyserver.
	exec {__fd_user[0]}<&0 {__fd_user[1]}>&1
	for f in ${conf[KEYDIR]}/*.key; do
	    key=${f##*/} && pp=${key%.*}
		if [[ "${key}" != "*" ]]; then
			do_ask_passphrase "Enter ${pp} Passphrase: " || break
			until openssl aes-256-cbc -d -salt -pbkdf2 -in ${f} -out /dev/null -k "${passphrase}" >/dev/null 2>&1; do
		        do_ask_passphrase "Incorrect Password. Enter ${pp} Passphrase: " || break
			done
			r=$(mkfifo ${CONFDIR}/add.$$.res)? 
			[[ ${r} -ne 0 ]] && break
			exec {fd_fifo}<>${CONFDIR}/add.$$.res
			echo "$$ add ${pp} ${timeout} ${passphrase}" >${conf[FIFO]}
			read -t${conf[USER_TIMEOUT]} -ru${fd_fifo} res
			[[ $? -ne 0 || "${res,,}" == "nok" ]] && echo "Failed to Cache ${pp} Pasphrase."
			[[ "${res,,}" == "same" ]] && echo "${pp} Pasphrase Already Cached."
		else
			echo "No Stored Passphrases for ${host}"
			exit 1
		fi
	done

	[[ ${r} -ne 0 ]] && echo -e "${BOLD}${RED}Error, Cannot Create FIFO for Response.${NOR}"
	# Wake-up System.
	[[ -n "${MAC}" && -n "${INTERFACE}" ]] && sudo /usr/sbin/etherwake -i "${INTERFACE}" -b "${MAC}"
}

# [END OF KEY SERVER & CLIENT FUNCTIONS]

# [START OF UDEV PROCESSING FUNCTIONS]

do_cryptdisksd_udev()
{
	[[ -z "${conf[FIFO]}" ]] && conf[FIFO]=/run/${MYNAME}/${MYNAME}.queue

	# Parse the udev command line and prepare the message to be put on the queue. Udev can only be run by root.
	if [[ ${UID} -ne 0 || -z "${ACTION}" ]]; then
		echo "${MYNAME} udev queue can only be started from udev"
		exit 1
	fi

	# Prepare the message, first check if there is a confdir specified on command line, or load from systemd if not so.
	local msg="${ACTION}" command=udev
	if [[ -z "${CONFDIR}" ]]; then
		local dir="$(grep -ie "^CONFDIR=\/" /etc/systemd/${MYNAME}.conf)"
		CONFDIR="${dir##*=}"
	fi
	shift
	
	# Enter a loop to check if any of the arguments specified is a command, error exit if so, add parameter to message if ok.
	while [[ ! -z "$1" ]]; do
		do_parse_opt $@
		[[ $? -eq 0 ]] && msg+=" $1" || logger -p daemon.error "${MYNAME} cannot name crypt or dev \"$1\""
		shift
	done

	# Put the message (if any) on the queue.
	[[ "${msg}" == "${ACTION}" ]] && exit 1 || echo "$@" >${conf[FIFO]} 
}

# [END OF UDEV PROCESSING FUNCTIONS]

# [START OF INTERACTIVE CONTROL FUNCTIONS]

do_echo_use()
{
	[[ -z "${conf[RUNDIR]}" ]] && { do_init_conf || echo -e "${RED}${MYNAME}, Error Loading Configuration from ${CONFDIR}${NOR}"; }
	echo -e "${GREY}${BOLD}${MYNAME} (Encrypted Block Device Manager)${NOR}\n"
	case $1 in
	status)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tDisplays Status of Encrypted Block Devices"
		echo -e "\t\t\t\tCommand Has no Options or Arguments\n";;
	stop)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tStops the Encrypted Device Manager"
		echo -e "\t\t\t\tCommand Has no Options or Arguments\n";;
	reload)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tReloads the Configuration of the Encrypted Device Manager"
		echo -e "\t\t\t\tCommand Has no Options or Arguments\n";;
	add)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tAdd an Encrypted Block Device to the Manager\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hct ] { crypt | device } || { -p passphrase crypt device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-i${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
		echo -e "\t${BOLD}-p {passphrase}${NOR}\tUse {passphrase} for Crypt"
		echo -e "\t${BOLD}-t${NOR}\t\tEnable TRIM for Crypt\n\n"
		echo -e "The $1 Command Can Be Used it Two Ways.\nThe First ( ${BOLD}[ -i ] { crypt | device }${NOR} ) Will Add a Crypt or Device Which is Already on the Crypttab"
		echo -e "The Second ( ${BOLD}[ -i ] { -p passphrase crypt device }${NOR} ) Will Add a crypt (and Corresponding Backing Device) to the Crypttab\nThe Option '${BOLD}-p passphrase${NOR}' Must Be Specified in the Second Case\n"
		echo -e "The Options and Arguments Can Be Specified in any Order"
		echo -e "${BOLD}${UL}${MYNAME} $1 -p passphrase crypt device${NOR}\tand\t${BOLD}${UL}${MYNAME} $1 crypt -i\n${MYNAME} $1 crypt -i device -p passphrase${NOR}\tand\t${BOLD}${UL}${MYNAME} $1 -t device -p passphrase crypt -i${NOR}"
		echo -e "Are All Valid $1 Command Specifications\n"			
		echo -e "The ${MYNAME} Will Look for Block Devices in \"${BOLD}${conf[BLOCKDEVSDIRS]}${NOR}\"\n";;
	del)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tRemove an Encrypted Block Device from the Manager\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -htc ] { crypt | device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-i${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
		echo -e "\t${BOLD}-t${NOR}\t\tRemove the crypt (and Corresponding Backing Device) from the Crypttab\n\n"
		echo -e "The Options and Arguments Can Be Specified in any Order\n";;
	putkey)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tPut Key File to Boot Servers\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h -c -s (-a -l) -f -k HOST ] passphrase${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-i${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
		echo -e "\t${BOLD}-k${NOR}\t\tPut key only to local keyserver for HOST"
		echo -e "\t${BOLD}-c${NOR}\t\tPut key only to cache"
		echo -e "\t${BOLD}-f${NOR}\t\tPut key only to firmware"
		echo -e "\t${BOLD}-s${NOR}\t\tPut key only to servers"
		echo -e "\t${BOLD}-a${NOR}\t\tPut key to servers cache"
		echo -e "\t${BOLD}-l${NOR}\t\tUse local configured timeout values instead of keyserver values\n"
		echo -e "The option -i is a confirmation flag, when no other options are specified\nit disables confirmation, enables confirmation otherwise"
		echo -e "The options -s -f -c can be combined to put key to these places only\With -c an optional timeout can be specified, if not configured values are used"
		echo -e "With -s a server can be specified and this may occur more than once\nIt may only occur once without server to remove from all servers"
		echo -e "Multiple servers can be specified with , as separator"
		echo -e "When -s is used, -a will also add passphrase to boot servers cache\nOptionally a timeout for the passphrase can be specified"	
		echo -e "When -a is used without a timeout value, by default the keyserver timeout values are used\nWith -l the locally configured timeout values will be used"
		echo -e "${BOLD}${UL}(\"-s\" and \"-s server1 -s server2,server3\" are valid but \"-s -s server1\" or \"-s server1 -s\" are not.)${NOR}"
		echo -e "${BOLD}${MYNAME} putkey { passphrase }${NOR}\t\t- without any option puts key to everywhere asking for confirmation each step"
		echo -e "${BOLD}${MYNAME} putkey -i { passphrase }${NOR}\t\t- puts key to everywhere not asking for confirmation"
		echo -e "${BOLD}${MYNAME} putkey -i -c -f { passphrase }${NOR}\t- puts key to specified locations asking for confirmation"
		echo -e "${BOLD}${MYNAME} putkey -c -f { passphrase }${NOR}\t- puts key to specified locations not asking for confirmation";;
	rmkey)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tRemove Key File from Firmware and/or Boot Servers\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h -c -s (-a) -f -k ] passphrase${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-i${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
		echo -e "\t${BOLD}-k${NOR}\t\tRemove key only from local keyserver for HOST"
		echo -e "\t${BOLD}-c${NOR}\t\tRemove key only from cache"
		echo -e "\t${BOLD}-f${NOR}\t\tRemove key only from firmware"
		echo -e "\t${BOLD}-s${NOR}\t\tRemove key only from servers"
		echo -e "\t${BOLD}-a${NOR}\t\tRemove key from servers cache\n"
		echo -e "The option -i is a confirmation flag, when no other options are specified\nit disables confirmation, enables confirmation otherwise"
		echo -e "The options -s -f -c can be combined to remove key from these places only"
		echo -e "With -s a server can be specified and this may occur more than once\nIt may only occur once without server to remove from all servers"
		echo -e "Multiple servers can be specified with , as separator"
		echo -e "When -s is used, -a can be used to also remove passphrase from boot servers cache"
		echo -e "${BOLD}${UL}(\"-s\" and \"-s server1 -s server2,server3\" are valid but \"-s -s server1\" or \"-s server1 -s\" are not.)${NOR}"
		echo -e "${BOLD}${MYNAME} rmkey { passphrase }${NOR}\t\t- without any option removes key from everywhere asking for confirmation each step"
		echo -e "${BOLD}${MYNAME} rmkey -i { passphrase }${NOR}\t\t- removes key from everywhere not asking for confirmation"
		echo -e "${BOLD}${MYNAME} rmkey -i -c -f { passphrase }${NOR}\t- removes key from specified locations asking for confirmation"
		echo -e "${BOLD}${MYNAME} rmkey -c -f { passphrase }${NOR}\t- removes key from specified locations not asking for confirmation";;
	smart)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tShow S.M.A.R.T. Information for Backing Device\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hax ] {crypt | device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-a|-x${NOR}\t\tShow all S.M.A.R.T. information (Only Atrributes Otherwise)"
		echo -e "\t${BOLD}-t${NOR}\t\tRun S.M.A.R.T. Long Self Test on Device\n";;
	erase)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tSecure Erase Device\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h ] {crypt | device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text";;
	keyserver)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tSecure Erase Device\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h | -f | status HOST ]${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-f${NOR}\t\tRun in Foreground (Debug) Mode. Can not be Started by root"
		echo -e "\t${BOLD}status HOST${NOR}\tDisplay Status of Keyserver for HOST";;
	bootsan)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tAdd Keys to Keyserver and Start Host\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h | -t timeout } HOST${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e " \t${BOLD}-t${NOR}\t\tSpecify Timeout Overriding Config\n";;
	*)
		echo -e " Usage:\n\t${BOLD}${MYNAME} { [ -hdf ] ${UL}COMMAND ...${NOR} }\n"
		echo -e "\tEncrypted Block Devices Manager, Command Line Requires at Least one Option or Command"
		echo -e "\tMultiple Commands May Be Specified in Order, Commands Can Have Multiple Options and Arguments"
		echo -e "\tAll Commands Options and Arguments Are cAsE iNSensItiVe, except for ${UL}Device Names${NOR}\n"
		echo -e "\tUse ${UL}${BOLD}${MYNAME} command -h${NOR} To Display Help for That Command${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-d${NOR}\t\tSet Configuration Directory (${BOLD}${UL}Default: /etc/${MYNAME:0:-1}.d${NOR})"
		echo -e "\t${BOLD}-f${NOR}\t\tRun in Foreground (Debug) Mode. Can Only be Started by root"
		echo -e "\n\n Commands:\n\t${BOLD}status${NOR}\t\tDisplays Status of Encrypted Block Device Manager"
		echo -e "\t${BOLD}smart${NOR}\t\tDisplay S.M.A.R.T. Status of Encrypted Block Device"
		echo -e "\t${BOLD}erase${NOR}\t\tSecure Erase Encrypted Block Device"
		echo -e "\t${BOLD}stop${NOR}\t\tStop the Encrypted Device Manager"
		echo -e "\t${BOLD}reload${NOR}\t\tReload the Configuration of the Encrypted Device Manager"
		echo -e "\t${BOLD}add${NOR}\t\tAdd Encrypted Block Device to Manager"
		echo -e "\t${BOLD}del${NOR}\t\tDelete Encrypted Block Device from Manager"
		echo -e "\t${BOLD}putkey${NOR}\t\tPut Keyfile (Passphrase) to Boot Servers"
		echo -e "\t${BOLD}rmkey${NOR}\t\tRemove Keyfile (Passphrase) from Firmware"
		echo -e "\t${BOLD}keyserver${NOR}\tKeyserver Start or Status\n"
		echo -e "\t${BOLD}bootsan${NOR}\tAdd Keys to Keyserver and Start Host\n";;
	esac
	exit 127
}

do_parse_opt()
{
	# Parse command line options (-h -d -f). Function is run from main cli to parse as first options given.
	# Function can also run from the parse cmds function, it that case only -d option can be valid.
	local opt; OPTIND=1; getopts :fFd:D:hHiIlLcCaAxXk:K:sSp:P:tT opt
	opt="${opt,,}"
	case ${opt} in
	h|:) # if -h is specified as a command line option echo usage for the command running if run from parse cmds.
		do_echo_use "${command}";;
	a) # Option for smart -x or add to bootserver cache for putkey/rmkey
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(smart|putkey|rmkey)$ ]] && do_echo_use "${command}"
		if [[ "${command,,}" == "smart" ]]; then
			smartall=1
		else
			[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
			[[ ${_add} == "1" ]] && _add=0
			[[ ${_cache} == "1" ]] && _cache=0
			[[ -n "${add}" ]] && do_echo_use "${command}"
			add=-1 _add=1
		fi
		return 1;;
	k) # Option to put/del key from/to local keyserver..
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(putkey|rmkey)$ ]] && do_echo_use "${command}"
		[[ -n "${ks}" || -z "${OPTARG}" ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		ks="${OPTARG}"
		return $((OPTIND-1));;
	l) # option for using local timeout values instead of keyserver values when adding keys to keyserver cache.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(putkey|rmkey)$ || ${loc} -ne 0 ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		loc=1
		return 1;;
	x) # Option for smart -x
		[[ ${cmd} -eq 0 || ! "${command,,}" == "smart" ]] && do_echo_use "${command}"
		smartall=1
		return 1;;
	i) # Option to ask for confirmation for non critical actions.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(add|del|putkey|rmkey)$ ]] && do_echo_use "${command}"
		[[  ${confirm} -eq 1 ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		confirm=1
		return 1;;
	c) # Option to add/remove key from cache.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(putkey|rmkey)$ || ${key} -eq 1 ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		cache=-1 _cache=1
		return 1;;
	p) # Option to specify a passphrase name for the new crypt to be added to the crypttab.
		[[ ${cmd} -eq 0 || ! "${command,,}" == "add" ]] && do_echo_use "${command}"
		[[ ${crypttab} -eq 1 || -z "${OPTARG}" ]] && do_echo_use "${command}"
		crypttab=1
		pp="${OPTARG}"
		return $((OPTIND-1));;
	s) # Option to remove key from boot servers. We keep _srv to track how option is used
	   # 1 for first time option is encountered, 2 for consecutive. May only contain server names when it occurs more than once.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(putkey|rmkey)$ ]] && do_echo_use "${command}"
		[[ ${srv} == "1" || ${_srv} -eq 1 ]] && do_echo_use "${command}"
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		[[ -z "${srv}" ]] && _srv=1 srv=1 || _srv=2
		return 1;;
	t) # Option trim enable foor add, remove crypt from crypttap for del command. Or Run smart self test.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(add|del|smart|bootsan)$ ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		if [[ "${command}" == "bootsan" ]]; then
			[[ -n "${timeout}" ]] && do_echo_use "${command}"
			timeout=-1
		elif [[ "${command}" == "add" ]]; then
			[[ ${add_trim} -eq 1 ]] && do_echo_use "${command}"
			add_trim=1
		elif [[ "${command}" == "del" ]]; then
			[[  ${crypttab} -eq 1 ]] && do_echo_use "${command}"
			crypttab=1
		elif [[ "${command}" == "smart" ]]; then
			[[  ${smarttest} -eq 1 ]] && do_echo_use "${command}"
			smarttest=1
		fi
		return 1;;
	d) # Set configuration directory. If no dir specified echo usage. Option is only valid for global, not for command.
		[[ ${cmd} -eq 1 ]] && do_echo_use "${command}"
		[[ ! -d ${OPTARG} ]] && echo "Configuration Directory ${OPTARG} Does not Exist"
		[[ ! -d ${OPTARG} || ${_conf} -ne 0 ]] && do_echo_use "${command}"
		_conf=1
		CONFDIR=${OPTARG}
		# Shift the parameters and check if more arguments specified, continue with processing options if so.
		[[ $# -ge ${OPTIND} ]] && return $((OPTIND-1))
		shift $((OPTIND-1));;
	f) # Flag to run in foreground mode. Option to remove key from firmware.
		[[ ( ${cmd} -eq 1 && ! "${command,,}" =~ ^(putkey|rmkey)$ ) || ${FOREGROUND} -eq 1 ]] && do_echo_use "${command}"
		if [[ "${command}" =~ ^(putkey|rmkey)$ ]]; then
			[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
			[[ ${_add} == "1" ]] && _add=0
			[[ ${_cache} == "1" ]] && _cache=0
			[[ ${fw} -eq 1 ]] && do_echo_use "${command}"
			fw=1
			return 1
		fi
		FOREGROUND=1
		# If there are more options continue parsing. -f can only be followed by -d.
		shift
		[[ ! -z "$1" ]] && return 1;;
	?) # If run from parse cmds function, we need to check if the option specified matches a known command.
	   # If that is the case we have reached the end of the current command and can start processing the next.
		if [[ ${cmd} -eq 1 || ${_srv} -ge 1 ]]; then
			if [[ ! -z "$1" ]]; then 
				if ! do_parse_cmd check $1; then
					next_cmd=1
				else
					# We may get here if put/rmkey command contains -s server options. Check here if it was specified without server before.
					# If this is the last word in the command return 0 because we are done and it is the keynamen, not a server.
					[[ ${_srv} -eq 2 && ${srv} == 1 ]] && do_echo_use "${command}"
					if [[ ${timeout} == "-1" ]]; then
						[[ ! ${!OPTIND} =~ ^[0-9]+$ ]] && do_echo_use "${command}"
						timeout=$((${!OPTIND}*60))
						return 1
					fi
					[[ ${_add} -ne 1 && ${_cache} -ne 1 ]] && ( [[ -z "$2" ]] || ! do_parse_cmd check $2 ) && return 0
					if [[ ${_srv} -ge 1 ]]; then
						[[ ${srv} == "1" ]] && srv=""
						srv+="${!OPTIND}," _srv=0
						return 1
					elif [[ ${cache} == "-1" || ${add} == "-1" ]]; then
						[[ ! ${!OPTIND} =~ ^[0-9]+$ ]] && do_echo_use "${command}"
						[[ "${add}" == "-1" ]] && add=$((${!OPTIND}*60)) _add=0 || cache=$((${!OPTIND}*60)) _cache=0
						return 1
					fi
				fi
			else
				# If there are no more arguments set to process next command, which will be none.
				next_cmd=1
			fi
		fi;;
	esac

	# Check rmkey server option for validity. If -s server was specified before and now only -s this is an error and we catch it here.
	[[ ${_srv} -eq 2 ]] && do_echo_use "${command}"
	[[ ${_srv} -eq 1 ]] && _srv=0

	# All options are evaluated or confdir specified, initialize the configuration.
	if [[ ${cmd} -eq 0 && ( ${_conf} -eq 1 || -z "$1" ) ]]; then
		if ! do_init_conf; then
			echo "Error loading configuration from ${CONFDIR}"; exit 1
		else
			_conf=1
		fi
	fi

	# If foreground mode was requested execute. Echo command usage if specified in wrong place.
	if [[ ${FOREGROUND} -eq 1 ]]; then
		# If -f is not first option specified, it must be last (after -d) and no more options can be present.
		[[ ${nr} -gt 1 && ! -z "$1" ]] && do_echo_use "${command}"
		# Start in debug/foreground mode.
		if [[ ${UID} -ne 0 && $# -le 1 ]]; then
			echo "${MYNAME} foreground can only be started as root"; exit 1
		fi
		echo "loglevel=${conf[LOGLEVEL]}"
		do_systemd_daemon_start
		exit $?
	fi

	# Return 1 if next command is found, 0 otherwise.
	[[ ${next_cmd} -eq 1 ]] && return 1
	return 0
}

do_parse_cmd()
{
	# Parse the commands specified on the command line, one by one. If called with check, then return 1 on match.
	# This is to let the parse opt function know a match for a new command has been found.
	local command="${1,,}" check msg="$1 " s timeout=""
	if [[ "${command}" == "check" ]]; then 
		shift
		command="${1,,}" check=1;
	fi
	case ${command} in
	udev)
		[[ ${check} -eq 1 ]] && return 1
		do_cmd_parseopt $@
		do_init_conf || return 1
		do_cryptdisksd_udev $@
		return $#;;
	stop)
		[[ ${check} -eq 1 ]] && return 1
		do_cmd_parseopt $@
		do_init_conf || return 1
		/bin/kill -SIGTERM $(cat ${conf[PIDFILE]})
		return $#;;
	reload)
		[[ ${check} -eq 1 ]] && return 1
		do_cmd_parseopt $@
		do_init_conf || return 1
		/bin/kill -SIGHUP $(cat ${conf[PIDFILE]})
		return 1;;
	status|shell|add|del|putkey|rmkey|smart|erase)
		[[ ${check} -eq 1 ]] && return 1
		do_cryptdisksd_cmd $@
		return $?;;
	bootsan)
		[[ ${check} -eq 1 ]] && return 1
		do_cmd_parseopt $@
		s=$?
		do_init_conf || return ${s}
		[[ $(wc -w <<<"${msg}") -ne 2 || "${timeout}" == "-1" ]] && do_echo_use "${command}"
		[[ -z "${timeout}" ]] && timeout=-1
		do_bootsan ${msg}
		return ${s};;
	*)
		[[ ${check} -ne 1 ]] && do_echo_use "${command}"
		return 0;;
	esac
	return 0
}

do_cmd_parseopt()
{
	# If there are more arguments to process, check for command options or or for a new command to be processed.
	local next_cmd=0 res s=0 _srv=0
	shift
	while [[ ${next_cmd} -eq 0 ]]; do
		do_parse_opt $@
		res=$? 
		if [[ ${res} -eq 0 ]]; then
			msg+="$1 "
			shift
			s=$((s+1))
		else
			shift ${res}
			s=$((s+res))
		fi
	done
	return ${s}
}

trap_term_cryptdisksd_cmd()
{
	trap 'echo "${RED}${MYNAME} unclean finish${NOR}"; exit 1;' SIGINT SIGTERM

	# Kill socat coproc if still active and remove the socket if still present. Restore stdin to the tty.
	if [[ ! -z "${pid_socat}" && "$(cat /proc/${pid_socat}/comm 2>/dev/null)" == "socat" ]]; then
		kill -SIGTERM ${pid_socat}
		[[ ${conf[LOGLEVEL]} -gt 2 ]] && echo -e "\rKilled ${pid_socat}"
	fi
	if [[ -e ${conf[CRYPTDISKSDDIR]}/${sock} ]]; then
		rm -f ${conf[CRYPTDISKSDDIR]}/${sock}
		echo -e "\rRemoved ${conf[CRYPTDISKSDDIR]}/${sock}\r\n"
	fi
	exec 0<&${stdin}-
	stty sane
	echo -e "${NOR}\r"
	exit 1
}

do_cryptdisksd_cmd()
{
	trap 'trap_term_cryptdisksd_cmd' SIGINT SIGTERM

	local crypttab=0 confirm=0 smartall=0 smarttest=0 cache="" _cache=0 fw=0 srv="" add="" _add=0 loc=0 pp="" ks="" add_trim=0 msg="$1 " stty_opt="" s c sock pid_socat stdin passphrase _passphrase
	# Parse the options to the command and store the nr. of paramters to shift in s.
	do_cmd_parseopt $@
	s=$?

	if [[ -n "${ks}" ]]; then 
		# First put or del key to local keyserver
		HOME=$(getent passwd ${ks} |cut -d':' -f6 2>/dev/null) pp="$(do_eval_pp ${msg#* })"
		[[ "${command,,}" == "rmkey" ]] && c=del || c=put
		if [[ -z "${HOME}" ]] || ! do_init_conf keyserver || ! mkfifo ${CONFDIR}/${c}.$$.res; then
			echo "Unable to Initialize$([[ -z "${HOME}" ]] && echo ", ${ks} is not a Valid Host")."
			exit 1
		elif [[ "${command,,}" == "putkey" ]]; then
			exec {__fd_user[0]}<&0 {__fd_user[1]}>&1
			do_ask_passphrase "Enter ${pp} Passphrase: " || return ${s}
			_passphrase="${passphrase}"
			do_ask_passphrase "Confirm ${pp} Passphrase: " || return ${s}
			until [[ "${passphrase}" == "${_passphrase}" ]]; do
				passphrase="" _pasphrase=""
		        do_ask_passphrase "Passhrases do not Match. Enter ${pp} Passphrase: " || return ${s}
				_passphrase="${passphrase}"
				do_ask_passphrase "Confirm ${pp} Passphrase: " || return ${s}
			done
		fi
		exec {fd}<>${CONFDIR}/${c}.$$.res
		echo "$$" "${c}" "${pp}" "${passphrase}" >${conf[FIFO]}
		read -t${conf[QUEUE_TIMEOUT]} -ru${fd} res || exit
		[[ $? -ne 0 || "${res,,}" == "nok" ]] && echo "Failed to Put ${pp} Pasphrase."
		[[ "${res,,}" == "same" ]] && echo "${pp} Pasphrase Equal to Stored Passphrase."
		[[ -z "${srv}" && ${fw} -eq 0 && -z "${cache}" ]] && return ${s}
	fi

	# Reload config, necessary when executing put to local keyserver.
	unset conf
	do_init_conf || exit 1
	sock=${conf[CRYPTDISKSDDIR]}/${MYNAME}-${BASHPID}.sock
	if [[ ! "$(NOTIFY_SOCKET= systemctl is-active ${MYNAME:0:-1}.service 2>&1)" =~ activating|active ]]; then
		echo "${MYNAME} not Running"
		exit 1
	fi
	
	# Start socat in background and attach stdin, listen on a socket in RUNDIR. 
	# The daemon will spawn a worker which will connect and start interactive session.
	exec {stdin}<&0
	socat -t${conf[QUEUE_TIMEOUT]} - UNIX-LISTEN:${sock},unlink-early,unlink-close,group=${conf[CRYPTDISKSD_GROUP]},mode=600 0<&${stdin}- &
	pid_socat=$!

	case ${command} in
	add)
		if [[ ${crypttab} -eq 1 ]]; then
			[[ $(wc -w <<<"${msg}") -ne 3 ]] && do_echo_use "${command}"
		else
			[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		fi
		msg+="${pp} ${add_trim} ${confirm} ${crypttab}"
		stty_opt="raw -echo isig";;
	del)
		[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		msg+="${confirm} ${crypttab}"
		stty_opt="raw -echo isig";;
	status)
		[[ $(wc -w <<<"${msg}") -ne 1 ]] && do_echo_use "${command}"
		stty_opt="raw -echo isig";;
	smart)
		[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		msg+="${smartall} ${smarttest}"
		stty_opt="-echo isig";;
	putkey)
		[[ -z "${srv}" ]] && srv=0; [[ -z "${cache}" ]] && cache=-2; [[ -z "${add}" ]] && add=-3; [[ ${add} -eq -1 && ${loc} -eq 1 ]] && add=-2; pp=${msg#* }
		echo "M: ${msg} P: ${pp} C: ${cache} F: ${fw} A: ${add} L: ${loc} S: ${srv} K: ${ks} I: ${confirm}"
		[[ $(wc -w <<<"${msg}") -ne 2 || ( ${loc} -eq 1 && ( ${add} -eq -3 || ${add} -ge 0 ) ) || ( ${add} -ne -3 && "${srv}" == "0" ) ]] && do_echo_use "${command}"
		msg+="${confirm} ${add} ${cache} ${fw} ${srv}"
		stty_opt="raw -echo isig";;
	rmkey)
		echo "M: ${msg} P: ${pp} C: ${cache} F: ${fw} A: ${add} L: ${loc} S: ${srv} K: ${ks} I: ${confirm}"
		[[ $(wc -w <<<"${msg}") -ne 2 || ${loc} -eq 1 || ( -n "${add}" && ( ${add} -ne -1 || -z "${srv}" ) ) || ( -n "${cache}" && ${cache} -ne -1 ) ]] && do_echo_use "${command}"
		[[ -z "${srv}" ]] && srv=0; [[ -z "${cache}" ]] && cache=-2; [[ -z "${add}" ]] && add=-3; [[ ${add} -eq -1 && ${loc} -eq 1 ]] && add=-2; pp=${msg#* }
		echo "M: ${msg} P: ${pp} C: ${cache} F: ${fw} A: ${add} L: ${loc} S: ${srv} K: ${ks} I: ${confirm}"
		msg+="${confirm} ${add} ${cache} ${fw} ${srv}"
		stty_opt="raw -echo isig";;
	shell)
		[[ $(wc -w <<<"${msg}") -ne 1 ]] && do_echo_use "${command}"
		stty_opt="raw -echo -isig";;
	*)
		[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		msg+="${confirm}"
		stty_opt="raw -echo isig";;
	esac

	# Notify the daemon to connect to the socket and wait until it's finished. Then restore stdin and exit.
	stty ${stty_opt}
	[[ ${conf[LOGLEVEL]} -gt 2 ]] && echo -e "Requesting \"$@\" \"${msg}\" from ${MYNAME} - ${conf[FIFO]}\r"
	echo "control ${BASHPID},${pid_socat} ${msg}" >${conf[FIFO]}
	wait ${pid_socat}

	# Restore stdin, remove socket and exit.
	stty sane
	[[ -e ${sock} ]] && rm -f ${sock}

	[[ ${conf[LOGLEVEL]} -gt 3 ]] && echo "Done requesting \"$@\" from ${MYNAME}"
	return ${s}
}

# [END OF INTERACTIVE CONTROL FUNCTIONS]

# [BEGIN OF EXECUTION FUNCTIONS]

do_systemd_daemon_start()
{
	# Check if we are started from systemd (PID 1).
	[[ ( ! "${UID}" -eq 0 || ! ${PPID} -eq 1 ) && ${FOREGROUND} -eq 0 ]] && do_echo_use
	local myname="daemon (${BASHPID}):" hostname="$(hostname)" pid_daemon=${BASHPID} starting=1 start_status=0 time_start=$(do_timer)
	local systemdconf="" crypttab="" pid_logwriter fd_logwriter fd_journal

	# Close stdin, fd3 to stdout (systemd journald) for reader and worker processes. Redirect stdout and stderr to /dev/null.
	# If we are running in foreground mode evrything goes to stdout of the user's terminal. And we wish him or her good luck with that.
	[[ ${FOREGROUND} -ne 1 ]] && exec 0>&- {fd_journal}>&1- 1>/dev/null 2>&1
	[[ ${FOREGROUND} -eq 1 ]] && exec {fd_logwriter}>&1 {fd_journal}>&${fd_logwriter} 2>&1

	# Load config and start new key session and link the user key ring to the session key ring. On boot keys will be cached in user key ring. 
	set -m
	keyctl new_session
	keyctl link @u @s
	if ! do_init_conf; then
		systemd-notify --pid=$$ --stopping --status="${MYNAME}: Cannot Initialize Config" 
		exit 0
	fi

	# Start the logwriter.
	[[ ! -d ${conf[LOGDIR]} ]] && mkdir -p ${conf[LOGDIR]}
	[[ ! -e ${conf[LOGFILE]} ]] && touch ${conf[LOGFILE]}
	chgrp ${conf[CRYPTDISKSD_GROUP]} ${conf[LOGDIR]} ${conf[LOGFILE]}
	chmod 750 ${conf[LOGDIR]}
	chmod 640 ${conf[LOGFILE]}
	[[ ${FOREGROUND} -eq 0 ]] && do_daemon_start_logwriter
	do_log info "${myname} initializing"

	# Here we go, we are started from systemd. We will first process to queue entirely and notify systemd if we're done.
	# The daemon and queue reader are recursive processes. They will re-enter themselves after processing a command. 
	# The reader spawns worker processes to get passphrases and the daemon will mount the actual cryptdisks. 
	# A cleanup will be run every minute. There we will detect if configuration has changed and remove timed out workers and mounts.
	[[ ${conf[DEBUGSHELL]} -eq 1 ]] && set -a
	echo ${pid_daemon} >${conf[PIDFILE]}

	# Check if the queue exists first, exit with error if it isn't. It should be there, or something is wrong with socket.
	if [[ ! -p ${conf[FIFO]} ]]; then
		do_log error "${myname} queue not found" 
		systemd-notify --pid=$$ --stopping --status="${MYNAME}: Queue not Found, Restart ${MYNAME}.socket" 
		exit 0
	fi

	# Parse and load the configuration, exit if either fails.
	if ! do_daemon_check_conf; then 
		do_log error "${myname} failed to load config" 
		systemd-notify --pid=$$ --stopping --status="${MYNAME}: Failed to Load Configuration"
		exit 0
	fi

	# Check if there is a crypttab, log message if there isn't since everything we do is based on it.
	if [[ ! -f ${conf[CRYPTTAB]} ]]; then
		echo -e "#Crypt\t\t\t#Device\t\t\t\t#Passphrase\t\t#TRIM" >${conf[CRYPTTAB]}
		do_log warning "${myname} crypttab not found" 
		systemd-notify --pid=$$ --status="${MYNAME}: Crypttab (${conf[CRYPTTAB]}) not Found"
		start_status=2
	fi

	systemd_daemon
}

do_systemd_keysrv_start()
{
	local myname="${MYNAME}-keyserver" time_start=$(do_timer) host=${USER} fd_logwriter pid_logwriter fd_journal
	[[ ${UID} -eq 0 ]] && echo "${myname} can not  be started as root" && exit 1
	
	# Load the configuration.
	if ! do_init_conf keyserver; then
		systemd-noify --pid=$$ --stopping --status="${myname}: Cannot Initialize Config" 
		exit 0
	elif [[ ! -p ${conf[FIFO]} ]]; then
		systemd-notify --pid=$$ --stopping --status="${myname}: Queue not Found, Restart ${myname}.socket" 
		exit 0
	fi
	( [[ ! -d ${CONFDIR} ]] && ! mkdir ${CONFDIR} ) || ( [[ ! -d ${conf[KEYDIR]} ]] && ! mkdir ${conf[KEYDIR]} ) && exit 1
	chmod 770 ${CONFDIR} 
	chmod 750 ${conf[KEYDIR]}

	# Start Log Writer
	[[ ${FOREGROUND} -ne 1 ]] && exec 0>&- {fd_journal}>&1- 1>/dev/null 2>&1
	[[ ${FOREGROUND} -eq 1 ]] && exec {fd_logwriter}>&1 {fd_journal}>&${fd_logwriter} 2>&1
	[[ ! -d ${conf[LOGDIR]} ]] && mkdir -p ${conf[LOGDIR]}
	[[ ! -e ${conf[LOGFILE]} ]] && touch ${conf[LOGFILE]}
	[[ ${FOREGROUND} -ne 1 ]] && case ${conf[LOGLEVEL]} in
		0|1|2)  exec {fd_logwriter}> >(logwriter);;
		3|4)    exec {fd_logwriter}> >(logwriter) 1>&${fd_logwriter} 2>&1;;
	esac
	pid_logwriter=$!

	cd ${CONFDIR}
	keyctl new_session >/dev/null 2>&1
	do_systemd_keysrv
}

do_cryptdisksd_cli()
{
	local nr=$# cmd=0 _conf=0 res fd_logwriter myname=${MYNAME}
	exec {fd_logwriter}>&1
	# Enter a loop to evaluate all command line options and commands specified.
	while true; do
		# Parse options, the return code will be the nr of parameters to shift or 0 if all options parsed.
		# Continue with processing commands fase if all options parsed.
		if [[ ${cmd} -eq 0 ]]; then 
			do_parse_opt $@
			res=$?
			shift ${res}
			[[ ${res} -ne 0 ]] && continue
		fi
		# Command line options are parsed, evaluate and execute commands specified. Return code will be nr of arguments to shift.
		# If after shifting there are no more commands to process we can exit.
		cmd=1
		do_parse_cmd $@
		res=$?
		shift ${res}
		[[ -z "$1" ]] && return 0
	done
}

MYNAME="$(basename $0)" FOREGROUND=0 PATH=/bin:/sbin
[[ ! -z "${LC_NUMERIC}" ]] && unset LC_NUMERIC

# Check if we're started interactively (options must be specified) or from systemd (run without any options from PID 1).
if [[ $# -eq 0 ]]; then
	# No command line options specified. check if we're started from systemd, start daemon if so.
	do_systemd_daemon_start
	exit 1
elif [[ "$1" == "keyserver" && $(($#-2)) -le 1 ]]; then
	[[ ( $# -ge 2 && ! "$2" =~ ^(-f|-h|status)$ ) || $# -gt 3 || "$2" == "-h" || ( "$2" == "status" && -z "$3" ) ]] && do_echo_use keyserver
	if [[ "$2" == "status" ]]; then
		HOME=$(getent passwd $3 |cut -d':' -f6 2>/dev/null)
		if [[ -z "${HOME}" ]] || ! do_init_conf keyserver || ! mkfifo ${CONFDIR}/status.$$.res >/dev/null 2>&1; then
			echo "Unable to Initialize$([[ -z "${HOME}" ]] && echo ", $3 is not a Valid Host" || echo " Config")."
			exit 1
		else
			exec {fd}<>${CONFDIR}/status.$$.res
			echo "$$ status" >${conf[FIFO]}
			until ! read -t${conf[QUEUE_TIMEOUT]} -ru${fd} res || [[ ${res} == . ]]; do echo -e "${res}"; done
		fi
		rm -f ${CONFDIR}/status.$$.res
		exit 0
	else
		[[ "$2" == "-f" ]] && FOREGROUND=1
		do_systemd_keysrv_start
	fi
elif [[ "$(basename ${SHELL})" == "${MYNAME}" ]]; then
	[[ "$(cat /proc/${PPID}/comm)" != "sshd" ]] && exit 1
	exec 0>&- {out}>&1- 2>/dev/null
	shift
	do_sanboot $@
	exit $?
else
	# Command line options present, run in interactive mode.
	do_cryptdisksd_cli $@
	# Exit if there are no more commands to execute.
	exit $?
fi

# [END OF EXECUTION FUNCTIONS]

# We should never get here, error exit if we do.
echo "${MYNAME} Reached End of the Line, Bye Bye"
exit 1
