#!/bin/bash
# Function Definitions. All functions for serialized commands shall have their nemae prefixed by do_ all others shall not.

do_init_conf()
{
	# Initialize System Variables. Default config in /etc/cryptdisksd/cryptdisksd.conf. Systemd env CONF(DIR) will override.
	local var val _conf= _keylife IFS=$'\n'
	if [[ -s ${CONF} ]]; then for var in $(grep -ve "^\s*#" <<<$(<${CONF})); do
		val=${var#*=} var=${var%%=*}
		conf[${var^^}]="${val}"
	done fi
	[[ -z "${conf[FILES]}" ]] && conf[FILES]="$0 /usr/share/bash-completion/completions/${MYNAME}"
	[[ -z "${conf[SYSTEMPP]}" ]] && conf[SYSTEMPP]="system"
	[[ -z "${conf[LOGLEVEL]}" ]] && conf[LOGLEVEL]=0
	[[ -z "${conf[DEBUGSHELL]}" ]] && conf[DEBUGSHELL]=0
	[[ -z "${conf[RUNDIR]}" ]] && conf[RUNDIR]="/run"
	[[ -z "${conf[DMDIR]}" ]] && conf[DMDIR]="/dev/mapper"
	[[ -z "${conf[LOGDIR]}" ]] && conf[LOGDIR]="/var/log/${MYNAME}"
	[[ -z "${conf[LOGFILE]}" ]] && conf[LOGFILE]="/var/log/${MYNAME}.log"
	[[ -z "${conf[CRYPTDISKSDDIR]}" ]] && conf[CRYPTDISKSDDIR]=${conf[RUNDIR]}/${MYNAME}
	[[ -z "${conf[PIDFILE]}" ]] && conf[PIDFILE]="${conf[CRYPTDISKSDDIR]}/${MYNAME}.pid"
	[[ -z "${conf[CRYPTDISKSD_GROUP]}" ]] && conf[CRYPTDISKSD_GROUP]="disk"
	[[ -z "${conf[LOG_GROUP]}" ]] && conf[LOG_GROUP]="${conf[CRYPTDISKSD_GROUP]}"
	[[ -z "${conf[CRYPTDISKSDDIR_MODE]}" ]] && conf[CRYPTDISKSDDIR_MODE]=1770
	[[ -z "${conf[FIFO]}" ]] && conf[FIFO]="${conf[CRYPTDISKSDDIR]}/queue"
	[[ -z "${conf[FIFO_MODE]}" ]] && conf[FIFO_MODE]=620
	[[ -z "${conf[CRYPTTAB]}" ]] && conf[CRYPTTAB]="${CONFDIR}/crypttab"
	[[ -z "${conf[FWCRYPTTAB]}" ]] && conf[FWCRYPTTAB]="${FWDIR}/${DISTNAME}_${CRYPTTAB}-${FWGUID}"
	[[ -z "${conf[BLOCKDEVSDIRS]}" ]] && conf[BLOCKDEVSDIRS]="/dev/disk/by-id"
	[[ -z "${conf[START_TIMEOUT]}" ]] && conf[START_TIMEOUT]=5
	[[ -z "${conf[PP_TIMEOUT]}" ]] && conf[PP_TIMEOUT]=3
	[[ -z "${conf[QUEUE_TIMEOUT]}" ]] && conf[QUEUE_TIMEOUT]=2
	[[ -z "${conf[CLEANUP_TIMER]}" ]] && conf[CLEANUP_TIMER]=60
	[[ -z "${conf[BOOT]}" ]] && conf[BOOT]="boot.conf"
	[[ -z "${conf[FWCONF]}" ]] && conf[FWCONF]="${FWDIR}/${DISTNAME}_$(basename ${CONF})-${FWGUID}"
	[[ -z "${conf[FWBOOTCONF]}" ]] && conf[FWBOOTCONF]="${FWDIR}/${DISTNAME}_${conf[BOOT]}-${FWGUID}"
	[[ -z "${conf[BOOTCONF]}" ]] && conf[BOOTCONF]="${CONFDIR}/${conf[BOOT]}"
	[[ -z "${conf[NET_ONLINE]}" ]] && conf[NET_ONLINE]=1
	[[ -z "${conf[NET_RETRIES]}" ]] && conf[NET_RETRIES]=2
	[[ -z "${conf[ADDONSTOP]}" ]] && conf[ADDONSTOP]=0
	[[ -z "${conf[UPSONSTOP]}" ]] && conf[UPDONSTOP]=0
	[[ -z "${conf[USER_TIMEOUT]}" ]] && conf[USER_TIMEOUT]=10
	[[ -z "${conf[CMD_TIMEOUT]}" ]] && conf[CMD_TIMEOUT]=2
	[[ -z "${conf[MOUNT_TIMEOUT]}" ]] && conf[MOUNT_TIMEOUT]=30
	[[ -z "${conf[ALGO]}" ]] && conf[ALGO]="aes-xts-plain64"
	[[ -z "${conf[KEYSZ]}" ]] && conf[KEYSZ]="256"
	[[ -z "${conf[HASH]}" ]] && conf[HASH]="sha256"
	[[ -z "${conf[SYSIMG]}" ]] && conf[SYSIMG]="/sysimg-${DISTNAME}-${DISTVERSION}.sqfs"
	[[ -z "${conf[ROOTDIR]}" ]] && conf[ROOTDIR]="/sysroot"
	[[ -z "${conf[ETCDEV]}" ]] && conf[ETCDEV]="etc"
	[[ -z "${conf[LIBDEV]}" ]] && conf[LIBDEV]="lib"
	if [[ "$1" != "daemon" ]]; then
		if [[ -z "${KEYSRVDIR}" && -s ${HOME}/.config/systemd/${MYNAME}-keyserver.conf ]]; then
			. ${HOME}/.config/systemd/${MYNAME}-keyserver.conf
		fi
		[[ -z "${KEYSRVDIR}" ]] && KEYSRVDIR="${HOME}/${MYNAME}-keyserver"
		[[ -z "${KEYSRVCONF}" ]] && KEYSRVCONF="${KEYSRVDIR}/${MYNAME}-keyserver.conf"
		if [[ "$1" == "keyserver" && ! -d "${KEYSRVDIR}" ]]; then
			do_log warning "creating ${KEYSRVDIR} and using default config"
			mkdir -p ${KEYSRVDIR}
		fi
		if [[ -s ${KEYSRVCONF} ]]; then for var in $(grep -ve "^\s*#" <<<$(<${KEYSRVCONF})); do
			val=${var#*=} var=${var%%=*}
			keyserverconf[${var^^}]="${val}"
	   	done fi
		[[ ! -z "${keyserverconf[KEYSRV_FIFO]}" ]]	&& conf[KEYSRV_FIFO]="${KEYSRVDIR}/${keyserverconf[KEYSRV_FIFO]##${KEYSRVDIR}}"\
													|| conf[KEYSRV_FIFO]="${KEYSRVDIR}/queue"
		[[ ! -z "${keyserverconf[LOGDIR]}" ]]	&& conf[LOGDIR]="${HOME}/${keyserverconf[LOGDIR]##${HOME}}" \
												|| conf[LOGDIR]="${KEYSRVDIR}"
		[[ ! -z "${keyserverconf[LOGLEVEL]}" ]] && conf[LOGLEVEL]="${keyserverconf[LOGLEVEL]}"
		[[ ! -z "${keyserverconf[KEYSRVR_GROUP]}" ]]	&& conf[KEYSRV_GROUP]="${keyserverconf[KEYSRVR_GROUP]}" \
														|| conf[KEYSRV_GROUP]="bootsan"
		[[ ! -z "${keyserverconf[LOG_GROUP]}" ]]	&& conf[LOG_GROUP]="${keyserverconf[LOG_GROUP]}" \
													|| conf[LOG_GROUP]="${conf[KEYSRV_GROUP]}"
		[[ ! -z "${keyserverconf[KEYDIR]}" ]]	&& conf[KEYDIR]="${HOME}/${keyserverconf[KEYDIR]##${HOME}}" \
												|| conf[KEYDIR]="${KEYSRVDIR}/keys"
		[[ ! -z "${keyserverconf[KEYSRV_TIMEOUT]}" ]]	&& conf[KEYSRV_TIMEOUT]="${keyserverconf[KEYSRV_TIMEOUT]}" \
														|| conf[KEYSRV_TIMEOUT]=5
		[[ ! -z "${keyserverconf[PP_TIMEOUT]}" ]] && conf[PP_TIMEOUT]="${keyserverconf[PP_TIMEOUT]}"
		[[ ! -z "${keyserverconf[USER_TIMEOUT]}" ]] && conf[USER_TIMEOUT]=${keyserverconf[USER_TIMEOUT]}
		[[ ! -z "${keyserverconf[CLEANUP_TIMER]}" ]] && conf[CLEANUP_TIMER]="${keyserverconf[CLEANUP_TIMER]}"
		[[ "$1" == "keyserver" && ! -s ${KEYSRVCONF} ]] && for var in KEYSRV_FIFO LOGDIR LOGLEVEL KEYSRVR_GROUP LOG_GROUP \
																KEYSRV_TIMEOUT PP_TIMEOUT USER_TIMEOUT CLEANUP_TIMER; do
			echo "${var}=${conf[${var}]}" >>${KEYSRVCONF}
		done
	fi
	for _conf in LOGLEVEL DEBUGSHELL CRYPTDISKSDDIR_MODE FIFO_MODE START_TIMEOUT PP_TIMEOUT QUEUE_TIMEOUT CLEANUP_TIMER NET_ONLINE \
				 NET_RETRIES UPDONSTOP ADDONSTOP USER_TIMEOUT CMD_TIMEOUT MOUNT_TIMEOUT KEYSRV_TIMEOUT; do
		if [[ -n "${conf[${_conf}]}" && ! ${conf[${_conf}]} =~ ^[0-9]+$ ]]; then
			do_log error "${_conf} must have numerical value"
		elif [[ ${_conf} =~ ^(LOGLEVEL|ADDONSTOP)$ && ( ${conf[${_conf}]} -lt 0 || ${conf[${_conf}]} -gt 4 ) ]]; then 
			do_log error "${_conf} must be between 0 and 4"
		elif [[ ${_conf} =~ ^(DEBUGSHELL|NET_ONLINE|UPDONSTOP)$ && ${conf[${_conf}]} -ne 0 && ${conf[${_conf}]} -ne 1 ]]; then
			do_log error "${_conf} must be 0 or 1"
		elif [[ -n "${conf[${_conf}]}" && ${_conf} =~ ^(.*TIMEOUT|CLEANUP_TIMER)$ && ${conf[${_conf}]} -eq 0 ]]; then
			do_log error "${_conf} must be greater than 0"
		elif [[ ${_conf} == CRYPTDISKSDDIR_MODE && ! ${conf[${_conf}]} =~ ^(1|0|)(0|5|7){3}$ ]] || \
			 [[ ${_conf} == FIFO_MODE && ! ${conf[${_conf}]} =~ ^(0|2|4|6){3}$ ]]; then
			do_log error "invalid ${_conf}"
		else
			continue
		fi
		return 1
	done
	if [[ -n "${conf[KEYLIFE]}" || -n "${keyserverconf[KEYLIFE]}" ]]; then
		IFS=' '; for _conf  in conf[KEYLIFE] keyserverconf[KEYLIFE]; do 
			_keylife=""; for var in ${!_conf}; do
				if [[ "${var}" =~ ^[0-9]+$ && -n "${_keylife}" ]]; then
					do_log error "can only specify default keylife once"
					return 1
				elif [[ "${var}" =~ ^[0-9]+$ ]]; then
					_keylife=${var}
					continue
				else
					val=${var#*=} var=${var%%=*}
					if [[ -z "${val}" || ! ${val} =~ ^[0-9]+$ ]]; then
						do_log error "invalid keylife ${var}=${val}"
						return 1
					fi
					keylife[$(do_eval_pp ${var})]=$((val*60))
				fi
			done
			[[ "${_conf}" == "conf[KEYLIFE]" ]] && conf[KEYLIFE]=${_keylife} || keyserverconf[KEYLIFE]=${_keylife}
		done
		[[ -n "${keyserverconf[KEYLIFE]}" ]] && conf[KEYLIFE]=${keyserverconf[KEYLIFE]}
	fi
	conf[KEYLIFE]=$((conf[KEYLIFE]*60))
	if [[ "$1" == "daemon" && $2 == "1" && ! -s ${CONF} ]]; then
		do_log warning "${CONF} not found, creating default"
		for var in ${!conf[@]}; do echo "${var}=${conf[${var}]}" >>${CONF}; done
	fi
	conf[START_TIMEOUT]=$((conf[START_TIMEOUT]*60))
	conf[PP_TIMEOUT]=$((conf[PP_TIMEOUT]*60))

	return 0
}

do_reload_bootconf()
{
	do_log debug "loading configuration"
	local var val IFS=$'\n'
	unset bootconf crypttab systemdconf
	declare -gA bootconf
	# Load the crypttab and systemd conf into memory.
	[[ -s ${conf[CRYPTTAB]} ]] && crypttab="$(t_cat ${conf[CRYPTTAB]}| grep -ve "^\s*#" |tr "\t" " " |tr -s " ")" 
	[[ -s ${CONF} ]] && systemdconf="$(t_cat ${CONF} |grep -ve "^\s*#")"
	# Source the boot config if necessary.
	if [[ -s ${conf[BOOTCONF]} ]]; then for var in $(t_cat ${conf[BOOTCONF]} |grep -ve "^\s*#"); do
		val=${var#*=} var=${var%%=*}
		bootconf[${var^^}]="${val}"
	done fi
	return 0
}

# [BEGIN OF LOGGING FUNCTIONS]

# LOGLEVEL 0, log only to syslog (daemon facility). 
# LOGLEVEL 1, log to syslog and debug to dedicated logfile.
# LOGLEVEL 2 is loglevel 1 with components having dedicated log file.
# LOGLEVEL 3, extra debug logging, stdout and stderr of processes also sent to log.
# LOGLEVEL 4, sames as level 3 with components having dedicated log file.
# The log write will parse lines from stdin, sent by various workers. The lines are written to log and sent to syslog.
logwriter()
{
	local myname="logger:${BASHPID}:" _time_start=$(do_timer) ll line
	trap 'logger -p daemon.warning "${MYNAME}: ${myname} terminating"; exit 1' SIGINT SIGTERM
	exec 1>/dev/null 2>&1

	# Initialize the log file. Set the correct access rights.
	[[ -n "$1" ]] && conf[LOGFILE]="${conf[LOGDIR]}/$1"
	if [[ ${conf[LOGLEVEL]} -ge 1 ]]; then
		touch ${conf[LOGFILE]}
		chgrp ${conf[LOG_GROUP]} ${conf[LOGFILE]}
		chmod 640 ${conf[LOGFILE]}
		echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${myname} initialized" >>${conf[LOGFILE]}
	fi

	# Prepend every line recieved with date and time and write to logfile.
	while read -r ll line; do
		local _date="$(date '+%d-%m %H:%M:%S.%3N')"
		if [[ ( "${ll}" == "debug" && ${conf[LOGLEVEL]} -ge 1 ) || ( "${ll}" == "debug2" && ${conf[LOGLEVEL]} -ge 3 ) ]]; then
			echo "${_date} ${hostname} ${line}" >>${conf[LOGFILE]}
		elif [[ ! ${ll} =~ debug ]]; then
			[[ ${ll} =~ ^(info|warning|error)$ ]] && logger -p daemon.${ll} "${MYNAME}: ${line}"
			[[ ${conf[LOGLEVEL]} -ge 1 ]] && echo "${_date} ${hostname} ${line}" >>${conf[LOGFILE]}
		fi
	done
	if [[ ${conf[LOGLEVEL]} -ge 1 ]]; then
		echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${myname} finished after $(do_timer ${_time_start})s" >>${conf[LOGFILE]}
	fi
	[[ "${INITRD}" -eq 1 && "${keeplog}" -eq 1 ]] && cp -a ${conf[LOGFILE]} ${conf[LOGDIR]} /sysroot/var/log/
}

do_log()
{
	# Send a message to the log writer, or to systemd if that fails.
	echo "$1 ${myname} ${@:2}" >&${fd_logwriter} || echo "$1 ${myname} ${@:2}" >&${fd_journal}
	return 0
}

do_timer()
{
	local IFS='.' x y z
	# Start a timer for debugging purposes. We will track to the ms.
	if [[ $# -eq 0 ]]; then
		# Started with no args, start a timer, echo the start time.
		echo "${EPOCHREALTIME::-3}"
	elif [[ "${1,,}" == "date" ]]; then
		# Output the exact date of the timestamp.
		echo "$(date --date @${2::-4} +%Y-%m-%d.%H:%M:%S)"
	else
		# Started with start time as args, calculate and echo the time difference.
		x=(${EPOCHREALTIME::-3}) y=($1); z=$((${x[0]}${x[1]}-${y[0]}${y[1]}))
		case $((4-${#z})) in 1) z="0${z}";; 2) z="00${z}";; 3) z="000${z}";; esac 
		echo "${z::-3}.${z:$((${#z}-3)):3}"
	fi
}

# [END OF LOGGING FUNCTIONS]

# [BEGIN OF MAIN DAEMON FUNCTIONS]

do_term_daemon()
{
	trap 'systemd-notify --stopping --status="${MYNAME}: unclean finish after $(do_timer ${time_start})s"; exit 1;' SIGINT SIGTERM
	local res pid pp crypt timeout passphrase

	do_log warning "terminating after $(do_timer ${time_start})s"
	do_daemon_check_conf
	for key in ${!job[@]}; do
		res="$(cut -d'|' -f1 <<<"${key}")" cmd="$(cut -d'|' -f2 <<<"${key}")" pid="$(cut -d'|' -f3 <<<"${key}")"
		if [[ "$(</proc/${pid}/comm)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${pid} 2>/dev/null
			do_log debug "killed ${res} worker for ${cmd} (PID: ${pid})"
		fi
	done
	if [[ ${coonf[UPDONSTOP]} -eq 1 ]]; then
		key_clnt "UPDATE" & wait $!
	fi
	[[ ${conf[ADDONSTOP]} -gt 0 ]] && {
		for pp in ${!cached_pp[@]}; do
			if [[ ${conf[ADDONSTOP]} -ge 4 || ( ${conf[ADDONSTOP]} -eq 1 && ${cached_pp[${pp}]##*,} -eq 0 ) ]]; then
				timeout=0
			elif [[ ${conf[ADDONSTOP]} -eq 1 && ${cached_pp[${pp}]##*,} -gt 0 ]]; then
				timeout=$((${cached_pp[${pp}]##*,}-$(do_timer ${cached_pp[${pp}]%%,*} |cut -d'.' -f1)+1))
			elif [[ ${conf[ADDONSTOP]} -eq 2 ]]; then
				[[ -z "${keylife[${pp}]}" ]] && timeout=${conf[KEYLIFE]} ||timeout=${keylife[${pp}]}
			elif [[ ${conf[ADDONSTOP]} -eq 3 ]]; then
				timeout=-1
			fi
			if passphrase="$(t_keyctl 1 pipe "$(t_keyctl 1 request user "${pp}" @s)")"; then
				key_clnt "ADD" "${pp}" "${timeout}" "${passphrase}" &
				do_log info "adding ${pp} to boot servers with ${timeout}s timeout"
			fi
		done
		[[ -n "$(jobs -rp)" ]] && wait $(jobs -rp |tr $'\n' ' ')
	} & job[addkey:${MYNAME}:$!]="$(do_timer)"
	rm -f ${conf[PIDFILE]} ${conf[CRYPTDISKSDDIR]}/*.sock

	[[ -n "$(jobs -rp)" ]] && wait $(jobs -rp |tr $'\n' ' ')
	do_log debug2 "stopping log writer (PID: ${pid_logwriter} FD:${fd_logwriter})"
	exec {fd_logwriter}>&- 1>&- 2>&-
	wait ${pid_logwriter}
	[[ -n "$2" ]] && kill -SIGTERM $2 2>/dev/null
	systemd-notify --stopping --status="${MYNAME}: Daemon Terminated After $(do_timer ${time_start})s (PID: ${BASHPID})"
	exit $1
}

do_hup_daemon()
{
	# Received reload request from systemd. Reload the config asap (no active commands/workers).
	do_log warning "received SIGHUP, reload config asap"
	echo reload >${conf[FIFO]}
}

do_systemd_daemon()
{
	local time_active=0 cleanup=0 msg fd_fifo key read_to res _time_start crypt_arr crypt
	local pid_ctrl pid_socat sock_ctrl cmd pp dev trim pid _jobs to _time_active mountsysimg
	declare -gA active_mnt waiting_mnt cached_pp job
	trap 'do_term_daemon' SIGINT SIGTERM; trap 'do_hup_daemon' SIGHUP

	# The master passphrase may be in the user keyring, revoke and cache in session keyring.
	key="$(keyctl search @u user "${MYNAME}:${conf[SYSTEMPP]}" 2>/dev/null)" && do_move_passphrase "${conf[SYSTEMPP]}" "${key}"

	exec {fd_fifo}<>${conf[FIFO]}
	while true; do	
		# Evaluate cleanup, jobs, start status and set the new read timeout, we will run a cleanup every conf[CLEANUP_TIMER].
		# Make sure the read timeout is never 0 as this will complicate things (read will not read if to = 0).
		time_active=$(do_timer ${time_start}) passphrase="" _jobs="$(echo $(jobs -rp))"
		for key in ${!job[@]}; do
			res=$(cut -d'|' -f1 <<<"${key}") cmd=$(cut -d'|' -f2 <<<"${key}") pid=$(cut -d'|' -f3 <<<"${key}")
			_time_active=$(do_timer ${job[${key}]} |cut -d'.' -f1)
			[[ ${starting} -eq 0 ]] && to=${conf[PP_TIMEOUT]} || to=${conf[START_TIMEOUT]}
			if [[ ! ${_jobs} =~ ^(|.*[[:space:]])${pid}(|[[:space:]].*)$ ]]; then
				wait ${pid}
				do_log debug "${res} worker for ${cmd} finished (PID: ${pid}: $?)"
				unset job[${key}]
			elif [[ "${job[${key}]}" == "-1" ]]; then
				do_log warning "${res} worker for ${cmd} (PID: ${pid}) not terminated"
				kill -SIGKILL ${pid} 2>/dev/null
				unset job[${key}]
			elif   [[ "${res}" == "passphrase" && ${_time_active} -gt ${to} ]] \
				|| [[ "${res}" == "control" && "${cmd}" != "erase" && ${_time_active} -gt $((2*conf[START_TIMEOUT])) ]] \
				|| [[ "${res}" == "mount" && ${_time_active} -gt ${conf[MOUNT_TIMEOUT]} ]] \
				|| [[ "${res}" == "putkey" && ${_time_active} -gt ${conf[PP_TIMEOUT]} ]]; then
				kill -SIGTERM ${pid}
				job[${key}]=-1
				[[ "${res}" == "passphrase" ]] && for crypt in ${!waiting_mnt[@]}; do
					[[ "${waiting_mnt[${crypt}]%% *}" == "${cmd}" ]] && unset waiting_mnt[${crypt}]
				done
				do_log debug "${res} worker for ${cmd} (PID: ${pid}) timeout"
			fi 
		done
		if [[ ${starting} -eq 2 && -z "${!job[@]}" && -z "${!waiting_mnt[@]}" ]]; then
			do_daemon_notify_systemd
		elif [[ ${starting} -eq 2 && ${time_active::-4} -ge ${conf[START_TIMEOUT]} ]]; then
			do_log debug "start timeout reached"
			start_status=3
			do_daemon_notify_systemd
		fi
		if [[ ${cleanup} == "0" || ${time_active::-4} -gt $((${cleanup::-4}+${conf[CLEANUP_TIMER]}-${conf[QUEUE_TIMEOUT]})) ]]; then
			do_daemon_cleanup
		fi
		[[ ${starting} -eq 0 ]] && read_to=$((conf[CLEANUP_TIMER]-(${time_active::-4}-${cleanup::-4})))
		[[ ${starting} -eq 2 ]] && read_to=$((conf[START_TIMEOUT]-${time_active::-4}+conf[QUEUE_TIMEOUT]))
		[[ ${starting} -eq 1 || -n "${_jobs}" ]] && read_to=${conf[QUEUE_TIMEOUT]}
		do_log debug2 "running since $(do_timer date ${time_start}), workers: ${!job[@]}"
		IFS=' ' read -t${read_to} -ru${fd_fifo} -a msg; res=$?
		
		# Evaluate the exit status of the message queue read and act accordingly.
		time_active=$(do_timer ${time_start})
		if [[ ${res} -eq 142 ]]; then 
			do_log debug2 "waking up from slumber"
			if [[ ${starting} -ne 0 && -z "${!waiting_mnt[@]}" && -z "${!job[@]}" ]]; then
				starting=0
				do_daemon_notify_systemd
			elif [[ ${starting} -eq 1 && -n "${!waiting_mnt[@]}" ]]; then
				starting=2
			fi
			continue
		elif [[ ${res} -gt 128 ]]; then
			# Should not happen, daemon process received unhandled signal from somewhere.
			do_log error "read result ${res}, may have been trapped"
			do_daemon_cleanup 
			continue
		elif [[ ${res} -ne 0 ]]; then
			# FIFO has terminated unexpectedly or fd has somehow been closed.
			do_log error "read error ${res} \"${msg[@]}\""
			do_term_daemon 0
		fi
		# Process the message.
		do_log debug "processing \"${msg[@]}\"" 
		_time_start=$(do_timer)

		case ${msg[0],,} in
		reload)
			do_reload_bootconf || do_term_daemon 1;;
		mount|unmount)
			if [[ "${msg[0],,}" == "unmount" && ${msg[2]} -ne 1 ]]; then
				do_log debug "removed ${msg[1]} from active mounts"
				unset active_mnt[${msg[1]}]
			elif [[ "${msg[0],,}" == "mount" && ${msg[2]} -ne 1 && ${msg[2]} -ne 2 && ${msg[2]} -ne 5 ]]; then
				if crypt_arr=($(do_xcrypt_fromtab "${msg[1]}")); then
					pp="$(do_eval_pp ${crypt_arr[2]})" dev="$(do_find_dev "${crypt_arr[1]}")" || dev"${RED}Not Found!${NOR}"
					[[ -n "${crypt_arr[4]}" ]] && pp+="/${crypt_arr[4]}/${crypt_arr[5]}/${crypt_arr[6]}"
					[[ "${msg[2]}" -ne 0 ]] && crypt_arr[3]="${msg[2]}"
				else
					pp="-" dev="/dev/$(t_dmsetup 1 deps ${msg[1]} -o blkdevname |cut -d':' -f2 |tr -d " ()" |cut -d':' -f2)"
					[[ "$(t_lsblk -rD ${conf[DMDIR]}/${msg[1]} |head -n2 |tail -n1 |cut -d' ' -f3-4)" =~ 0B ]] && crypt_arr[3]=0 \
																											   || crypt_arr[3]=1
				fi
				active_mnt[${msg[1]}]="${dev} ${pp} ${crypt_arr[3]} $(do_timer)"
				do_log debug "added ${msg[1]} to active mounts"
			fi
			if [[ "${msg[2]}" -eq 1 || "${msg[2]}" -eq 5 ]]; then
				start_status=1
			elif [[ ${start_status} -eq 0 && (  ( "${msg[0],,}" == "unmount" && ${msg[2]} -eq 2 ) \
												|| ${msg[2]} -eq 3 || ${msg[2]} -eq 4 ) ]]; then
				start_status=2
			fi
			do_log debug2 "active mounts: ${!active_mnt[@]}";;
		control)
			pid_ctrl=${msg[1]%%,*} pid_socat=${msg[1]##*,} cmd="${msg[2],,}"
			sock_ctrl="${conf[CRYPTDISKSDDIR]}/${MYNAME}-${msg[1]%%,*}.sock"
			if [[ "${cmd}" == "stop" ]]; then
				do_term_daemon 0 ${pid_socat}
			elif [[ "${msg[2],,}" == "mountsysimg" && "${INITRD}" -eq 0 ]]; then
				echo "${RED}Not in Initramfs" |socat - UNIX-CONNECT:${sock_ctrl} && kill -SIGTERM ${pid_socat} 2>/dev/null
			elif [[ "${msg[2],,}" == "mountsysimg" && -n "${mountsysimg}" ]]; then
				do_log debug "already mounting ${conf[SYSIMG]} on ${conf[ROOTDIR]}"
				echo "${RED}Already Mounting${NOR}" |socat - UNIX-CONNECT:${sock_ctrl}
				[[ "$(</proc/${pid_socat}/comm)" == "socat" ]] && sleep 0.01 && kill -SIGTERM ${pid_socat} 2>/dev/null
			elif [[ "${msg[2],,}" == "mountsysimg" ]]; then
				mountsysimg="${pid_socat} ${sock_ctrl} $([[ "$(file -b ${conf[SYSIMG]})" =~ ^openssl ]])$?"
				if [[ "${mountsysimg##* }" -eq 1 ]] || key="$(t_keyctl 1 request user "${conf[SYSTEMPP]}" @s)"; then
					[[ "${mountsysimg##* }" -eq 1 ]] || passphrase="$(t_keyctl 1 pipe "${key}")" && daemon_mount_sysimg &
				elif [[ ! ${!job[@]} =~ passphrase\|${conf[SYSTEMPP]} ]]; then
					do_log debug "no active worker for ${conf[SYSTEMPP]}, starting"
					crypt_arr[2]="${conf[SYSTEMPP]}"
					get_passphrase "" & job[passphrase|${conf[SYSTEMPP]}|$!]="$(do_timer)"
				else
					do_log debug "already waiting for ${conf[SYSTEMPP]} passphrase"
				fi
			else
				[[ "${msg[2],,}" =~ ^(smart|erase)$ ]] && msg[2]=smarterase
				[[ "${msg[2],,}" =~ ^(putkey|rmkey)$ ]] && msg[2]=putrmkey
				daemon_control ${msg[2],,} & job[control|${cmd}|$!]="$(do_timer)"
				do_log debug "started control worker for ${cmd} (PID: $!)"
			fi;;
		remove)
			if crypt_arr=($(do_xcrypt_fromtab ${msg[@]:1})) && [[ ! ${!job[@]} =~ mount\|${crypt_arr[0]} ]]; then
				daemon_unmount_crypt "${crypt_arr[0]}" & job[mount|${crypt_arr[0]}|$!]="$(do_timer)"
			fi
			if [[ ${!job[@]} =~ mount\|${crypt_arr[0]} ]]; then
				pid=$(sed "s/.*mount|${crypt_arr[0]}|//" <<<"${!job[@]}" |cut -d' ' -f1)
				do_log info "ignoring ${msg[1]} for ${crypt_arr[0]}, active worker (PID: ${pid})"
			fi;;
		add|change)
			! crypt_arr=($(do_xcrypt_fromtab ${msg[@]:1})) && continue
			pp="$(do_eval_pp "${crypt_arr[2]}")"; key="$(t_keyctl 1 search @u user "${MYNAME}:${pp}")"
			dev="$(do_find_dev "${crypt_arr[1]}")"
			# Set the variables for the crypt to be added, search for the backing device in conf[BLOCKDEVSDIRS].	
			do_log debug "adding ${crypt_arr[1]} as ${crypt_arr[0]} TRIM ${crypt_arr[3]} using ${pp} passphrase"
			if [[ -n "${active_mnt[${crypt_arr[0]}]}" ]]; then
				do_log debug "${active_mnt[${crypt_arr[0]}]%% *} as ${crypt_arr[0]} already active using"\
							 "$(echo "${active_mnt[${crypt_arr[0]}]}" |cut -d' ' -f2) passphrase"\
							 "TRIM $(echo "${active_mnt[${crypt_arr[0]}]}" |cut -d' ' -f3)"
			elif [[ -z "${dev}" ]]; then
				do_log warning "${crypt_arr[1]} not found in ${conf[BLOCKDEVSDIRS]}"
				[[ start_status -eq 0 ]] && start_status=2
			elif [[ -n "${key}" || -n "$(t_keyctl 1 request user "${pp}" @s)" ]]; then
				do_log debug "found cached ${pp} passphrase" 
				[[  -n "${key}" ]] && do_move_passphrase "${pp}" "${key}"
				if [[ ${!job[@]} =~ mount\|${crypt_arr[0]} ]];then
					pid=$(sed "s/.*mount|${crypt_arr[0]}|//" <<<"${!job[@]}" |cut -d' ' -f1)
					do_log info "ignoring ${msg[0]} for ${crypt_arr[0]}, active worker (PID: ${pid})"
					continue
				fi
				daemon_mount_crypt "${crypt_arr[0]}" "${dev}" "${pp}" "${crypt_arr[3]}" "${crypt_arr[4]}" \
								   "${crypt_arr[5]}" "${crypt_arr[6]}" &
				job[mount|${crypt_arr[0]}|$!]="$(do_timer)"
			elif [[ -n "${waiting_mnt[${crypt_arr[0]}]}" ]]; then
				# Check if crypt is already waiting
				do_log debug "${dev} as ${crypt_arr[0]} TRIM ${crypt_arr[3]} already on waiting list"
			else
				# No worker and no passphrase cached, start new worker.
				# If the crypt is already active the user will not be asked for passphrase.
				t_dmsetup 0 info "${crypt_arr[0]}" && user=0
				do_log debug "adding ${dev} as ${crypt_arr[0]} TRIM ${crypt_arr[3]} to waiting list for ${pp} passphrase"
				waiting_mnt[${crypt_arr[0]}]="${pp} ${dev} ${crypt_arr[3]} $(do_timer)"
				if [[ ! ${!job[@]} =~ passphrase\|${pp} ]]; then
					do_log debug "no active worker for ${pp}, starting"
					get_passphrase "${user}" & job[passphrase|${pp}|$!]="$(do_timer)"
				fi
			fi;;
		passphrase)
			pp="$(do_eval_pp ${msg[1]})"
			[[ ${msg[2]} -eq 0 ]] && do_log warning "passphrase ${msg[1]} failed" || do_log debug "passphrase ${pp} success"
			if [[ -n "${mountsysimg}" && "${pp}" == "${conf[SYSTEMPP]}" ]]; then
				key="$(t_keyctl 1 request user "${conf[SYSTEMPP]}" @s)" && passphrase="$(t_keyctl 1 pipe "${key}")"
				daemon_mount_sysimg &
			fi
			[[ ${msg[3]} -eq -1 && -n "${keylife[${pp}]}" ]] && msg[3]=${keylife[${pp}]}
			[[ ${msg[3]} -eq -1 && -z "${keylife[${pp}]}" ]] && msg[3]=${conf[KEYLIFE]}
			[[ ${msg[2]} -ne 2 ]] && for crypt in ${!waiting_mnt[@]}; do if [[ "${waiting_mnt[${crypt}]%% *}" == "${pp}" ]]; then
				crypt_arr=($(do_xcrypt_fromtab "${crypt}")); crypt_arr[7]="$(do_timer ${waiting_mnt[${crypt}]##* })s"
				unset waiting_mnt[${crypt}]
				if [[ ${msg[2]} == 0 ]]; then
					do_log debug "removed ${crypt_arr[1]} as ${crypt_arr[0]} TRIM ${crypt_arr[3]} using ${pp} passphrase,"\
								 "waited for ${crypt_arr[4]}s"
				else
					do_log debug2 "can mount ${crypt_arr[1]} as ${crypt_arr[0]} TRIM ${crypt_arr[3]} using ${pp} passphrase,"\
								  "waited for ${crypt_arr[7]}s"
					if [[ ${!job[@]} =~ mount\|${crypt_arr[0]} ]]; then
						pid=$(sed "s/.*mount|${crypt_arr[0]}|//" <<<"${!job[@]}" |cut -d' ' -f1)
						do_log debug "ignoring ${msg[0]} for ${crypt_arr[0]}, active worker (PID: ${pid})"
						continue
					fi
					daemon_mount_crypt "${crypt_arr[0]}" "$(do_find_dev "${crypt_arr[1]}")" "${pp}" "${crypt_arr[3]}" \
									   "${crypt_arr[4]}" "${crypt_arr[5]}" "${crypt_arr[6]}" &
					job[mount|${crypt_arr[0]}|$!]="$(do_timer)"
				fi
			fi done
			pid=$(sed "s/.*passphrase|${pp}|//" <<<"${!job[@]}" |cut -d' ' -f1)
			if [[ ${msg[2]} -ne 2 && "${msg[4]}" != "0" && ${!job[@]} =~ passphrase\|${pp} ]]; then
				if [[ "$(</proc/${pid}/comm)" == "${MYNAME}" ]]; then
					kill -SIGTERM $(sed "s/.*passphrase|${pp}|//" <<<"${!job[@]}" |cut -d' ' -f1) 2>/dev/null
					do_log debug "killed passphrase worker (PID: ${pid})"
				fi
			fi
			[[ ${msg[2]} -eq 1 ]] && cached_pp[${pp}]="$(do_timer),${msg[3]}" || unset cached_pp[${pp}];;
		*)	
			do_log warning "received invalid message \"${msg[@]}\"";;
		esac

		do_log debug2 "processing \"${msg[@]}\" took $(do_timer ${_time_start})s total"
	done
}

do_move_passphrase()
{
	local pp="$1" key="$2" passphrase to="$([[ -n "${keylife[$1]}" ]] && echo ${keylife[$1]} || echo ${conf[KEYLIFE]})"
	passphrase="$(t_keyctl 1 pipe "${key}")" || return 1
	do_log debug "found cached ${pp} passphrase in user keyring"
	t_keyctl 0 revoke "${key}"
	t_keyctl 0 unlink "${key}" @u
	key_clnt "PUT" "${pp}" "${passphrase}" & job[putkey|${pp}|$!]="$(do_timer)"
	[[ $(do_cache_pp "${pp}" "@s" "-1" "${passphrase}")$? -ne 1 ]] && cached_pp[${pp}]="$(do_timer),${to}" || unset cached_pp[${pp}]
	return 0
}

do_daemon_start_logwriter()
{
	[[ -n "${fd_logwriter}" ]] && exec {fd_logwriter}>&-
	case ${conf[LOGLEVEL]} in
		0|1)  exec {fd_logwriter}> >(logwriter);;
		2)    exec {fd_logwriter}> >(logwriter daemon-${pid_daemon}.log);;
		3)    exec {fd_logwriter}> >(logwriter) 1>&${fd_logwriter} 2>&1;;
		4)    exec {fd_logwriter}> >(logwriter daemon-${pid_daemon}.log) 1>&${fd_logwriter} 2>&1;;
	esac
	pid_logwriter=$!
	do_log debug "started log writer (PID: ${pid_logwriter} FD: ${fd_logwriter})"
}

do_daemon_notify_systemd()
{
	starting=0
	systemd-notify --ready
	case ${start_status} in 
	0)
		do_log info "startup completed succesfully in ${time_active}s"
		systemd-notify --status="${MYNAME}: Startup completed succesfully in ${time_active}s (PID: ${BASHPID})";;
	1)
		do_log warning "startup completed with errors in ${time_active}s"
		systemd-notify --status="${MYNAME}: Startup completed with errors in ${time_active}s (PID: ${BASHPID})";;
	2)
		do_log warning "startup completed with warnings in ${time_active}s"
		systemd-notify --status="${MYNAME}: Startup completed with warnings in ${time_active}s (PID: ${BASHPID})";;
	3)
		do_log warning "startup timed out after ${time_active}s"
		systemd-notify --status="${MYNAME}: Startup timed out after ${time_active}s (PID: ${BASHPID})"
	esac
}

do_daemon_check_conf()
{
	# Parse the configuration from firmware and compare it to the config stored in the confdir.
	local diff _diff fwsrvvar fwsrvkey fwusrvar fwusrkey srvkey usrkey confok=0
	do_log debug "checking config"

	if [[ -s ${conf[FWBOOTCONF]} && ! -s ${conf[BOOTCONF]} ]]; then
		# Config in firware, not in confdir, copy fw to confdir.
		confok=1
		do_log debug "copying ${conf[FWBOOTCONF]} config to ${CONFDIR}"
		t_cat ${conf[FWBOOTCONF]} |t_tail -c +5 >${conf[BOOTCONF]} || return 1
	elif [[ -s ${conf[FWBOOTCONF]} && -s ${conf[BOOTCONF]} ]]; then
		# Compare the firmware config to confdir.
		if diff="$(t_cat ${conf[FWBOOTCONF]} |tail -c +5)" && _diff="$(t_cat ${conf[BOOTCONF]})"; then
			if ! t_diff -q <(echo "${diff}") <(echo "${_diff}"); then
				# Configs are different, overwrite confdir on startup firmware config otherwise.
				confok=1
				if [[ ${starting} -eq 0 ]]; then
					do_log warning "${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} differ, replacing ${conf[FWBOOTCONF]}"
					[[ -e ${conf[FWBOOTCONF]} ]] && t_chattr -i ${conf[FWBOOTCONF]}
					if ! t_printf "\x07\x00\x00\x00\x00" >${conf[FWBOOTCONF]}; then
						do_log error "error creating ${conf[FWBOOTCONF]}"
					elif ! t_efivar -n ${FWGUID}-${DISTNAME}_${conf[BOOT]} -w -f ${conf[BOOTCONF]}; then
						do_log error "error copying ${conf[BOOTCONF]} to ${conf[FWBOOTCONF]}"
					fi
					t_chattr +i ${conf[FWBOOTCONF]}
				else
					do_log warning "${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} differ, replacing ${conf[BOOTCONF]}"
					t_cat ${conf[FWBOOTCONF]} |tail -c +5 >${conf[BOOTCONF]}
				fi
			else
				do_log debug2 "${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} equal"
			fi
		else
			do_log error "failed to compare ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]}"
		fi
	elif [[ ! -s ${conf[FWBOOTCONF]} && -s ${conf[BOOTCONF]} ]]; then
		# No fwconfig store confdir.
		confok=1
		do_log info "no firmware config, copying from ${conf[BOOTCONF]}"
		[[ -e ${conf[FWBOOTCONF]} ]] && t_chattr -i ${conf[FWBOOTCONF]}
		if ! t_printf "\x07\x00\x00\x00\x00" >${conf[FWBOOTCONF]}; then
			do_log error "error creating ${conf[FWBOOTCONF]}"
		elif ! t_efivar -n ${FWGUID}-${DISTNAME}_${conf[BOOT]} -w -f ${conf[BOOTCONF]}; then
			do_log error "error copying ${conf[BOOTCONF]} to ${conf[FWBOOTCONF]}"
		fi
		t_chattr +i ${conf[FWBOOTCONF]}
	else
		# No bootconf at all.
		do_log warning "no boot config found"
		bootconf[BOOTSERVERS]=""
	fi

	# If we are starting up, now is the time to load the config.	
	if [[ ${starting} -eq -1 ]]; then
		starting=1
		do_reload_bootconf
	fi

	# Check if the service config or crypttab has changed on disk.
	if [[ ${starting} -eq 0 && ${confok} -eq 0 ]]; then
		if [[ ! -f ${conf[CRYPTTAB]} ]]; then
			do_log warning "${conf[CRYPTTAB]} disappeared, reloading asap"
			confok=1
		fi
		if [[ ! -f ${CONF} ]]; then
		 	do_log error "${CONF} disappeared, terminating"
			return 1
		fi
		diff="$(t_cat ${CONF} |grep -ve "^\s*#")"
		if ! t_diff -q <(echo "${diff}") <(echo "${systemdconf}"); then
			do_log error "${CONF} changed, terminating"
			return 1
		fi
		diff="$(t_cat ${conf[CRYPTTAB]} |grep -ve "^\s*#" |tr "\t" " " |tr -s " ")"
		if ! t_diff -q <(echo "${diff}") <(echo "${crypttab}"); then
			do_log warning "crypttab changed, reloading asap"
			confok=1
		fi
	fi

	# Check the bootserver and user keys if present.
	[[ -z ${bootconf[BOOTSERVERS]} ]] && return
	fwsrvvar="${FWGUID}-${DISTNAME}_${bootconf[BOOTSERVERKEYS]}"
	fwsrvkey="${FWDIR}/${DISTNAME}_${bootconf[BOOTSERVERKEYS]}-${FWGUID}"
	fwusrvar="${FWGUID}-${DISTNAME}_${bootconf[BOOTUSERKEY]}"
	fwusrkey="${FWDIR}/${DISTNAME}_${bootconf[BOOTUSERKEY]}-${FWGUID}"
	srvkey="${CONFDIR}/${bootconf[BOOTSERVERKEYS]}" usrkey="${CONFDIR}/${bootconf[BOOTUSERKEY]}"
	if [[ -s ${fwsrvkey} && -s ${srvkey} ]]; then
		# compare the keys, overwrite if necessary
		if diff="$(t_cat ${fwsrvkey} |tail -c +5)" && _diff="$(t_cat ${srvkey})"; then
			if ! t_diff -q <(echo "${diff}") <(echo "${_diff}"); then
				# Configs are different, overwrite firmware config
				do_log warning "${fwsrvkey} and ${srvkey} differ, replacing ${fwsrvkey}"
				[[ -e ${fwsrvkey} ]] && t_chattr -i ${fwsrvkey}
				if ! t_printf "\x07\x00\x00\x00\x00" >${fwsrvkey}; then
					do_log error "error creating ${fwsrvkey}"
				elif ! t_efivar -n ${fwsrvvar} -w -f ${srvkey}; then
					do_log error "error copying ${srvkey} to ${fwsrvkey}"
				fi
				t_chattr +i ${fwsrvkey}
			else
				do_log debug2 "${fwsrvkey} and ${srvkey} equal"
			fi
		else
			do_log error "failed to compare ${fwsrvkey} and ${srvkey}"
		fi
	elif [[ -s ${fwsrvkey} && ! -s ${srvkey} ]]; then
		# Keys in fw not in confdir, copy
		do_log debug "copying ${fwsrvkey} to ${srvkey}"
		t_cat ${fwsrvkey} |t_tail -c +5 > ${srvkey} || return 1
	elif [[ ! -s ${fwsrvkey} && -s ${srvkey} ]]; then
		# No fwbootkeys, copy from confdir.
		do_log info "no firmware bootserver keys, copying from ${srvkey}"
		[[ -e ${fwsrvkey} ]] && t_chattr -i ${fwsrvkey}
		if ! t_printf "\x07\x00\x00\x00\x00" >${fwsrvkey}; then
			do_log error "error creating ${fwsrvkey}"
		elif ! t_efivar -n ${fwsrvvar} -w -f ${srvkey}; then
			do_log error "error copying ${srvkey} to ${fwsrvkey}"
		fi
		t_chattr +i ${fwsrvkey}
	else
		# No bootserverkeys at all
		do_log error "no bootserver keys found"
		bootconf[BOOTSERVERS]=""
	fi

	# No need to check user key, if server key not present.
	[[ -z ${bootconf[BOOTSERVERS]} ]] && return
	if [[ -s ${fwusrkey} && ! -s ${usrkey} ]]; then
		# Key in fw not in confdir, copy
		do_log info "copying ${fwusrkey} to ${usrkey}"
		if ! t_chattr -i ${fwusrkey} || ! t_chmod 400 ${fwusrkey} || ! t_chattr +i ${fwusrkey} || \
		   ! t_cat ${fwusrkey} |t_tail -c +5 >${usrkey} && t_chmod 400 ${usrkey}; then
			do_log error "failed to copy ${fwusrkey} to ${usrkey}"
		fi
	elif [[ -s ${fwusrkey} && -s ${usrkey} ]]; then
		# compare the keys, overwrite if necessary
		if diff="$(t_cat ${fwusrkey} |tail -c +5)" && _diff="$(t_cat ${usrkey})"; then
			if ! t_diff -q <(echo "${diff}") <(echo "${_diff}"); then
	 			# Configs are different, overwrite firmware config
				do_log warning "${fwusrkey} and ${usrkey} differ, replacing ${fwusrkey}"
				[[ -e ${fwusrkey} ]] && chattr -i ${fwusrkey}
				t_printf "\x07\x00\x00\x00\x00" >${fwusrkey} || do_log error "error creating ${fwusrkey}"
				if ! t_efivar -n ${fwusrvar} -w -f ${usrkey} || ! t_chattr -i ${fwusrkey} || \
				   ! t_chmod 400 ${fwusrkey} || ! t_chattr +i ${fwusrkey}; then
					do_log error "error copying ${usrkey} to ${fwusrkey}"
				fi
			else
				do_log debug2 "${fwusrkey} and ${usrkey} equal"
				if ! t_chattr -i ${fwusrkey} || ! t_chmod 400 ${fwusrkey} || \
				   ! t_chattr +i ${fwusrkey} || ! t_chmod 400 ${usrkey}; then
					do_log error "error setting mode for ${fwusrkey} or ${usrkey}"
				fi
			fi
		else
			do_log error "failed to compare ${fwusrkey} and ${usrkey}"
		fi
	elif [[ ! -s ${fwusrkey} && -s ${usrkey} ]]; then
		# No fwbootuserkey, copy from confdir
		do_log info "no firmware bootuser key, copying from ${usrkey}"
		[[ -e ${fwusrkey} ]] && chattr -i ${fwusrkey}
		t_printf "\x07\x00\x00\x00\x00" >${fwusrkey} || do_log error "error creating ${fwusrkey}"
		if ! t_efivar -n ${fwusrvar} -w -f ${usrkey} || ! t_chattr -i ${fwusrkey} || \
		   ! t_chmod 400 ${fwusrkey} || ! t_chattr +i ${fwusrkey}; then
			do_log error "error copying ${usrkey} to ${fwusrkey}"
		fi
	else
		# No bootuserkeys at all
		bootconf[BOOTSERVERS]=""
	fi

	[[ ${confok} -eq 1 ]] && echo "reload" >${conf[FIFO]}
	return 0
}

do_daemon_cleanup()
{
	local myname="daemon:cleanup:${BASHPID}:" _time_start=$(do_timer) tab_crypt="" pp crypt_arr
	local crypt _crypt dev trim time pid mnt_crypt key
	do_log debug "cleanup starting at ${time_active}"
	systemd-notify WATCHDOG=1 WATCHDOG_USEC=$(((2*conf[CLEANUP_TIMER])*1000000))

	# Check if the log writer is still active, restart it if necessary.
	if [[ ${FOREGROUND} -eq 0 && ("$(</proc/${pid_logwriter}/comm)" != "${MYNAME}" || $(kill -0 ${pid_logwriter})$? -ne 0) ]]; then
		pid="${pid_logwriter}"
		do_daemon_start_logwriter
		systemd-notify "${MYNAME}: logwriter (PID: ${pid}) terminated after $(do_timer ${time_start})s"
		do_log error "logwriter (PID: ${pid}) terminated after $(do_timer ${time_start})s"
	fi

	# Check the config.
	if ! do_daemon_check_conf; then
		do_log error "failed to check config, terminating"
		systemd-notify --stopping --status="${MYNAME}: Failed to Load Configuration"
		do_term_daemon 0
	fi

	# Check the active crypts and add to active list if not already present.
	mnt_crypt="$(t_dmsetup 1 ls --target crypt |cut -f1 |grep -vi "No devices found")"
	for crypt in ${mnt_crypt}; do if [[ -z "${active_mnt[${crypt}]}" ]]; then
		crypt_arr=($(do_xcrypt_fromtab "${crypt}"))
		[[ "$(t_lsblk -rD ${conf[DMDIR]}/${crypt} |head -n2 |tail -n1 |cut -d' ' -f3-4)" =~ 0B ]] && trim=0 || trim=1
		if [[ ! -z "${crypt_arr[@]}" ]]; then
			dev="$(do_find_dev ${crypt_arr[1]})" pp="$(do_eval_pp "${crypt_arr[2]}")"
			[[ -z "${cached_pp[${pp}]}" ]] && key="$(t_keyctl 1 search @u user "${MYNAME}:${pp}")" && do_move_passphrase "${pp}" "${key}"
			[[ -n "${crypt_arr[4]}" ]] && pp+="/${crypt_arr[4]}/${crypt_arr[5]}/${crypt_arr[6]}"
			active_mnt[${crypt}]="${dev} ${pp} ${trim} $(do_timer)"
		else
			dev=/dev/"$(t_dmsetup 1 deps ${crypt} -o blkdevname |cut -d':' -f2 |tr -d " ()" |cut -d':' -f2 2>/dev/null)" pp="-"
			active_mnt[${crypt}]="${dev} - ${trim} $(do_timer)"
		fi
		do_log debug "found ${dev} as ${crypt} TRIM ${trim} passphrase ${pp} adding to active list"
		unset waiting_mnt[${crypt}] 
	fi done

	# Check for removed crypts and remove the from active list.
	for crypt in ${!active_mnt[@]}; do
		for _crypt in ${mnt_crypt}; do
			[[ "${crypt}" == "${_crypt}" ]] && continue 2
		done
		crypt_arr=(${active_mnt[${crypt}]})
		do_log warning "${crypt_arr[0]} as ${crypt} TRIM ${crypt_arr[2]} passphrase ${crypt_arr[1]}"\
					   "mounted since $(do_timer date ${crypt_arr[3]}) disapeared"
		unset active_mnt[${crypt}]
	done

	# If we have reloaded look up any managed crypts removed from crypttab and make them unmanaged.
	if [[ ! -z "${tab_crypt}" ]]; then for crypt in ${!active_mnt[@]}; do
		crypt_arr=(${active_mnt[${crypt}]})
		[[ "${crypt_arr[1]}" == "-" ]] && continue
		for _crypt in ${tab_crypt}; do
			[[ "${crypt}" == "${_crypt}" ]] && continue 2
		done
		do_log warning "${crypt_arr[0]} as ${crypt} TRIM ${crypt_arr[2]} passphrase ${crypt_arr[1]}"\
					   "mounted since $(do_timer date ${crypt_arr[3]}) removed from crypttab"
		active_mnt[${crypt}]="${crypt_arr[0]} - ${crypt_arr[2]} ${crypt_arr[3]}"
	done fi

	# Check Cached Passphrases
	for _pp in ${!cached_pp[@]}; do if ! t_keyctl 0 request user "${_pp}" @s; then
		do_log info "${_pp} passphrase no longer cached"
		unset cached_pp[${_pp}]
	fi done

	[[ -n "${!cached_pp[@]}" ]] && pp=", cached passphrases: ${!cached_pp[@]}" || pp=""
	[[ -n "${!active_mnt[@]}" ]] && crypt=", active mounts: ${!active_mnt[@]}" || crypt=""
	[[ -n "${!waiting_mnt[@]}" ]] && key=", waiting mounts: ${!waiting_mnt[@]}" || key=""
	do_log debug2 "cleanup took $(do_timer ${_time_start})s${pp}${crypt}${key}"
	cleanup=$(do_timer ${time_start})
}

daemon_mount_sysimg()
{
	local res=0 sock="$(cut -d' ' -f2 <<< "${mountsysimg}")" enc="${mountsysimg##* }" pid="${mountsysimg%% *}"
	do_log warning "mounting system image ${conf[SYSIMG]} on ${conf[ROOTDIR]}"
	[[ -d /squashfs ]] || mkdir /squashfs || res=1
	mount -t tmpfs tmpfs -o size="$(($(stat -c%s ${conf[SYSIMG]})+1))" /squashfs || res=1
	if [[ "${res}" -eq 0 && "${enc}" -eq 0 ]]; then
		t_openssl aes-256-cbc -salt -d -pbkdf2 -in ${conf[SYSIMG]} -out /squashfs/${conf[SYSIMG]##*/} >/dev/null 2>&1 || res=1
	elif [[ "${res}" -eq 0 ]]; then
		t_cp ${conf[SYSIMG]} /squashfs/${conf[SYSIMG]##*/} >/dev/null 2>&1 || res=1
	fi
	[[ "${res}" -eq 0 ]] && losetup /dev/loop0 /squashfs/${conf[SYSIMG]##*/} >/dev/null 2>&1 || res=1
	[[ "${res}" -ne 0 ]] && do_log error "failed to mount ${conf[SYSIMG]} on ${conf[ROOTDIR]}"
	echo "${res}" |socat - UNIX-CONNECT:${sock}
	[[ "$(</proc/${pid}/comm)" == "socat" ]] && sleep 0.01 && kill -SIGTERM ${pid} 2>/dev/null
}

daemon_mount_crypt()
{
	local myname="mount:$1:${BASHPID}:" _add_crypt="$1" _add_dev="$2" _add_pp="$(do_eval_pp "$3")" _add_trim="$4" _passphrase=""
	local _add_time=$(do_timer) _crypt_arr _key="$(t_keyctl 1 request user "${_add_pp}" @s)" _res=0 _cmd _pid_cmd _fd_cmd
	trap 'do_log debug "terminating after $(do_timer ${_add_time})s"; exit 1' SIGINT SIGTERM
	do_log debug "mounting ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} with ${_add_pp} passphrase"

	if [[ -z "${_key}" ]] || ! _passphrase="$(t_keyctl 1 pipe "${_key}")"; then
		do_log warning "passphrase ${_add_pp} not cached!" 
		echo "passphrase ${_add_pp} 0 0" >${conf[FIFO]} 
		_res=5
	elif ! t_dmsetup 0 info "${_add_crypt}"; then
		if [[ "$(t_lsblk -rD ${_add_dev} |head -n2 |tail -n1 |cut -d' ' -f3-4)" =~ 0B ]]; then
			do_log warning "requested TRIM for ${_add_crypt} but device ${_add_dev} does not support it"
			_add_trim=0 _res=3
		fi
		[[ -n "$5" ]] && key="--cipher $5 --key-size $6 --hash $7" \
					  || key="--cipher ${conf[ALGO]} --key-size ${conf[KEYSZ]} --hash ${conf[HASH]}"
		[[ ${_add_trim} -eq 1 ]] && key+=" --allow-discards"
		if t_cryptsetup open --type plain "${key}" "${_add_dev}" "${_add_crypt}" <<<"${_passphrase}"; then
			do_log info "mounted ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} passphrase ${_add_pp}"
			do_log debug2 "mounting ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} passphrase took $(do_timer ${_add_time})s"
		else
			do_log error "error mounting ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} after $(do_timer ${_add_time})s"
			_res=1
		fi
	else
		[[ "$(t_lsblk -rD ${conf[DMDIR]}/${_add_crypt} |head -n2 |tail -n1 |cut -d' ' -f3-4)" =~ 0B ]] && _add_trim=0 || _add_trim=1
		if [[ -n "${active_mnt[${_add_crypt}]}" ]]; then
			_crypt_arr=($(echo "${_add_crypt} ${active_mnt[${_add_crypt}]}"))
			_res=2
		else
			_crypt_arr=($(do_xcrypt_fromtab ${_add_crypt}) $(do_timer))
			if [[ ${_add_trim} -ne ${_crypt_arr[3]} ]]; then
				[[ ${_add_trim} -eq 0 ]] && _res=3
				[[ ${_add_trim} -eq 1 ]] && _res=4
			fi
		fi
		do_log info "${_crypt_arr[1]} already active as ${_add_crypt} TRIM ${_add_trim} passphrase ${_crypt_arr[2]}"\
					"since $(do_timer date ${_crypt_arr[4]})"
	fi

	echo "mount ${_add_crypt} ${_res}" >${conf[FIFO]}
	exit ${_res}
}

daemon_unmount_crypt()
{
	local myname="unmount:$1:${BASHPID}:" _time_start=$(do_timer) _cmd _pid_cmd _res=0 _del_crypt="$1" _crypt_arr
	trap 'do_log debug "terminating after $(do_timer ${_time_start})s"; exit 1' SIGINT SIGTERM
	if [[ -n "${active_mnt[${_del_crypt}]}" ]]; then
		_crypt_arr=(${_del_crypt} ${active_mnt[${_del_crypt}]})
	elif ! _crypt_arr=($(do_xcrypt_fromtab "${_del_crypt}")); then
		_crypt_arr[0]="${_del_crypt}"
		_crypt_arr[1]="/dev/$(t_dmsetup 1 deps ${_del_crypt} -o blkdevname |cut -d':' -f2 |tr -d " ()" |cut -d':' -f2 2>/dev/null)"
		_crypt_arr[2]="-"
		[[ "$(t_lsblk -rD ${conf[DMDIR]}/${_del_crypt} |head -n2 |tail -n1 |cut -d' ' -f3-4)" =~ 0B ]] && _crypt_arr[3]=0 \
																									   || _crypt_arr[4]=1
	fi
	[[ -z "${_crypt_arr[4]}" ]] && _crypt_arr[4]="$(do_timer)"
	do_log debug "unmounting ${_crypt_arr[1]} as ${_crypt_arr[0]} TRIM ${_crypt_arr[3]} with ${_crypt_arr[2]} passphrase"

	if ! t_dmsetup 0 info "${_del_crypt}"; then
		do_log debug "crypt ${_crypt_arr[0]} not present"
		_res=2
	elif t_kpartx -d ${conf[DMDIR]}/${_crypt_arr[0]} && t_cryptsetup remove "${_crypt_arr[0]}"; then
		do_log info "removed ${_crypt_arr[1]} as ${_crypt_arr[0]} TRIM ${_crypt_arr[3]} passphrase ${_crypt_arr[2]}"\
					"mounted since $(do_timer date ${_crypt_arr[4]})"
		do_log debug2 "removing ${_crypt_arr[0]} took $(do_timer ${_time_start})s"
	else
		do_log warning "failed to remove ${_crypt_arr[1]} as ${_crypt_arr[0]} TRIM ${_crypt_arr[3]} passphrase ${_crypt_arr[2]}"\
					   "mounted since $(do_timer date ${_crypt_arr[4]})"
		_res=1
	fi

	echo "unmount ${_crypt_arr[0]} ${_res}" >${conf[FIFO]}
	exit ${_res}
}

do_term_get_passphrase()
{
	do_log debug "terminating after $(do_timer ${_time_start})s"
	trap 'do_log warning "unclean exit after $(do_timer ${_time_start})s"; exit 1;' SIGINT SIGTERM

	# Kill the workers and exit.
	if [[ ! -z ${__pid_keyclnt} && "$(</proc/${__pid_keyclnt}/comm)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_keyclnt} 2>/dev/null
		do_log debug "killed key client worker (PID: ${__pid_keyclnt})"
		wait ${__pid_keyclnt}
	fi
	if [[ ! -z ${__pid_querypp} && "$(</proc/${__pid_querypp}/comm)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_querypp} 2>/dev/null
		do_log debug "killed query worker (PID: ${__pid_querypp})"
		wait ${__pid_querypp}
	fi
	if [[ ! -z ${_pid_getpp} && "$(</proc/${_pid_getpp}/comm)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${_pid_getpp} 2>/dev/null
		do_log debug "killed get worker (PID: ${_pid_getpp})"
		wait ${_pid_getpp}
	fi
	if [[ ! -z ${_pid_putkey} && "$(</proc/${_pid_putkey}/comm)" == "${MYNAME}" ]]; then
		[[ $1 -ne 0 ]] && kill -SIGTERM ${_pid_putkey} 2>/dev/null && do_log debug "killed put key worker (PID: ${_pid_putkey})"
		[[ $1 -eq 0 ]] && do_log debug "waiting for put key worker (PID: ${_pid_putkey})"
		wait ${_pid_putkey}
	fi
	if [[ ! -z "${_pid_logwriter}" && "$(</proc/${_pid_logwriter}/comm)" == "${MYNAME}" ]]; then
		do_log debug2 "stopping log writer (PID: ${_pid_logwriter} FD:${fd_logwriter})"
	fi
	exit $1
}

get_passphrase()
{
	# We need to get a passphrase. We will start a worker to get the passphrase from the boot servers
	# and a worker to ask for the passphrase using systemd-ask-password after a few seconds.
	# We call ourselves first to provide the two workors with a common {__fd_up} to relay the passphrase.
	# If first parameter is 0 wel will not bother the user for a passphrase.
	local _pid_getpp=${BASHPID} myname="passphrase:${crypt_arr[2]}:${BASHPID}:" _time_start=$(do_timer)
	local _time_active=0 __pid_keyclnt __pid_querypp
	trap 'do_term_get_passphrase' SIGINT SIGTERM

	if [[ $# -eq 2 ]]; then
		# Start key client, wait for a little bit if appropriate, start the query worker and wait.
		_pid_getpp= _pid_logwriter= _pid_putkey=
		if [[ ${conf[NET_ONLINE]} -eq 0 || "$(t_networkctl status |grep "Online state")" =~ (online|partial)$ ]]; then 
			key_clnt "GET" "${crypt_arr[2]}" & __pid_keyclnt=$!
			do_log debug "started key client (PID: ${__pid_keyclnt})"
			t_sleep ${conf[USER_TIMEOUT]}
		fi
		if [[ $2 -eq 1 ]]; then
			query_passphrase ${crypt_arr[2]} "" "" "" "" "" "(${MYNAME}) " & __pid_querypp=$!
			do_log debug "started query user (PID: ${__pid_querypp})"
		fi
		[[ -n "${__pid_keyclnt}${__pid_querypp}" ]] && wait ${__pid_keyclnt} ${__pid_querypp}
		do_term_get_passphrase 0
	fi
		
	# Start a logwriter when LOGLEVEL = 2 or 4, redirect our stdout and stderr to that logwiter whenn level = 4.
	local __fd_up _fd_getpp _pid_getpp _pid_logwriter _pid_putkey _passphrase="" _to
	exec {fd_fifo}>&-
	if [[ ${FOREGROUND} -eq 0 && ${conf[LOGLEVEL]} -eq 2 ]]; then
		exec {fd_logwriter}>&- {fd_logwriter}> >(logwriter passphrase-${crypt_arr[2]}-${_pid_getpp}.log)
	elif [[ ${FOREGROUND} -eq 0 && ${conf[LOGLEVEL]} -eq 4 ]]; then
		exec {fd_logwriter}>&- {fd_logwriter}> >(logwriter passphrase-${crypt_arr[2]}-${_pid_getpp}.log) 1>&${fd_logwriter} 2>&1
	fi
	_pid_logwriter=$!
	do_log debug "started"

	# When starting we will wait max PP_TIMEOUT for the network to come up, or fail.
	[[ ${conf[NET_ONLINE]} -eq 1 && ${starting} -ne 0 ]] && \
	until [[ ${_time_active%%.*} -ge ${conf[PP_TIMEOUT]} || $(t_networkctl status |grep "Online state") =~ (online|partial)$ ]]; do
		t_sleep ${conf[QUEUE_TIMEOUT]}
		_time_active=$(do_timer ${_time_start})
	done

	# Start the worker to get the passphrase from the boot servers or from the user. fd 4 will point back to us.
	exec {_fd_getpp}< <(get_passphrase "$1" 1 {__fd_up}>&1- 1>&2)
	_pid_getpp=$!
	do_log debug "started get passphrase worker (PID: ${_pid_getpp})"

	# We should get a pssphrase or an empty response from the workers or timeout.
	[[ ${starting} -ne 0 ]] && _to=$((conf[START_TIMEOUT]+conf[PP_TIMEOUT])) || _to=${conf[PP_TIMEOUT]}
	if ! IFS= read -t${_to} -u${_fd_getpp} _passphrase; then
		do_log debug "$([[ $? -eq 142 ]] && echo timeout || echo failed) after $(do_timer ${_time_start})s"
		echo "passphrase ${crypt_arr[2]} 0 0 0" >${conf[FIFO]}
		do_term_get_passphrase 1
	fi

	# Put key (back) to servers, cache and send to daemon.
	key_clnt "PUT" "${crypt_arr[2]}" "${_passphrase}" & _pid_putkey=$!
	[[ "${INITRD}" -eq 1 ]] && do_cache_pp "${MYNAME}:${crypt_arr[2]}" "@u" "$((2*conf[START_TIMEOUT]))" "${_passphrase}"
	do_cache_pp "${crypt_arr[2]}" "@s" "-1" "${_passphrase}" || do_term_get_passphrase 1
	echo "passphrase ${crypt_arr[2]} 1 -1 0" >${conf[FIFO]}

	do_log debug2 "took $(do_timer ${_time_start})s"
	do_term_get_passphrase 0
}

# [END OF MAIN DAEMON FUNCTIONS]

# [BEGIN OF DAEMON CONTROL FUNCTIONS]
do_term_control()
{
	trap 'do_log warning "unclean exit after $(do_timer ${_time_start})s"; exit 1;' SIGINT SIGTERM

	[[ $1 -ne 1 ]] && do_log debug "finished after $(do_timer ${_time_start})s"
	if [[ $1 -eq 1 ]]; then
		do_log debug "terminating after $(do_timer ${_time_start})s"
		if [[ -n "${_socat_PID}" && "$(</proc/${_socat_PID}/comm)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_socat_PID} 2>/dev/null
			do_log debug "killed socat coproc (PID: ${_socat_PID})"
			wait ${_socat_PID}
		fi
		if [[ -n "${_pid_putkey}" && "$(</proc/${_pid_putkey}/comm)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_putkey} 2>/dev/null
			do_log debug "killed put key worker (PID: ${_pid_putkey})"
			wait ${_pid_putkey}
		fi
		if [[ -n "${_pid_getpp}" && "$(</proc/${_pid_getpp}/comm)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_getpp} 2>/dev/null
			do_log debug "killed getpp worker (PID: ${_pid_getpp})"
			wait ${_pid_getpp}
		fi
	fi
	[[ "$(</proc/${pid_socat}/comm)" == "socat" ]] && sleep 0.01 && kill -SIGTERM ${pid_socat} 2>/dev/null
	[[ $1 -eq 0 && -n "${_pid_putkey}" ]] && wait ${_pid_putkey}
	if [[ -n "${_pid_logwriter}" && "$(</proc/${_pid_logwriter}/comm)" == "${MYNAME}" ]]; then
		do_log debug2 "stopping log writer (PID: ${_pid_logwriter} FD:${fd_logwriter})"
	fi
	exec {fd_logwriter}>&-
	exit $!
}

daemon_control()
{
	local myname="control:${cmd}:${BASHPID}:${pid_ctrl}:" _crypt_arr _pid_logwriter _pid_putkey _confirm _crypttab
	local  _trim _smartall _smarttest _cache _fw _srv _upd _add _socat
	trap 'do_term_control' SIGINT SIGTERM

	# Start logwriter when LOGLEVEL=2 or = 4. When level = 4 redirect out stdout and stderr to the logwriter.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && _pid_logwriter="1>&${fd_logwriter} 2>&1"
		exec {fd_logwriter}>&- {fd_logwriter}> >(logwriter control-${cmd}-${BASHPID}.log ${_pid_logwriter})
		_pid_logwriter=$!
	fi
	[[ "${cmd}" =~ ^(add|del|smart|erase)$ ]] && _crypt_arr=($(do_xcrypt_fromtab "${msg[3]}"))
	
	# Check if socket exists first.
	if [[ ! -S ${sock_ctrl} ]] && t_sleep 0.05 && [[ ! -S ${sock_ctrl} ]]; then
		do_log warning "${sock_ctrl} is not a socket, pocket rocket or a locket"
		do_term_control 1
	fi

	# Open the client socket.
	do_log debug "connecting to ${sock_ctrl}"
	if [[ "${cmd}" == "shell" && ! conf[DEBUGSHELL] -eq 1 ]]; then
		do_log error "debug shell not enabled"
		kill -SIGTERM ${pid_ctrl} 2>/dev/null
		do_term_control 1
	elif [[ "${cmd}" == "shell" ]]; then
		# Open a connection to the listening socket. Check if it exists first.
		export LC_ALL=en_US.UTF-8
		TERM=xterm socat exec:"/bin/bash --login",pty,ctty,raw,stderr,sigint,setsid,sane UNIX-CONNECT:${sock_ctrl} & _socat_PID=$!
		do_log error "debug shell started"
		wait ${_socat_PID}
		do_log error "debug shell ended"
		do_term_control 0
	fi
	coproc _socat ( socat - UNIX-CONNECT:${sock_ctrl} )
	[[ ${conf[LOGLEVEL]} -ge 3 ]] && echo -e "\r${myname} Connected for ${cmd}.\r" >&${_socat[1]}

	# Check the command line, it should contain crypt, device and passphrase and two options (confirm / crypttab) for add or del.
	if [[ ${cmd} =~ ^(smart|erase)$ ]]; then
		_smartall=${msg[$((${#msg[@]}-2))]} _smarttest=${msg[$((${#msg[@]}-1))]}
	elif [[ ${cmd} =~ ^(putkey|rmkey)$ ]]; then
		_confirm=${msg[$((${#msg[@]}-6))]} _add=${msg[$((${#msg[@]}-5))]} _cache=${msg[$((${#msg[@]}-4))]}
		_fw=${msg[$((${#msg[@]}-3))]} _upd=${msg[$((${#msg[@]}-2))]} _srv=$(IFS=','; echo ${msg[$((${#msg[@]}-1))]})
	elif [[ ${cmd} =~ ^(add|del)$ ]]; then
		_confirm=${msg[$((${#msg[@]}-2))]} _crypttab=${msg[$((${#msg[@]}-1))]} 
	fi
	do_log debug "control ${cmd} connection initialized (PID: ${_socat_PID} SOCK:${sock_ctrl})"
	do_control_$1
}

do_control_status()
{
	# Connect to control socket and blurt status in some form of a pretty fashion.
	local _passphrase _waiting_mnt=${msg[5]} _tab_crypt __crypt_arr ___crypt_arr _crypt __crypt _pp _trim _time _timeout

	# Output the status to the coproc, which will transfer it to stdout of the requestor. First al active mounts.
	echo -e "\r${GREY}${BOLD}${PR}CRYPT${PD}DEVICE${PE}TRIM${PP}PASSPHRASE${PT}MOUNTED${NOR}\r" >&${_socat[1]}
	[[ -n "${bootconf[STORAGEPREFIX]}" ]] && __storageprefix="${bootconf[STORAGEPREFIX]}" || __storageprefix="storage"
	for _crypt in ${!active_mnt[@]}; do
		__crypt_arr=(${active_mnt[${_crypt}]}) ___crypt_arr=($(do_xcrypt_fromtab "${_crypt}")) _pp=${__crypt_arr[1]}
		[[ "${__crypt_arr[2]}" == "0" ]] && _trim="Off  "; [[ "${__crypt_arr[2]}" == "3" ]] && _trim="${BOLD}${YEL}Off  "
		[[ "${__crypt_arr[2]}" == "1" ]] && _trim="On   "; [[ "${__crypt_arr[2]}" == "4" ]] && _trim="${BOLD}${RED}On   "
		if [[ "${__crypt_arr[1]}" == "-" && "${_crypt}" =~ ^${__storageprefix}[0-9]{1,2}$ ]]; then
			[[ -n "${bootconf[STORAGEPP]}" ]] && _pp="$(do_eval_pp "${bootconf[STORAGEPP]}")" || _pp="${conf[SYSTEMPP]}"
            [[ -x "${bootconf[STORAGEALGO]}" ]] && pp+="/${bootconf[STORAGEALGO]}/${bootconf[STORAGEKEYSZ]}/${bootconf[STORAGEHASH]}"
        fi
		_time="${GRN}$(do_timer date ${__crypt_arr[3]} |cut -d ':' -f-2)"
		echo -e "${PR}${_crypt::15}${PD}$(basename ${__crypt_arr[0]})${PE}${_trim}${NOR}${PP}${_pp::38}${PT}${_time}${NOR}\r" >&${_socat[1]}
	done

	# Output all unmounted and waiting crypts.
	_tab_crypt="$(tr "\t" " " <<<"${crypttab}" |cut -d' ' -f1)"
	for _crypt in ${_tab_crypt}; do
		for __crypt in ${!active_mnt[@]}; do
			[[ "${_crypt}" == "${__crypt}" ]] && continue 2
		done
		for __crypt in ${!waiting_mnt[@]}; do if [[ "${_crypt}" == "${__crypt}" ]]; then
			_time="${YEL}Waiting"
			break
		fi done
		[[ ! "${_time}" == "${YEL}Waiting" ]] && _time="${RED}Offline"
		__crypt_arr=($(do_xcrypt_fromtab "${_crypt}")) || continue
		[[ "${__crypt_arr[3]}" == "1" ]] && _trim="On   " || _trim="Off  "
		_pp="$(do_eval_pp ${__crypt_arr[2]})"
		[[ -n "${__crypt_arr[4]}" ]] && _pp+="/${__crypt_arr[4]}/${__crypt_arr[5]}/${__crypt_arr[6]}"
		echo -e "${PR}${_crypt::15}${PD}$(basename ${__crypt_arr[1]})${PE}${_trim}${PP}${_pp::37}${PT}${_time}${NOR}\r" >&${_socat[1]}
	done
	echo >&${_socat[1]}

	# Output cached passphrases.
	[[ ${conf[LOGLEVEL]} -ge 1 ]] && echo -e "${PR}${GREY}${BOLD}Cached Passphrases:${NOR} ${!cached_pp[@]}\r\n" >&${_socat[1]}
	# Output passphrases.
	echo -e "${PR}${GREY}${BOLD}PASSPHRASE${PK}VALUE${PE}TIMEOUT${NOR}\r" >&${_socat[1]}
	for _pp in ${!cached_pp[@]}; do
		echo -ne "\r${_pp}${PK}" >&${_socat[1]}
		if ! _passphrase="$(t_keyctl 1 pipe "$(t_keyctl 1 request user "${_pp}" @s)")"; then
			echo -e "${RED}${BOLD}FAIL${NOR}" >&${_socat[1]}
			echo "passphrase ${_pp} 2 0" >${conf[FIFO]}
		else
			echo -ne "\"$([[ ${conf[LOGLEVEL]} -ge 3 ]] && echo "${_passphrase}" || echo ${YEL}N/A${NOR})\"${PE}" >&${_socat[1]}
			if [[ ${cached_pp[${_pp}]##*,} -eq 0 ]]; then
				_timeout="-"
			else
				_timeout=$((${cached_pp[${_pp}]##*,}-$(do_timer ${cached_pp[${_pp}]%%,*} |cut -d'.' -f1)))
			fi
			if [[ "${_timeout}" != "-" ]]; then
				_timeout="$((_timeout/86400))d $((_timeout/3600%24))h $((_timeout/60%60))m $((_timeout%60))s"
			fi
			echo -e "${_timeout}${NOR}" >&${_socat[1]}
		fi
	done
	echo >&${_socat[1]}
	echo -e "\r${UL}${myname} Running Since $(do_timer date ${time_start}) ($(do_timer ${time_start})s)${NOR}\r" >&${_socat[1]}

	do_term_control 0
}

do_control_smarterase()
{
	# Secure Erase Device.
	local _crypt="${_crypt_arr[0]}" _dev="$(do_find_dev "${_crypt_arr[1]}")" _res=""

	if [[ -z "${_crypt_arr[@]}" ]]; then
		echo -e "\r${RED}${BOLD}${msg[5]} not Found on Crypttab.${NOR}\r" >&${_socat[1]}
		do_log debug "${msg[5]} not found on crypttab"
		do_term_control 1
	elif [[ -z "${_dev}" ]]; then
		echo -e "\r${RED}${BOLD}Device ${_dev} not Found in ${conf[BLOCKDEVSDIRS]}.${NOR}\r" >&${_socat[1]}
		do_log debug "${_dev} not Found in ${conf[BLOCKDEVSDIRS]}"
		do_term_control 1
	fi

	[[ ${_smartall} -eq 1 ]] && smartctl -x ${_dev} >&${_socat[1]} 2>&1 || smartctl -A ${_dev} >&${_socat[1]} 2>&1
	if [[ ${_smarttest} -eq 1 || "${cmd}" == "erase" ]] && t_dmsetup 0 info "${_crypt}"; then
		echo -e "\r${RED}${BOLD}${_crypt} Still Active.${NOR}\r" >&${_socat[1]}
		do_log debug "${_crypt} still active"
		do_term_control 1
	fi

	if [[ "${cmd}" == "smart" && ${_smarttest} -eq 1 ]]; then
		smartctl -t long ${_dev} >&${_socat[1]} 2>&1
		do_log info "smart test started on ${_crypt}"
		echo -e "\r${GRN}${BOLD}Started SMART test on ${_dev}.${NOR}\r" >&${_socat[1]}
	elif [[ "${cmd}" == "erase" ]]; then
		do_control_confirm "This Will Wipe all Data on ${_dev}, Are You Sure? (y/N)" "n"
		if [[ "${_res}" == "y" ]]; then
			echo -e "${RED}${BOLD}Secure Erasing ${_dev} ${YEL}password: $(hostname)${NOR}\r" >&${_socat[1]}
			if hdparm -I ${_dev} |grep "ENHANCED SECURITY ERASE UNIT" >/dev/null 2>&1; then
				_res="--security-erase-enhanced"
			else
				_res="--security-erase"
			fi
			hdparm --security-set-pass "$(hostname)" ${_dev}
			hdparm ${_res} "$(hostname)" ${_dev} &
			do_log info "secure erasing ${_crypt}"
			do_control_confirm "Do You Want to Wait for the Erase to Finish? (y|N)" "n"
			[[ "${_res}" == "y" ]] && wait $! || _pid_putkey=$!
		fi
	fi

	do_term_control 0
}

do_control_putrmkey()
{
	# Remove the key file for the passphrase.
	local _pp="$(do_eval_pp "${msg[3]}")" _res=0 _key="$(t_keyctl 1 request user "${_pp}" @s)" _passphrase _t _s
	local _keyfile="${FWDIR}/${DISTNAME}_${_pp}.key-${FWGUID}"
	if [[ ${_fw} -eq 0 && ${_cache} -eq -2 && "${_srv}" == "0" && ${_add} -eq -3 && ${_confirm} -eq 0 && ${_upd} -eq 0 ]]; then
		[[ -n "${keylife[${_pp}]}" ]] && _cache="${keylife[${_pp}]}" || _cache=${conf[KEYLIFE]}
		_fw=1 _srv=${bootconf[BOOTSERVERS]} _add=-1 _confirm=1
	elif [[ ${_fw} -eq 0 && ${_cache} -eq -2 && "${_srv}" == "0" && ${_add} -eq -3 && ${_confirm} -eq 1 && ${_upd} -eq 0 ]]; then
		[[ -n "${keylife[${_pp}]}" ]] && _cache="${keylife[${_pp}]}" || _cache=${conf[KEYLIFE]}
		_fw=1 _srv=${bootconf[BOOTSERVERS]} _add=-1 _confirm=0
	elif [[ ${_upd} -eq 1 && ${_srv} == "0" ]]; then
		_srv="${bootconf[BOOTSERVERS]}"
	fi
	[[ "${_srv}" == "1" ]] && _srv=${bootconf[BOOTSERVERS]}
	if [[ "${cmd}" == "rmkey" ]]; then
		_s="Remove " _t=" from:"
	elif [[ "${_pp}" != "::" ]]; then
		_s="Put " _t=" to:"
	else
		_s="Update" _pp=""
	fi
	[[ ${_cache} -ne -2 ]] && _t+=" cache"
	[[ ${_fw} -eq 1 ]]     && _t+=" firmware"
	[[ "${_srv}" != "0" ]] && _t+=" ${_srv}"
	do_log debug "${_s,,}${_pp}${_t,,}"
	echo -e "\r${BOLD}${_s}${_pp}${_t}.${NOR}\r" >&${_socat[1]}

	# Add or remove key to/from firmware
	if [[ "${cmd}" == "putkey" && -n "${_pp}" ]] && ! do_control_get_passphrase "${_pp}"; then
		do_term_control 1
	elif [[ "${cmd}" == "rmkey" && ${_fw} -eq 1 && ! -e ${_keyfile} ]]; then
		echo -e "\r${BOLD}${RED}${_keyfile} Does not Exist.${NOR}\r" >&${_socat[1]}
		do_log debug "${_keyfile} does not exist"
	elif  [[ ${_fw} -eq 1 ]]; then
		[[ ${_confirm} -eq 1 ]] && do_control_confirm "Continue ${_s}${_pp}${_t%%:*} Firmware? (Y/n)" "y" || _res="y"
		if [[ ${_res} == "y" ]]; then
			if [[ "${cmd}" == "rmkey" ]] && chattr -i ${_keyfile} && rm -f ${_keyfile}; then
				echo -e "\r${BOLD}${GRN}Removed ${_keyfile} Succesfully.${NOR}\r" >&${_socat[1]}
				do_log info "removed ${_keyfile}"
			elif [[ "${cmd}" == "putkey" ]] && do_write_keyfile "${_pp}" "${_passphrase}"; then
				echo -e "\r${BOLD}${GRN}Wrote ${_keyfile} Succesfully.${NOR}\r" >&${_socat[1]}
				do_log info "wrote ${_keyfile}"
			else
				[[ "${cmd}" == "putkey" ]] && _res="Write" || _res="Remove"
				echo -e "\r${BOLD}${RED}Failed to ${_res} ${_keyfile}.${NOR}\r" >&${_socat[1]}
				[[ "${cmd}" == "rmkey" ]] && do_log info "failed to remove ${_keyfile}"
			fi
		fi
	fi

	# Add or remove key to/from keyring.
	if [[ "${cmd}" == "rmkey" && ${_cache} -ne -2 && -z "${_key}" ]]; then
		do_log debug "${_pp} not cached"
		echo -e "\r${BOLD}${RED}${_pp} not Cached.${NOR}\r" >&${_socat[1]}
	elif [[ ${_cache} -ne -2 ]]; then
		[[ ${_confirm} -eq 1 ]] && do_control_confirm "${_s}${_pp}${_t%%:*} Cache? (Y/n)" "y" || _res="y"
		if [[ ${_res} == "y" ]]; then
			if [[ "${cmd}" == "rmkey" ]] && t_keyctl 0 revoke "${_key}" && t_keyctl 0 unlink "${_key}" @s; then
				echo "passphrase ${_pp} 2 0" >${conf[FIFO]}
				echo -e "\r${BOLD}${GRN}Removed ${_pp} from Cache.${NOR}\r" >&${_socat[1]}
				do_log info "removed ${_pp} from cache"
			elif [[ "${cmd}" == "putkey" && $(do_cache_pp "${_pp}" "@s" "${_cache}" "${_passphrase}")$? -ne 1 ]]; then
				echo "passphrase ${_pp} 1 ${_cache}" >${conf[FIFO]}
				echo -e "\r${BOLD}${GRN}Cached ${_pp} Passphrase.${NOR}\r" >&${_socat[1]}
			else
				[[ "${cmd}" == "rmkey" ]] && _res="Remove ${_pp} Passphrase from Cache" || _res="Cache ${_pp} Passphrase"
				echo -e "\r${BOLD}${RED}Failed to ${_res}.${NOR}\r" >&${_socat[1]}
				[[ "${cmd}" == "rmkey" ]] && do_log info "failed to remove ${_pp} from cache"
			fi
		fi
	fi

	# Add or remove key to/from servers (cache).
	if [[ "${_srv}" != "0" ]]; then
		exec {__fd_user}>&${_socat[1]}
		if [[ ${_upd} -eq 1 && ${_confirm} -eq 1 ]]; then
			do_control_confirm "${_s}${_pp}${_t%%:*}: ${NOR}${GREY}${_srv}${RED}${BOLD}? (Y/n)" "y"
		else
			_res="y"
		fi
		if [[ ${_upd} -eq 1 && "${_res}" == "y" ]]; then
			echo -e "\r${BOLD}${GRN}${_s}: ${GREY}${_srv}.${NOR}\r" >&${_socat[1]}
			do_log info "${_s,,}: ${_srv}"
			[[ "${cmd}" == "putkey" ]] && key_clnt "UPDATE" ${_srv} & _pid_putkey=$!; wait ${_pid_putkey}
			echo -e "\r" >&${_socat[1]}
		fi
		if [[ -n "${_pp}" && ${_confirm} -eq 1 ]]; then
			do_control_confirm "${_s}${_pp}${_t%%:*} Boot Servers: ${NOR}${GREY}${_srv}${RED}${BOLD}? (Y/n)" "y" || _res="y"
		fi
		if [[ -n "${_pp}" && "${_res}" == "y" ]]; then
			echo -e "\r${BOLD}${GRN}${_s}${_pp} Key${_t} Boot Servers: ${GREY}${_srv}.${NOR}\r" >&${_socat[1]}
			do_log info "${_s,,}${_pp} key${_t,,} boot servers: ${_srv}"
			if [[ "${cmd}" == "putkey" ]]; then
				key_clnt "PUT" "${_pp}" "${_passphrase}" ${_srv} &
			else
				key_clnt "DEL" "${_pp}" ${_srv} &
			fi
			_pid_putkey=$!; wait ${_pid_putkey}
			echo -e "\r" >&${_socat[1]}
		fi
		if [[ -n "${_pp}" && ${_add} -ne -3 && ${_confirm} -eq 1 ]]; then
			do_control_confirm "Add ${_pp}${_t%%:*} Boot Servers Cache: ${NOR}${GREY}${_srv}${RED}${BOLD}? (Y/n)" "y"
		else
			_res="y"
		fi
		if [[ -n "${_pp}" && "${_res}" == "y" && ${_add} -ne -3 ]]; then
			[[ ${_add} -eq -2 && -n "${keylife[${_pp}]}" ]] && _add=${keylife[${_pp}]}
			[[ ${_add} -eq -2 ]] && _add=${conf[KEYLIFE]}
			[[ "${cmd}" == "putkey" ]] && _s="Adding" _t="to" || _s="Deleting" _t="from"
			echo -e "\r${BOLD}${GRN}${_s} ${_pp} Key ${_t%%:*} Boot Servers Cache: ${GREY}${_srv}.${NOR}\r" >&${_socat[1]}
			do_log info "${_s,,} ${_pp} key ${_t,,} boot servers cache: ${_srv}"
			if [[ "${cmd}" == "putkey" ]]; then
				key_clnt "ADD" "${_pp}" "${_add}" "${_passphrase}" ${_srv} &
			else
				key_clnt "REM" "${_pp}" ${_srv} &
			fi
			_pid_putkey=$!; wait ${_pid_putkey}
			echo -e "\r" >&${_socat[1]}
		fi
	fi

	unset _pid_putkey
	do_term_control 0
}

do_control_del()
{
	local _del_crypt="${_crypt_arr[0]}" _del_dev="${_crypt_arr[1]}" _del_pp="${_crypt_arr[2]}" _del_trim="${_crypt_arr[3]}"
	local _del_time="$(do_timer)" _res="" _r=0

	# Check if specified crypt is on tab, user decides to exit or continue if it's not.
	if [[ -z "${_crypt_arr[@]}" ]]; then
		_del_crypt=${msg[3]}
		if [[ -n "${active_mnt[${_del_crypt}]}" ]]; then
			_crypt_arr=(${_del_crypt} ${active_mnt[${_del_crypt}]})
		else
			_crypt_arr[0]="${_del_crypt}"
			_crypt_arr[1]="/dev/$(t_dmsetup 1 deps ${_del_crypt} -o blkdevname |cut -d':' -f2 |tr -d " ()" |cut -d':' -f2)"
			_crypt_arr[2]="-"
			[[ "$(t_lsblk -rD ${conf[DMDIR]}/${_del_crypt} |head -n2 |tail -n1 |cut -d' ' -f3-4)" =~ 0B ]] && _crypt_arr[3]=0 \
																										   || _crypt_arr[3]=1
		fi
		[[ -z "${_crypt_arr[4]}" ]] && _crypt_arr[4]="$(do_timer)"
		_del_dev="${_crypt_arr[1]}" _del_pp="${_crypt_arr[2]}" _del_trim="${_crypt_arr[3]}" _del_time="${_crypt_arr[4]}"
		do_log debug "${_del_crypt} not found in Crypttab.${NOR}"
		echo -ne "\r${RED}${BOLD}${_del_crypt} not on Crypttab, Continue Removing (y/N)? ${NOR}" >&${_socat[1]}
		read -t${conf[USER_TIMEOUT]} -rsn1 -u ${_socat[0]} _res
		[[ "${_res,,}" == $'\r' || -z "${_res,,}" ]] && _res=n
		echo -e "${BOLD}${_res}${NOR}\r" >&${_socat[1]}
		[[ "${_res,,}" != "y" ]] && do_term_control 0
		_crypttab=0
	fi
	
	daemon_unmount_crypt "${_del_crypt}" &
	wait $!; _r=$?; case ${_r} in
	0)
		do_log info "removed ${_del_dev##*/} as ${_del_crypt} using ${_del_pp} passphrase trim ${_del_trim}"
		echo -e "\r${BOLD}${GRN}Removed ${_del_dev##*/} as ${_del_crypt} TRIM ${_del_trim} Using ${_del_pp} Passphrase,"\
				"Active Since $(do_timer date ${_del_time})${NOR}\r" >&${_socat[1]};;
	2)
		_r=2
		do_log debug "${_del_crypt} not active"
		echo -e "\r${BOLD}${YEL}${_del_crypt} not Active${NOR}\r" >&${_socat[1]};;
	*)
		_r=1
		do_log info "failed to remove ${_del_dev##*/} as ${_del_crypt} using ${_del_pp} passphrase trim ${_del_trim}"
		echo -e "\r${BOLD}${RED}Failed to Remove ${_del_dev##*/} as ${_del_crypt} Using ${_del_pp} Passphrase"\
				"TRIM ${_del_trim}${NOR}\r" >&${_socat[1]};;
	esac

	# Remove from crypttab.
	if [[ ${_crypttab} -eq 1 && ( ${_r} -ne 0 || ${_confirm} -eq 1 ) ]]; then
		do_control_confirm "Continue Removing ${_del_crypt} from Crypttab? (Y/n)" "y"
	else
		_res="y"
	fi
	if [[ ${_crypttab} -eq 1 && "${_res}" == "y" ]]; then
		sed -i "/^${_del_crypt}\\s/D" ${conf[CRYPTTAB]}
		echo "reload" >${conf[FIFO]}
		do_log warning "removed ${_del_dev##*/} as ${_del_crypt} using ${_del_pp} passphrase trim ${_del_trim} from crypttab"
		echo -e "\r${BOLD}${GRN}Removed ${_del_dev} as ${_del_crypt} TRIM ${_del_trim} from Crypttab${NOR}\r" >&${_socat[1]}
	fi

	do_term_control ${_r}
}

do_control_add()
{
	local _add_crypt="${_crypt_arr[0]}" _add_dev="${msg[3]}" _add_dev2="${msg[4]}" _add_ppa=($(tr '/' ' ' <<<"${msg[5]}"))
	local _add_trim="${msg[6]}" _res="" _r=0 __crypt_arr _passphrase=""
	local _add_algo="${conf[ALGO]}" _add_keysz="${conf[KEYSZ]}" _add_hash="${conf[HASH]}" _add_pp=""
	
	if [[ ${_crypttab} -eq 0 && -z "${_add_crypt}" ]]; then
		# Recevied add with just a crypt, if it's not on the tab exit.
		echo -e "\r${BOLD}${RED}${add_crypt} not Found on Crypttab${NOR}\r" >&${_socat[1]}
		do_log debug "${msg[5]} not found on crypttab"
		do_term_control 1
	elif [[ ${_crypttab} -eq 0 ]]; then
		_add_dev="$(do_find_dev "${_crypt_arr[1]}")" _add_pp="$(do_eval_pp "${_crypt_arr[2]}")" _add_trim="${_crypt_arr[3]}"
		[[ -n "${_crypt_arr[4]}" ]] && _add_algo="${_crypt_arr[4]}" _add_keysz="${_crypt_arr[5]}" _add_hash="${_crypt_arr[6]}"
	elif [[ ${_crypttab} -eq 1 ]]; then
		# Crypt should be added to tab, check if specified crypt and dev are already on tab.
		if [[ "${#_add_ppa[@]}" -ne 1 && "${#_add_ppa[@]}" -ne 4 ]]; then
			echo -e "\r${BOLD}${RED}${_add_ppa[@]} Not a Valid Passphrase${NOR}" >&${_socat[1]}
			do_term_control 1
		fi
		[[ -n "${_add_ppa[1]}" ]] && _add_algo="${_add_ppa[1]}" _add_keysz="${_add_ppa[2]}" _add_hash="${_add_ppa[3]}"
		__crypt_arr=($(do_xcrypt_fromtab "${_add_dev2}")) _add_pp="${_add_ppa[0]}"
		if [[ -z "${_crypt_arr[@]}" && -z "${__crypt_arr[@]}" ]]; then
			# Crypt and dev not on tab, find device.
			_add_dev="$(do_find_dev "${_add_dev}")" _add_dev2="$(do_find_dev "${_add_dev2}")"
			if [[ -z "${_add_dev}" && -z "${_add_dev2}" ]]; then
				do_log debug "neither ${msg[3]} nor ${msg[4]} is a valid block device in ${conf[BLOCKDEVDIRS]}"
				echo -e "\r${BOLD}${RED}Neither ${msg[3]} nor ${msg[4]} is a Valid Block Device in"\
						" ${conf[BLOCKDEVDIRS]}.${NOR}\r" >&${_socat[1]}
				do_term_control 1
			elif [[ -n "${_add_dev}" && -n "${_add_dev2}" ]]; then
				do_log debug "both ${_add_dev} and ${_add_dev2} are valid block devices in ${conf[BLOCKDEVDIRS]}"
				echo -e  "\r${BOLD}${RED}Both ${_add_crypt} and ${_add_dev} are Valid Block Devices in"\
						 "${conf[BLOCKDEVDIRS]}'.${NOR}\r" >&${_socat[1]}
				do_term_control 1
			fi
			[[ -n "${_add_dev}" ]] && _add_crypt="${msg[4]}" || _add_crypt="${msg[3]}" _add_dev="${_add_dev2}"
		else
			# Crypt and/or dev already on tab.
			if [[ -n "${_crypt_arr[@]}" && -n "${__crypt_arr[@]}" ]]; then
				do_log debug "both ${msg[3]} and ${msg[4]} already on crypttab"
				echo -e "\r${BOLD}${RED}Both ${msg[3]} and ${msg[4]} Already on Crypttab.${NOR}\r" >&${_socat[1]}
			elif [[ -n "${_crypt_arr[@]}" ]]; then
				do_log debug "${_add_dev} already on crypttab"
				echo -e "\r${BOLD}${RED}${_add_dev} Already on Crypttab.${NOR}\r" >&${_socat[1]}
			else
				do_log debug "${_add_dev2} already on crypttab"
				echo -e "\r${BOLD}${RED}${_add_dev2} Aready on Crypttab.${NOR}\r" >&${_socat[1]}
			fi
			do_term_control 1
		fi
	fi
	if [[ ${_add_crypt}${_add_dev}${_add_pp} =~ ( |,|\||\$) || ( ${_crypttab} -eq 0 && -z "${_add_dev}" ) ]]; then
		do_log debug "incorrect crypt or dev"
		if [[ ${_crypttab} -eq 0 && -z "${_add_dev}" ]]; then
			echo -e "\r${BOLD}${RED}${_crypt_arr[1]} not Found in \"${conf[BLOCKDEVDIRS]}\"${NOR}\r" >&${_socat[1]}
		elif [[ -n "${_add_dev}" ]]; then
			echo -e "\r${BOLD}${RED}Illegal Characters \" $,|\" in Crypt or Dev.${NOR}\r" >&${_socat[1]}
		fi
		do_term_control 1
	elif ! do_control_get_passphrase "${_add_pp}"; then
		# if we do not get a passphrase we cannot mount, continue to add on tab after confirmation.
		echo -e "\r${BOLD}${RED}No Passphrase Received, Cannot Mount ${_add_dev} as ${_add_crypt} TRIM ${_add_trim}"\
				"Using ${_add_pp} Passphrase.${NOR}\r" >&${_socat[1]}
		_confirm=1
	elif [[ $(do_cache_pp "${_add_pp}" "@s" "-1" "${_passphrase}")$? -eq 1 ]]; then
		echo -e "\r${BOLD}${RED}Failed to Cache ${_add_pp} Passphrase.${NOR}\r" >&${_socat[1]}
		do_term_control 1
	else
		echo "passphrase ${_add_pp} 1 -1" >${conf[FIFO]}
		daemon_mount_crypt "${_add_crypt}" "${_add_dev}" "${_add_pp}" "${_add_trim}" "${_add_algo}" "${_add_keysz}" "${_add_hash}" &
		wait $!; _r=$?; case ${_r} in
		0)
			do_log info "mounted ${_add_dev} as ${_add_crypt} trim ${_add_trim} using ${_add_pp} passphrase"
			echo -e "\r${BOLD}${GRN}Mounted ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using"\
					"${_add_pp} Passphrase${NOR}\r" >&${_socat[1]};;
		1)
			do_log info "failed to mount ${_add_dev} as ${_add_crypt} trim ${_add_trim} using ${_add_pp} passphrase"
			echo -e "\r${BOLD}${RED}Failed to Mount ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using"\
					"${_add_pp} Passphrase${NOR}\r" >&${_socat[1]};;
		2)
			do_log debug "${_add_dev} as ${_add_crypt} trim ${_add_trim} using ${_add_pp} passphrase already active"
			echo -e "\r${BOLD}${YEL}${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase"\
					"Already Active${NOR}\r" >&${_socat[1]};;
		3)
			do_log warning "mounted ${_add_dev} as ${_add_crypt} trim ${_add_trim} using ${_add_pp} passphrase"
			echo -e "\r${BOLD}${YEL}Mounted ${_add_dev} as ${_add_crypt} ${BOLD}${RED}TRIM ${_add_trim}"\
					"${BOLD}${YEL}Using ${_add_pp} Passphrase${NOR}\r" >&${_socat[1]};;
		*)
			_r=1
			do_log info "failed to mount ${_add_dev} as ${_add_crypt} trim ${_add_trim} using ${_add_pp} passphrase"
			echo -e "\r${BOLD}${RED}TIMEOUT or ERROR! (${_res})${NOR}\r" >&${_socat[1]};;
		esac
	fi

	if [[ ${_crypttab} -eq 1 ]]; then
		[[ -n "${_add_ppa[1]}" ]] && _add_pp+="/${_add_algo}/${_add_keysz}/${_add_hash}"
		if [[ ${_r} -ne 0 || ${_confirm} -eq 1 ]]; then
		# Crypt should be added to tab, ask for confirmation if necessary (error or request by user).
			do_control_confirm \
					"Add ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase to Crypttab? (Y/n)"
		else
			_res="y"
		fi
		if [[ "${_res}" == "y" ]]; then
			# Add the crypt to the crypttab and send reload signal to daemon.
			echo -e "${_add_crypt}\t${_add_dev##*/}\t${_add_pp}\t${_add_trim}" >>${conf[CRYPTTAB]}
			do_log warning "added ${_add_dev} as ${_add_crypt} passphrase ${_add_pp} trim ${_add_trim} to crypttab"
			echo -e "\r${BOLD}${GRN}Added ${_add_dev} as ${_add_crypt} Passphrase ${_add_pp} TRIM ${_add_trim}"\
					"to Crypttab.${NOR}\r" >&${_socat[1]}
			echo "reload" >${conf[FIFO]}
		fi
	fi
	_add_pp="${_add_pp%%/*}"
	[[ ${_confirm} -eq 1 || ${_r} -ne 0 ]] && do_control_confirm "Put ${_add_pp} Passphrase to Bootservers? (Y/n)" y || _res="y"
	if [[ "${_res}" == "y" ]]; then
		echo -e "\r${BOLD}${GRN}Putting ${_add_pp} Key to Boot Servers: ${GREY}${bootconf[BOOTSERVERS]}.${NOR}\r" >&${_socat[1]}
		exec {__fd_user}>&${_socat[1]}
		key_clnt "PUT" "${_add_pp}" "${_passphrase}" & _pid_putkey=$!
		echo -e "\r" >&${_socat[1]}
	fi

	[[ -n "${_pid_putkey}" ]] && wait ${_pid_putkey}
	unset _pid_putkey
	do_term_control ${_r}
}

do_control_confirm()
{
	echo -ne "\r${RED}${BOLD}$1 ${NOR}" >&${_socat[1]}
	read -t${conf[USER_TIMEOUT]} -rsn1 -u ${_socat[0]} _res 
	[[ $? -ne 0 && $? -ne 142 ]] && do_term_control 1
	[[ "${_res,,}" != "y" && "${_res,,}" != "n" ]] && _res=${2,,} || _res=${_res,,}
	echo -e "${BOLD}${_res}${NOR}\r" >&${_socat[1]}
}

do_control_get_passphrase()
{
	# Ask to get passphrase from network, if not cached, or query the user for the passphrase.
	local _key _pp=$1 _res _fd_getpp _pid_getpp __fd_up __fd_user
	if _key="$(t_keyctl 1 request user "$1" @s)" && _passphrase="$(t_keyctl 1 pipe "${_key}")"; then
		# Passphrase is still cached, use it and notify the daemon about the crypt.
		do_log debug "found cached ${_pp} passphrase"
		echo -e "\r${BOLD}${GRN}Found Cached ${_pp} Passphrase.${NOR}\r" >&${_socat[1]}
	else
		_key=""
		do_log debug "${_pp} passphrase not cached"
		echo -e "\r${BOLD}${RED}Passphrase ${_pp} not Cached.${NOR}\r" >&${_socat[1]}
		[[ -n "${cached_pp[${_pp}]}" ]] && echo "passphrase ${_pp} 2 0" >${conf[FIFO]}
	fi

	# If confirm option is specified ask to retreive passphrase from boot servers.
	if [[ -z "${_key}" && ( ${conf[NET_ONLINE]} -eq 0 || $(t_networkctl status |grep "Online state") =~ (online|partial)$ ) ]]; then
		if [[ ${_confirm} -eq 1 ]]; then
			do_control_confirm "${_pp} Passphrase Not Cached, Get Passphrase from Boot Servers? (Y/n)" "y"
		else
			_res="y"
		fi
		if [[ "${_res}" == "y" ]]; then
			do_log debug "getting ${_pp} passphrase from boot servers: ${bootconf[BOOTSERVERS]}"
			echo -e "\r${BOLD}Getting ${_pp} Passphrase from Boot Servers: ${GREY}${bootconf[BOOTSERVERS]}${NOR}\r" >&${_socat[1]}
			exec {_fd_getpp}< <(key_clnt "GET" "${_pp}" {__fd_up}>&1- {__fd_user}>&${_socat[1]}-)
			_pid_getpp=$!
			if IFS= read -t$((conf[PP_TIMEOUT]/conf[NET_RETRIES]+1)) -ru${_fd_getpp} _passphrase; then
				_key=1
			else
				echo -ne "\r\n${RED}${BOLD}Failed to Get ${_pp} Passphrase from Boot Servers.${NOR}" >&${_socat[1]}
			fi
			exec {_fd_getpp}>&-
			echo -e "${NOR}\r" >&${_socat[1]}
			[[ "$(</proc/${_pid_getpp}/comm)" == "${MYNAME}" ]] && kill -SIGTERM ${_pid_getpp} 2>/dev/null
		fi
	fi

	# Query the user for the passphrase.
	if [[ -z "${_key}" ]]; then
		exec {_fd_getpp}< <(query_passphrase "${_pp}" {__fd_up}>&1- {__fd_user[0]}<&${_socat[0]}- {__fd_user[1]}>&${_socat[1]}-)
		_pid_getpp=$!
		if IFS= read -t${conf[PP_TIMEOUT]} -ru${_fd_getpp} _passphrase; then
			_key=1
		else
			do_log debug "failed to get ${_pp} passphrase from user"
			echo -e "\r\n${RED}${BOLD}Failed to Get ${_pp} Passphrase from You Yourself and You${NOR}\r" >&${_socat[1]}
		fi
		exec {_fd_getpp}>&-
		[[ "$(</proc/${_pid_getpp}/comm)" == "${MYNAME}" ]] && kill -SIGTERM ${_pid_getpp} 2>/dev/null
	fi

	# Got passphrase, put and cache it.
	if [[ -n "${_key}" ]]; then
		do_log debug "got ${_pp} passphrase"
		if [[ -z "${_passphrase}" ]]; then
			echo -e "\r${BOLD}${YEL}Your ${_pp} Passphrase Has no Character, Just Like You.${NOR}\r" >&${_socat[1]}
		fi
		return 0
	else
		do_log debug "${_pp} passphrase error or timeout"
		return 1
	fi
}

# [END OF DAEMON CONTROL FUNCTIONS]

# [BEGIN SHARED FUNCTIONS]

# Execut a command with or without timeout, this will keep main process interuptable and prevents stalls due to hanging commands.
# Paramter 1 Timeout 0 if no timeout. Parameter 2 Relay output of command. or not.
do_term_cmd_timeout()
{
	if [[ -n "${pid[@]}" && ( "$(</proc/${pid[0]}/comm)" == "${cmd::15}" || "$(</proc/${pid[1]}/comm)" == "${cmd::15}" ) ]]; then
		kill -SIGTERM ${pid[@]} 2>&1
		do_log debug "killed ${cmd} (PID: ${pid[1]})"
	fi
	[[ "$1" == "SIGINT" && -n "${ti[@]}" ]] && ${ti[0]} ${ti[@]:1}
	[[ "$1" == "SIGTERM" && -n "${tt[@]}" ]] && ${tt[0]} ${tt[@]:1}
}

do_cmd_timeout()
{
	local to="$([[ $1 -eq -1 ]] && echo ${conf[CMD_TIMEOUT]} || echo $1)" res="$2" cmd="$3" ti tt pid
	local  r=(0 0) in out fd_cmd _time_start=$(do_timer)

	# Redirect input to command, output according to result parameter, save current traps, run command in the background.
	[[ ${res} -eq 0 ]] && exec {out}>/dev/null {err}>/dev/null
	[[ ${res} -eq 1 ]] && exec {out}>&1 {err}>/dev/null
	[[ ${res} -eq 2 ]] && exec {out}>&1 {err}>&1
	ti="$(trap -p SIGINT)"; ti="${ti%\'*}"; ti="${ti##*\'}"; ti=(${ti})
	tt="$(trap -p SIGTERM)"; tt="${tt%\'*}"; tt="${tt##*\'}"; tt=(${tt})
	trap 'do_term_cmd_timeout SIGINT' SIGINT; trap 'do_term_cmd_timeout SIGTERM' SIGTERM
	shift 3
	exec {in}<&0- {stdout}>&1- {stderr}>&2- {fd_cmd}< <(${cmd} $@ 0<&${in}- >&${out}- 2>&${err}- & echo $!; wait $!; echo $?;)
	pid[0]=$!
	do_log debug2 "running \"${cmd} ${@}\" (PID: ${pid[0]}) with $([[ ${to} -eq 0 ]] && echo no || echo ${to}s) timeout"

	# Read the PID an error means subshell killed or worse. Set new timeout, and evaluate if timeout has already been reached.
	IFS= read $([[ ${to} -ne 0 ]] && echo "-t${to}") -ru${fd_cmd} res
	r[0]=$?
	[[ ${r[0]} -eq 0 ]] && pid[1]="${res}"
	[[ ${r[0]} -ne 0 || -z "${res}" ]] && r=(1 1)
	if [[ ${to} -ne 0 ]]; then
		to="$((to-$(do_timer ${_time_start} |cut -d'.' -f1)))"
		[[ ${to} -le 0 ]] && r[1]=142
	fi
	if [[ ${r[0]} -eq 0 && ${r[1]} -eq 0 ]]; then
		IFS= read $([[ ${to} -ne 0 ]] && echo "-t${to}") -ru${fd_cmd} res
		r[1]=$?
		# A read error other than timeout means something terrible has happened, this is also a timeout.
		if [[ ${r[1]} -eq 0 ]]; then
			r[1]="${res}"
			do_log debug2 "running \"${cmd} $@\" (PID: ${pid[1]}) complete (${r[1]})"
		else
			r[1]=142
		fi
	fi
	if [[ ${r[0]} -ne 0 || ${r[1]} -eq 142 ]]; then
		kill -SIGTERM ${pid[@]} >/dev/null 2>&1
		do_log warning "command ${cmd} (PID: ${pid[1]}) $([[ ${r[0]} -ne 0 ]] && echo "failed to start" || echo "timed out")"
	fi

	# Restore traps and close fds. Return the result.
	res=${ti[@]}; trap "${res}" SIGINT; res=${tt[@]}; trap "${res}" SIGTERM
	exec {fd_cmd}>&- {out}>&- {err}>&- 0<&${in}- 1>&${stdout}- 2>&${stderr}-
	return ${r[1]}
}
t_sleep() { do_cmd_timeout $((${1%%.*}+1)) 0 sleep $@; return $?; }
t_keyctl() { do_cmd_timeout -1 $1 keyctl ${@:2}; return $?; }
t_dmsetup() { do_cmd_timeout -1 $1 dmsetup ${@:2}; return $?; }
t_lsblk() { do_cmd_timeout -1 1 lsblk ${@}; return $?; }
t_cryptsetup() { do_cmd_timeout $((5*conf[CMD_TIMEOUT])) 0 cryptsetup ${@}; return $?; }
t_kpartx() { do_cmd_timeout $((5*conf[CMD_TIMEOUT])) 0 kpartx ${@}; return $?; }
t_cat() { do_cmd_timeout -1 1 cat ${@}; return $?; }
t_tail() { do_cmd_timeout -1 1 tail ${@}; return $?; }
t_rm() { do_cmd_timeout -1 0 rm ${@}; return $?; }
t_cp() { do_cmd_timeout -1 0 cp ${@}; return $?; }
t_chattr() { do_cmd_timeout -1 0 chattr ${@}; return $?; }
t_chmod() { do_cmd_timeout -1 0 chmod ${@}; return $?; }
t_chgrp() { do_cmd_timeout -1 0 chgrp ${@}; return $?; }
t_efivar() { do_cmd_timeout -1 0 efivar ${@}; return $?; }
t_openssl() { 	local fd r; exec {fd}<<<"${passphrase}"; \
				do_cmd_timeout $((2*conf[CMD_TIMEOUT])) 0 openssl ${@} -pass fd:${fd}; \
				r=$?; exec {fd}>&-; return ${r}; }
t_networkctl() { NOTIFY_SOCKET= do_cmd_timeout -1 1 networkctl ${@}; return $?; }
t_diff() { do_cmd_timeout -1 0 diff ${@}; return $?; }
t_printf() { do_cmd_timeout -1 1 printf ${@}; return $?; }

do_xcrypt_fromtab()
{
	# Extract the line for the device received in the udev command from the crypttab into crypt_arr array.
	# Element 1 = cryptdisk name, Element 2 = cryptdisk block device, Element 3 = passphrase, Element 4 = TRIM
	local crypt_arr i key_arr
	for ((i=1;i<=$#;i++)); do
		crypt_arr=($(grep -iE "(^|\s)${!i}\s" <<<"${crypttab}" 2>/dev/null)) 
		[[ "${#crypt_arr[@]}" -eq 3 ]] && crypt_arr[3]=0
		if [[ "${#crypt_arr[@]}" -eq 0 ]]; then
			do_log debug "device ${!i} not found on crypttab"
		elif [[ "${#crypt_arr[@]}" -ne 4 || ${crypt_arr[0]}${crypt_arr[1]}${crypt_arr[2]} =~ (,| |\||\$) ]]; then
			do_log warning "incorrect crypttab entry ${crypt_arr[@]}"
		else
			do_log debug "device ${!i} found on crypttab"
			if [[ "${crypt_arr[3]}" == "1" || "${crypt_arr[3],,}" == "y" || "${crypt_arr[3],,}" == "yes" ]]; then
				crypt_arr[3]=1
			else
				crypt_arr[3]=0
			fi
			key_arr=($(tr '/' ' ' <<<"${crypt_arr[2]}"))
			if [[ "${#key_arr[@]}" -ne 1 && "${#key_arr[@]}" -ne 4 ]]; then
				do_log warning "incorrect crypttab entry ${crypt_arr[@]}"
				return
			fi
			crypt_arr[2]="$(do_eval_pp "${key_arr[0]}")"
			echo "${crypt_arr[@]} ${key_arr[1]} ${key_arr[2]} ${key_arr[3]}"
			return 0
		fi
	done
	return 1
}

do_eval_pp()
{
	# Evaluate and sanitize the passphrase.
	local pp="$1"
	shopt -s nocasematch
	[[ "${pp}" =~ ^${MYNAME}: ]] && pp="${pp:$((${#MYNAME}+1)):${#pp}}"
	[[ "${pp}" =~ ^(1|master|system|system:1|system:master)$ ]] && pp="system"
	echo "${pp}"
	shopt -u nocasematch
}

do_find_dev()
{
	local blockdevdir dev=$1
	for blockdevdir in ${conf[BLOCKDEVSDIRS]}; do if [[ -b ${blockdevdir}/${dev} ]]; then
		do_log debug "found ${blockdevdir}/${dev} for ${dev}"
		echo "${blockdevdir}/${dev}"
		return 0
	fi done
	do_log debug "${dev} not found in ${conf[BLOCKDEVSDIRS]}"
	return 1
}

do_check_passphrase()
{
	# Check the received passphrase against the stored key in firmware. Write key if it doesn't exist.
	local pp="$1" passphrase="$2" rmkey="$3" mode="$4" t="$([[ $4 -eq 0 ]] && echo "tail -c +5" || echo "cat -")" f
	[[ ${mode} -eq 0 ]] && f=${FWDIR}/${DISTNAME}_${pp}.key-${FWGUID} || f=${conf[KEYDIR]}/${pp}.key
	if [ -s ${f} ]; then
		if  $( t_cat ${f} |${t} |t_openssl aes-256-cbc -d -salt -pbkdf2 -in - -out /dev/null); then
			do_log debug "passphrase check ok"
			return 0
		fi
		do_log debug "passphrase check fail"
		if [[ ${rmkey} -eq 1 ]]; then 
			[[ ${mode} -eq 0 ]] && ! t_chattr -i ${f} && do_log error "unable to change mode of ${f}" && return 3
			! t_rm -f ${f} && do_log error "unable te remove ${f}" && return 3
		fi
		return 1
	else
		do_write_keyfile "${pp}" "${passphrase}" "$4" || return 3
		do_log debug "passphrase not checked"
		return 2
	fi
}

do_write_keyfile()
{
	# Write a keyfile for key received to firmware.
	local pp="$1" passphrase="$2" srv="$([[ -n "$3" && $3 -ge 1 ]] && echo 1)"
	local keydir="$([[ -n "${srv}" ]] && echo ${conf[KEYDIR]} || echo ${conf[CRYPTDISKSDDIR]})" res
	if ! head -c256 /dev/urandom |t_openssl aes-256-cbc -e -salt -pbkdf2 -in - -out ${keydir}/${pp}.key; then
		res=1
		do_log error "error creating ${keydir}/${pp}.key"
	elif [[ -z "${srv}" ]] && ! t_efivar -n ${FWGUID}-${DISTNAME}_${pp}.key -w \
										 -f ${keydir}/${pp}.key; then
		res=2
		do_log error "error writing ${FWDIR}/${DISTNAME}_${pp}.key-${FWGUID}"
	else
		res=0
		do_log debug "wrote $([[ -z "${srv}" ]] && echo ${FWDIR}/${DISTNAME}_${pp}.key-${FWGUID} \
												|| echo ${keydir}/${pp}.key)"
	fi
	[[ -z "${srv}" ]] && t_rm -f ${keydir}/${pp}.key
	[[ -n "${srv}" && ${res} -eq 0 ]] && t_chgrp ${conf[KEYSRV_GROUP]} ${keydir}/${pp}.key && t_chmod 640 ${keydir}/${pp}.key
	return ${res}
}

do_cache_pp()
{
	local pp="$1" key="$(t_keyctl 1 request user "$1" "$2")" ring="$2" timeout="$3" passphrase="$4" ks="$5" r=0
	[[ ${timeout} -eq -1 && -n "${keylife[${pp}]}" ]] && timeout=${keylife[${pp}]}
	[[ ${timeout} -eq -1 ]] && timeout=${conf[KEYLIFE]}
	[[ -n "${ks}" && "${pp}" == "${conf[SYSTEMPP]}" ]] && timeout=0
	
	if [[ -n "${key}" ]]; then
		do_log debug "${pp} passphrase already cached"
		r=2
	elif ! key="$(t_keyctl 1 padd user "${pp}" "${ring}" <<<"${passphrase}")"; then
		do_log warning "failed to cache ${pp} passphrase"
		r=1
	else
		do_log debug "cached ${pp} passphrase"
	fi
	if [[ ${r} -ne 1 ]]; then 
		t_keyctl 0 timeout "${key}" "${timeout}"
		[[ ${timeout} -eq 0 ]] && key="-" || key="$((timeout/86400))d $((timeout/3600%24))h $((timeout/60%60))m"
		do_log debug "set ${pp} timeout to ${key}"
	fi
	return ${r}
}

# Query the user for a passphrase. We get called with 1 parameter, the passphrase to query.
# Also a fd redirection for {__fd_up} to relay the passphrase and {__fd_user[]} when interactively querying for cli.
do_term_query_passphrase()
{
	trap 'do_log warning "unclean finish after $(do_timer ${_time_start})s"; exit 1;' SIGINT SIGTERM

	if [[ ! -z "${pid_askpp}" && "$(</proc/${pid_askpp}/comm)" == "systemd-ask-pas" ]]; then
		kill -SIGTERM ${pid_askpp}
		do_log debug "killed ask worker (PID: ${pid_askpp})"
	fi
	do_log debug "terminating after $(do_timer ${_time_start})s"
	exit 0
}

query_passphrase()
{
	# Ask for a pssphrase input by user through systemd-ask-password
	local pp="$1" POS="$2" OK="$3" WARN="$4" FAIL="$5" mode="$([[ -z "$6" ]] && echo 0 || echo $6)" pid_askpp fd_askpp
	local myname="query:$1:${BASHPID}:" _time_start=$(do_timer) passphrase _passphrase ppchk="${mode}" PRE="$7"
	trap 'do_term_query_passphrase' SIGINT SIGTERM
	do_log debug "query for ${pp} passphrase started"

	# Receive a passphrase from the user check it against key stored in firmware.
	do_ask_passphrase "${POS}${PRE}Enter ${pp} Passphrase: " || do_term_query_passphrase
	[[ ${mode} -ne 2 ]] && ppchk=$(do_check_passphrase "${pp}" "${passphrase}" 0 ${mode})$?
	case ${ppchk} in
	3)
		[[ -n "${FAIL}" ]] && echo -e "${FAIL}" >&${__fd_user[1]}
		do_log warning "Unable to confirm passphrase due to key error, giving up"
		do_term_query_passphrase;;
	2)
		# Key not present in firmware, ask for confirmation from the user.
		[[ -n "${WARN}" ]] && echo -e "${WARN}" >&${__fd_user[1]}
		_passphrase="${passphrase}" passphrase="$([[ ${mode} -ne 2 ]] && echo "Created key file. ")"
		do_ask_passphrase "${POS}${PRE}${passphrase}Confirm ${pp} Passphrase: " || do_term_query_passphrase
		# If the passphrase does not match, enter a loop until it does and wirte the keyfile if ok.
		until [[ "${_passphrase}" == "${passphrase}" ]]; do
			[[ -n "${FAIL}" ]] && echo -e "${FAIL}" >&${__fd_user[1]}
			do_ask_passphrase "${POS}${PRE}Passphrases do not Match. Enter ${pp} Passphrase: " || do_term_query_passphrase
			_passphrase="${passphrase}"
			[[ ${mode} -ne 2 && $(do_check_passphrase "${pp}" "${passphrase}" 1 ${mode})$? -ge 3 ]] && do_term_query_passphrase
			[[ -n "${WARN}" ]] && echo -e "${WARN}" >&${__fd_user[1]}
			do_ask_passphrase "${POS}${PRE}Confirm ${pp} Passphrase: " || do_term_query_passphrase
		done
		[[ ${mode} -ne 2 ]] && do_write_keyfile "${pp}" "${passphrase}"
		do_log debug "received passphrase after $(do_timer ${_time_start})s";;
	1)
		# Passphrase entered does not match stored key, keep asking until it does.
		until [[ ${ppchk} -eq 0 ]]; do
			do_log debug "query passphrase check failed"
			[[ -n "${FAIL}" ]] && echo -e "${FAIL}" >&${__fd_user[1]}
			do_ask_passphrase "${POS}${PRE}Incorrect Passphrase. Enter ${pp} Passphrase: " || do_term_query_passphrase
			ppchk=$(do_check_passphrase "${pp}" "${passphrase}" 0 ${mode})$?
		done
		do_log debug "received passphrase after $(do_timer ${_time_start})s";;
	0)
		# Passphrase received is ok.
		do_log debug "received passphrase after $(do_timer ${_time_start})s";;
	esac

	# Notify the daemon, so it knows passphrase worker has finished.
	[[ -n "${OK}" ]] && echo -e "${OK}" >&${__fd_user[1]}
	echo "${passphrase}" >&${__fd_up}
	
	do_log debug2 "took $(do_timer ${_time_start})s total"
}

do_ask_passphrase()
{
	local CHAR DEL="$(printf "\x7F")" ca=() c=0 x
	if [[ -z "${__fd_user[@]}" ]]; then
		# Query for the passphrase in the background, record pid so we can kill if passphrase is received from server.
		exec {fd_askpp}< <(NOTIFY_SOCKET= systemd-ask-password --timeout=0 --id=${pp} "$1" {__fd_up}>&-)
		pid_askpp=$!
		IFS= read -ru${fd_askpp} passphrase || exit 1
	else
		passphrase="" CHAR=""
		echo -ne "\r${BOLD}$1${NOR}" >&${__fd_user[1]}
		until [[ "${CHAR}" == $'\r' || "${CHAR}" == $'\n' ]]; do
			[[ $((RANDOM%100)) -le 50 ]] && x=1 || x=$((RANDOM%3+2))
		   	read -t${conf[USER_TIMEOUT]} -rsN1 -u${__fd_user[0]} CHAR || return 1
			if [[ "${CHAR}" == "${DEL}" && "${#passphrase}" -ge 1 ]]; then
				for (( c=0; c<${ca[${#passphrase}]}; c++ )); do echo -ne "\b \b" >&${__fd_user[1]}; done
				passphrase="${passphrase::-1}"
			elif [[ "${CHAR}" != $'\r' && "${CHAR}" != $'\n' && "${CHAR}" != "${DEL}" ]]; then
				passphrase+="${CHAR}"
				for (( c=0; c<x; c++ )); do echo -n "*" >&${__fd_user[1]}; done
				ca[${#passphrase}]=${c}
			fi
		done
		[[ -z "${POS}" ]] && echo -e "\r" >&${__fd_user[1]}
	fi
	return 0
}

do_read_passphrase()
{
	local pp="$(do_eval_pp "$1")" network="$2" fd_user="$3" mode="$4" passphrase fd_pp=0
	if ! passphrase="$(t_keyctl 1 pipe "$(t_keyctl 1 request user "${pp}")")"; then
		if [[ ${network} -eq 1 ]]; then
			exec {fd_pp}< <(key_clnt "GET" "${pp}" {__fd_up}>&1- {__fd_user}>&${fd_user}-); pid=$!
			IFS= do_initrd_cmd "($5) Getting ${pp} Passphrase from Boot Servers: " \
					read -t${bootconf[TIMEOUT]} -ru${fd_pp} passphrase && fd_pp=1 || fd_pp=0
		fi
		if [[ ${fd_pp} -eq 0 ]]; then
			exec {fd_pp}< <(query_passphrase "${pp}" "${PI}" "${OK}" "${WARN}" "${FAIL}" "${mode}" "(${MYNAME}) " \
							{__fd_up}>&1- {__fd_user[0]}<&0- {__fd_user[1]}>&${fd_user}-)
			! IFS= read -ru${fd_pp} passphrase && return 1
		fi
		[[ $4 -eq 0 ]] && do_cache_pp "${pp}" "@u" "$((2*conf[START_TIMEOUT]))" "${passphrase}"
	fi
	echo "${passphrase}"
	return 0
}

# [END OF SHARED FUNCTIONS]

# [BEGIN OF KEY SERVER & CLIENT FUNCTIONS]

# A simple keyserver for caching passphrases so that booting systems can get passphrases here.
# The server runs under a user account correspnding to the host they are for.
# All confi etc. is in that users home directory. Key life can be set as default and per passphrase in the config.
do_term_keysrv()
{
	trap 'do_log warning "unclean exit after $(do_timer ${time_start})s"; exit 1;' SIGINT SIGTERM

	do_log warning "terminating after $(do_timer ${time_start})s"
	if [[ ! -z "${pid_logwriter}" && "$(</proc/${pid_logwriter}/comm)" == "${MYNAME}" ]]; then
		do_log debug2 "stopping log writer (PID: ${pid_logwriter})"
	fi
	exec {fd_logwriter}>&- {fd_fifo}>&- 1>&- 2>&-
	rm -f ${KEYSRVDIR}/*.res

	exit 0
}

do_systemd_keysrv()
{
	local fd_fifo pid msg cmd pp passphrase _passphrase key timeout _conf="$(<${KEYSRVCONF})" res=0 r IFS=' '
	declare -A cached_pp
	trap 'do_term_keysrv' SIGINT SIGTERM SIGHUP
	systemd-notify --ready --status="${myname} Started on $(do_timer date ${time_start})"
	
	do_log debug "started on $(do_timer date ${time_start})"
	exec {fd_fifo}<>${conf[KEYSRV_FIFO]}
	while true; do 
		do_log debug "running since $(do_timer date ${time_start})"
		systemd-notify WATCHDOG=1 WATCHDOG_USEC=$(((2*conf[CLEANUP_TIMER])*1000000))
		[[ "$(<${KEYSRVCONF})" != "${_conf}" ]] && do_log error "config changed, terminating" && break

		# Read message from queue, when add or put read the passphrase. Clean up expired passphrases before handling command.
		IFS=$'\r' read -t${conf[CLEANUP_TIMER]} -ru${fd_fifo} msg passphrase
		r=$? res=0 msg=(${msg})
		for pp in ${!cached_pp[@]}; do if ! t_keyctl 0 request user "${pp}" @s; then
			do_log info "${pp} passphrase has expired"
			unset cached_pp[${pp}]
		fi done
		[[ ${r} -eq 142 ]] && continue
		[[ ${r} -ne 0 ]] && break
		pid="${msg[0]}" cmd="${msg[1],,}" pp="$(do_eval_pp ${msg[2]})" timeout="${msg[3]}"
		if [[ ! ${pid} =~ ^[0-9]+$ || ! ${cmd} =~ ^(add|rem|get|put|del|status)$ || $((${#msg[@]}-3)) -gt 2 \
								   || ! -p ${cmd}.${pid}.res ]]; then
			do_log warning "invalid command \"${msg[@]}\""
			continue
		fi
		do_log debug "new command \"${msg[@]}\""

		case ${cmd} in
		put|add)
			[[ ${timeout} -eq -1 && -n "${keylife[${pp}]}" ]] && timeout=${keylife[${pp}]}
			[[ ${timeout} -eq -1 ]] && timeout=${conf[KEYLIFE]}
			[[ "${cmd}" == "put" ]] && do_log debug "putting ${pp} key" || do_log debug "adding ${pp} key, timeout ${timeout}s"
			res=$(do_check_passphrase "${pp}" "${passphrase}" 1 1)$?
			case ${res} in
			0)
				do_log info "recevied ${pp} passphrase equal to stored passphrase"
				[[ ${cmd} == "put" ]] && res=1 && do_keysrv_send "SAME";;
			1|2)
				if [[ ${res} -eq 2 && "${cmd}" == "put" ]]; then
					do_log info "PUT of papssphrase ${pp} succeeded"
					do_keysrv_send "OK"
				elif ! do_write_keyfile "${pp}" "${passphrase}" 1; then
					do_log error "${cmd^^} error writing keyfile"
					do_keysrv_send "NOK"
				else
					do_log warning "${cmd^^} replaced stored passphrase"
					[[ "${cmd}" == "put" ]] && do_keysrv_send "OK" || res=0
				fi;;
			*)
				do_log warning "${cmd^^} ${pp} passphrase failed."
				do_keysrv_send "NOK"
			esac
			if [[ ${res} -eq 0 ]]; then
				res=$(do_cache_pp "${pp}" "@s" "${timeout}" "${passphrase}")$? 1
				if [[ ${res} -eq 2 ]]; then
					_passphrase="$(t_keyctl 1 pipe "$(t_keyctl 1 request user ${pp} @s)")"
					if [[ $? -eq 0 && "${_passphrase}" != "${passphrase}" ]]; then
						do_log warning "${pp} passphrase differs from cached passphrase, revoking"
						t_keyctl 0 revoke "${key}"
						t_keyctl 0 unlimk "${key}" @s
						res=$(do_cache_pp "${pp}" "@s" "${timeout}" "${passphrase}")$? 1
					fi
				fi
				if [[ ${res} -eq 1 ]]; then
					unset cached_pp[${pp}]
					do_keysrv_send "NOK"
				else
					cached_pp[${pp}]="$(do_timer),${timeout}"
					do_keysrv_send "$([[ ${res} -eq 0 ]] && echo OK || echo SAME)"
				fi
			fi;;
		del|rem)
			[[ "${cmd}" == "rem" ]] && do_log debug "removing ${pp} key from cache" || do_log debug "deleting ${pp} key"
			if ! key="$(t_keyctl 1 request user "${pp}" @s)"; then
				do_log info "${cmd^^} ${pp} passphrase not cached"
				[[ "${cmd}" == "rem" ]] && do_keysrv_send "SAME"
			elif ! t_keyctl 0 revoke "${key}" || ! t_keyctl 0 unlink "${key}" @s; then
				do_log warning "${cmd^^} ${pp} passphrase from cache failed"
				[[ "${cmd}" == "rem" ]] && do_keysrv_send "NOK" 
			else
				do_log info "${cmd^^} ${pp} passphrase from cache succeeded"
				unset cached_pp[${pp}]
				[[ "${cmd}" == "rem" ]] && do_keysrv_send "OK"
			fi
			[[ "${cmd}" == "del" ]] && if [[ ! -e ${conf[KEYDIR]}/${pp}.key ]]; then
				do_log warning "Key of Passphrase ${pp} does not exist"
				do_keysrv_send "SAME"
			elif t_rm ${conf[KEYDIR]}/${pp}.key; then
				do_log info "DEL of passphrase ${pp} succeeded"
				do_keysrv_send "OK"
			else
				do_log warning "DEL of passphrase ${pp} failed"
				do_keysrv_send "NOK"
			fi;;
		get)
			do_log debug "getting ${pp} key"
			if ! key="$(t_keyctl 1 request user ${pp} @s)" || ! passphrase="$(t_keyctl 1 pipe "${key}")" \
						|| ! do_check_passphrase "${pp}" "${passphrase}" 0 1; then
				if [[ -z "${key}" ]]; then
					do_log info "did not find ${pp} passphrase for ${host}"
				else
					#The requstor has probably updated the key since it was loaded, revoke it.
					do_log warning "${pp} passphrase for ${host} does not match stored key file, revoking."
					t_keyctl 0 revoke ${key}
					t_keyctl 0 unlink ${key} @s
				fi
				do_keysrv_send "NOK"
			else
				do_log info "found ${pp} passphrase for ${host}"
				do_keysrv_send "OK"
				do_keysrv_send "${passphrase}"
			fi;;
		status)
			do_keysrv_send "${BOLD}${myname} Running Since $(do_timer date ${time_start})${NOR}"
			do_keysrv_send "${BOLD}Cached Passphrases: ${!cached_pp[@]}${NOR}"
			[[ ${conf[LOGLEVEL]} -ge 1 && -n "${!cached_pp[@]}" ]] && do_keysrv_send "${PR}" && for pp in ${!cached_pp[@]}; do
				timeout=${cached_pp[${pp}]##*,}
				[[ ${timeout} -ne 0 ]] && timeout=$((timeout-$(do_timer ${cached_pp[${pp}]%%,*} |cut -d'.' -f1)))
				if [[ ${timeout} -eq 0 ]]; then
					timeout="-"
				else
					timeout="$((timeout/86400))d $((timeout/3600%24))h $((timeout/60%60))m $((timeout%60))s"
				fi
				[[ ${conf[LOGLEVEL]} -lt 3 ]] || ! passphrase="${RED}${BOLD}$(t_keyctl 1 pipe "$(t_keyctl 1 request user "${pp}" @s)")" \
											  && passphrase="${YEL}${BOLD}N/A"
				do_keysrv_send "${BOLD}${pp}${PK}\"${passphrase}${NOR}${BOLD}\"${PE}timeout: ${timeout}${NOR}"
			done
			do_keysrv_send ".";;
		esac
		rm -f ${cmd}.${pid}.res
	done

	systemd-notify STOPPING=1 --status="${myname} Read Error ($?), terminating after $(do_timer ${time_start})s"
	do_term_keysrv
}

do_keysrv_send()
{
	cat >${cmd}.${pid}.res <<<"$@" 2>/dev/null
	return 0
}

# Key client executes commands on keyservers and relays the result back to caller, which may be user on cli.
# We expect to be called with two or three parameters, depending on the command. And optionally a list of servers.
# 1. The command (GET / PUT / DEL)
# 2. The passphrase name
# 3. In case of PUT, the passphrase
# In case of GET we also need a redirection for {__fd_up} and for cli a {__fd_user} to relay the passphrase / status.
do_term_key_clnt()
{
	trap 'do_log warning "unclean exit after $(do_timer ${_time_start})s"; exit 1;' SIGINT SIGTERM
	do_log debug "terminating after $(do_timer ${_time_start})s"

	srv=""
	for ts in ${pid_cmd}; do
		if [[ "$(</proc/${ts}/comm)" == "${MYNAME}" ]]; then
			do_log debug "killed ${cmd} (PID: ${ts})"
			kill -SIGTERM ${ts} 2>/dev/null
			srv+="${ts} "
		fi
	done
	[[ -n "${srv}" ]] && wait ${srv}
	if [[ -n "${_ssh_PID}" && "$(</proc/${_ssh_PID}/comm)" == "ssh" ]]; then
		do_log debug "killed ssh (PID: ${_ssh_PID})"
		kill -SIGTERM ${_ssh_PID} 2>/dev/null
		wait ${_ssh_PID}
	fi
	if [[ -n "${_pid_logwriter}" && "$(</proc/${_pid_logwriter}/comm)" == "${MYNAME}" ]]; then
		do_log debug2 "stopping logwriter (PID: ${_pid_logwriter} FD: ${fd_logwriter})"
	fi
	exec {fd_logwriter}>&-

	exit 0
}

key_clnt()
{
	local myname="${1,,}:$([[ "${1,,}" == "update" ]] && echo ${MYNAME} || echo $2):${BASHPID}:" ret=${BASHPID} _ssh srv msg res
	local _time_start=$(do_timer) cmd="${1,,}" pp="$(do_eval_pp "$2")" timeout kto ts _pid_logwriter pid_cmd passphrase="" r
	trap 'do_term_key_clnt' SIGINT SIGTERM

	[[ "${cmd}" == "update" ]] && pp="${MYNAME}" passphrase="" srv="$2" msg="updating"
	[[ "${cmd}" == "add" ]] && kto="$3" passphrase="$4" srv="$5" msg="add ${pp} key to"
	[[ "${cmd}" == "put" ]] && passphrase="$3" srv="$4" msg="put ${pp} key to"
	[[ ! ${cmd} =~ ^(put|add|update)$ ]] && srv="$3" msg="${cmd} key from"
	[[ ${starting} -eq 0 ]] && timeout=${conf[PP_TIMEOUT]} || timeout=${conf[START_TIMEOUT]}
	[[ "${cmd}" == "get" ]] && timeout=$((timeout/(conf[NET_RETRIES]+1)))

	# If we are called with exactly one server, execute the command on that server.
	if [[ ( "${cmd}" == "add" && $# -eq 5 ) || ( "${cmd}" == "put" && $# -eq 4 ) || ( "${cmd}" == "update" && $# -eq 2 ) \
											|| ( ! "${cmd}" =~ ^(put|add|update)$ && $# -eq 3 ) ]]; then
		pid_cmd= _pid_logwriter=
		do_log debug "${msg}: ${srv}"
		coproc _ssh ( ssh -i ${CONFDIR}/${bootconf[BOOTUSERKEY]} -o UserKnownHostsFile=${CONFDIR}/${bootconf[BOOTSERVERKEYS]} \
					      ${bootconf[BOOTUSER]}@${srv} "${cmd^^}" "${pp}" "${kto}" 2>/dev/null)
		[[ ${cmd} =~ ^(put|add)$ ]] && cat >&${_ssh[1]} <<<"${passphrase}" 2>/dev/null
		if [[ ${cmd} == "update" ]]; then
			for f in ${conf[FILES]}; do
				res=0
				do_log warning "updating ${f} on ${srv}"
				cat >&${_ssh[1]} <<<"${f}"$'\r'"$(du -b ${f} |cut -f1)" 2>/dev/null
				dd obs=1 if=${f} >&${_ssh[1]} 2>/dev/null || res=1
				[[ "${res}" -ne 1 ]] && ! IFS= read -t${timeout} -ru${_ssh[0]} res 2>/dev/null && res=1
				case ${res} in
				0)
					do_log info "update ${f} on ${srv} ok"
					[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${GRN}${srv}:${f}${NOR} " >&${__fd_user};;
				1)
					do_log error "update ${f} on ${srv} failed"
					[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${RED}${srv}:${f}${NOR} " >&${__fd_user};;
				2)
					do_log warning "update ${f} on ${srv} equal"
					[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${YEL}${srv}:${f}${NOR} " >&${__fd_user};;
				esac
			done
			exit
		fi
		IFS= read -t${timeout} -ru${_ssh[0]} res 2>/dev/null
		r=$?
		if [[ ${r} -ne 0 || ( "${cmd}" != "get" && ! "${res,,}" =~ ^(ok|same)$ ) \
				 		 || ( "${cmd}" == "get" && $(do_check_passphrase "${pp}" "${res}" 0)$? -eq 1 ) ]]; then
			[[ ${r} -eq 142 ]] && ts="timeout" || ts="failed"
			[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${RED}${srv}${NOR} " >&${__fd_user}
			do_log info "${msg} ${srv} for ${bootconf[BOOTUSER]} ${ts}"
		elif [[ "${cmd,,}" != "get" && "${res,,}" == "same" ]]; then
			[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${YEL}${srv}${NOR} " >&${__fd_user}
			do_log info "${msg} ${srv} for ${bootconf[BOOTUSER]} equal"
		elif [[ ( "${cmd,,}" != "get" && "${res,,}" == "ok" ) || "${cmd,,}" == "get" ]]; then
			[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${GRN}${srv}${NOR} " >&${__fd_user}
			do_log info "${msg} ${srv} for ${bootconf[BOOTUSER]} succeeded"
			[[ "${cmd}" == "get" ]] && echo "${res}" >&${__fd_up}
		fi
		exit
	fi

	# When starting wait for network before trying to connect to servers.
	if [[ ${FOREGROUND} -eq 0 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		exec {fd_logwriter}>&-
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && exec {fd_logwriter}> >(logwriter ${cmd}-${pp}-${ret}.log) 1>&${fd_logwriter} 2>&1
		[[ ${conf[LOGLEVEL]} -ne 4 ]] && exec {fd_logwriter}> >(logwriter ${cmd}-${pp}-${ret}.log)
		_pid_logwriter=$!
	fi
	if [[ ${starting} -ne 0 && ${conf[NET_ONLINE]} -eq 1 ]]; then
		ts=$(do_timer) ret=0
		until [[ ${ret} -ge ${conf[START_TIMEOUT]} || "$(t_networkctl status | grep "Online state")" =~ (online|partial)$ ]]; do
			t_sleep ${conf[QUEUE_TIMEOUT]}
			ret=$((ret+$(do_timer ${ts} |cut -d'.' -f1)))
		done
	fi

	# For every boot server on command line start a command sub shell. If no list of servers was specified use all servers.
	# We will not retry PUT or DEL as this should work if the other side ok. Also no retry for getting the passphrase for cli user.
	[[ ${cmd} == "add" ]] && srv="${@:5}"
	[[ ${cmd} == "put" ]] && srv="${@:4}"
	[[ "${cmd}" == "update" ]] && srv="${@:2}"
	[[ ! ${cmd} =~ ^(put|add|update)$ ]] && srv="${@:3}"
	ret=0
	[[ -z "${srv}" ]] && srv="${bootconf[BOOTSERVERS]}"
	do_log debug "${msg} boot servers: ${srv}"
	while [[ ${ret} -le ${conf[NET_RETRIES]} ]]; do
		to=$(do_timer)
		for ts in ${srv}; do
			if [[ "${cmd}" == "update" ]]; then
				key_clnt "${cmd}" "${ts}" &
			elif [[ "${cmd}" == "add" ]]; then
				key_clnt "${cmd}" "${pp}" "${kto}" "${passphrase}" "${ts}" &
			elif [[ "${cmd}" == "put" ]]; then
				key_clnt "${cmd}" "${pp}" "${passphrase}" "${ts}" &
			elif [[ ! ${cmd} =~ ^(put|add|update)$ ]]; then
				key_clnt "${cmd}" "${pp}" "${ts}" &
			fi
			pid_cmd+="$! "
		done
		wait ${pid_cmd}
		[[ "${cmd}" != "get" || -n "${__fd_user}" ]] && ret=$((conf[NET_RETRIES]+1)) || ret=$((ret+1))
		[[ ${ret} -le ${conf[NET_RETRIES]} ]] && t_sleep $((timeout-$(do_timer ${to} |cut -d'.' -f1)))
	done

	do_log debug2 "finished after $(do_timer ${_time_start})s"
}

do_sanboot()
{
	local myname="${MYNAME}-boot:" passphrase fd_fifo res r=0 t f
	trap 'rm -f ${KEYSRVDIR}/${MYNAME}.${BASHPID} ${KEYSRVDIR}/${cmd}.$$.res >/dev/null 2>&1; exit' SIGINT SIGTERM

	if ! do_init_conf keyserver || ! mkfifo ${KEYSRVDIR}/${cmd}.$$.res || ! chmod 600 ${KEYSRVDIR}/${cmd}.$$.res; then
		logger -p user.error "${myname} initialization failed"
		return 1
	elif [[ ${cmd} =~ ^(put|add)$ ]] && ! IFS= read -t${conf[KEYSRV_TIMEOUT]} -ru${in} passphrase; then
		logger -p user.error "${myname} did not receive ${pp} passphrase from ssh client"
		rm -f ${KEYSRVDIR}/${cmd}.$$.res
		return 1
	elif [[ ${cmd} == "update" ]]; then
		logger -p user.warning "${myname} running update"
		while IFS=$'\r' read -t${conf[CMD_TIMEOUT]} -ru${in} f res 2>/dev/null; do
			r=0 t="$(mktemp)" || r=1
			logger -p user.warning "${myname} updating ${f} (${res})"
			if [[ "${r}" -ne 1 && -f "${f}" && ! -L "${f}" && "${res}" -gt 0 ]]; then
				dd ibs=1 of=${t} count=${res} 0<&${in} 2>/dev/null || r=1
				[[ "${r}" -eq 0 ]] && diff -q ${t} ${f} >/dev/null 2>&1 && r=2
				[[ "${r}" -eq 0 ]] && ! cp ${t} ${f} && r=1
			fi
			[[ -n "${t}" ]] && rm -f ${t} >/dev/null 2>&1
			[[ "${r}" -eq 1 ]] && logger -p user.error "${myname} ${f} failed"
			[[ "${r}" -eq 2 ]] && logger -p user.info "${myname} ${f} not changed"
			cat >&${out} <<<"${r}" 2>/dev/null
		done || logger -p user.error "${myname} update failed"
		systemctl --user stop ${MYNAME}-keyserver.service >/dev/null 2>&1
		return
	else
		exec {fd_fifo}<>${KEYSRVDIR}/${cmd}.$$.res
		cat >>${conf[KEYSRV_FIFO]} <<<"$$ ${cmd} ${pp} ${timeout}"$'\r'"${passphrase}" 2>/dev/null
	fi

	if [[ ${cmd} != "update" ]] && ! read -t${conf[KEYSRV_TIMEOUT]} -ru${fd_fifo} res; then
		logger -p user.error "${myname} no response received from keyserver"
		r=1
	elif [[ "${cmd}" == "get" ]]; then
		if [[ "${res,,}" == "nok" ]] || ! IFS= read -t${conf[KEYSRV_TIMEOUT]} -ru${fd_fifo} passphrase 2>/dev/null; then
			[[ "${res,,}" == "nok" ]] && logger -p user.info "${myname} ${pp} passphrase not cached by keyserver"
			[[ "${res,,}" != "nok" ]] && logger -p user.warning "${myname} no ${pp} passphrase received from keyserver"
			kill -SIGTERM ${PPID} 2>/dev/null
			r=1
		else
			logger -p user.info "${myname} received ${pp} passphrase from keyserver"
			cat >&${out} <<<"${passphrase}" 2>/dev/null
		fi
	elif [[ "${cmd}" == "put" ]]; then
		[[ "${res,,}" == "same" ]] && r=2 && logger -p user.info "${myname} ${pp} passphrase on keyserver equal to stored passhrase"
		[[ "${res,,}" == "nok" ]]  && r=1 && logger -p user.warning "${myname} failed to put ${pp} passphrase to keyserver"
		[[ "${res,,}" == "ok" ]]   && r=0 && logger -p user.info "${myname} put ${pp} passphrase to keyserver succeeded"
	elif [[ "${cmd}" == "del" ]]; then
		[[ "${res,,}" == "same" ]] && r=2 && logger -p user.info "${myname} ${pp} passphrase not stored on keyserver"
		[[ "${res,,}" == "nok" ]]  && r=1 && logger -p user.warning "${myname} failed to remove ${pp} passphrase from keyserver"
		[[ "${res,,}" == "ok" ]]   && r=0 && logger -p user.info "${myname} removing ${pp} passphrase from keyserver succeeded"
	elif [[ "${cmd}" == "add" ]]; then
		[[ "${res,,}" == "same" ]] && r=2 && logger -p user.info "${myname} ${pp} passphrase already cached on keyserver"
		[[ "${res,,}" == "nok" ]]  && r=1 && logger -p user.warning "${myname} failed to cache ${pp} passphrase on keyserver"
		[[ "${res,,}" == "ok" ]]   && r=0 && logger -p user.info "${myname} adding ${pp} passphrase to keyserver cache succeeded"
	elif [[ "${cmd}" == "rem" ]]; then
		[[ "${res,,}" == "same" ]] && r=2 && logger -p user.info "${myname} ${pp} passphrase not cached on keyserver"
		[[ "${res,,}" == "nok" ]] && r=1 && logger -p user.warning "${myname} failed removing ${pp} passphrase from keyserver cache"
		[[ "${res,,}" == "ok" ]]  && r=0 && logger -p user.info "${myname} removing ${pp} passphrase from keyserver cache succeeded"
	fi

	[[ "${cmd}" != "get" ]] && cat >&${out} <<<"${res}" 2>/dev/null
	rm -f ${KEYSRVDIR}/${cmd}.$$.res >/dev/null 2>&1
	return ${r}
}

do_bootsan()
{
	# Set HOME to host(user) homedir and initialize config.
	local HOME=$(getent passwd $1 |cut -d':' -f6 2>/dev/null) host="${1::-1}" timeout="$2" pp f
	[[ -s ${HOME}/.config/systemd/${MYNAME}-keyserver.conf ]] && . ${HOME}/.config/systemd/${MYNAME}-keyserver.conf
	[[ -z "${KEYSRVDIR}" ]] && KEYSRVDIR="${HOME}/${MYNAME}-keyserver"
	if [[ -z "${HOME}" || ! -d ${HOME} ]] || ! do_init_conf; then
		echo -e "${RED}${BOLD}Unable to Initialize$([[ -z "${HOME}" ]] && echo ", ${host} is not a Valid Host" \
																	   || echo " Config").${NOR}"
		return 1
	fi
	[[ ! -p ${conf[KEYSRV_FIFO]} ]] && echo -e "${BOLD}${RED}Keyserver for ${host} not Running.${NOR}" && return
	[[ -f ${KEYSRVDIR}/host.conf ]] && . ${KEYSRVDIR}/host.conf

	# Ask the passphrase for every key present. And send add command to keyserver.
	exec {__fd_user[0]}<&0 {__fd_user[1]}>&1
	for f in $(ls ${conf[KEYDIR]}/*.key 2>/dev/null || echo -e "${BOLD}${YEL}No Stored Passphrases for ${host}.${NOR}"); do
		pp=${f##*/}; pp="$(do_eval_pp "${pp%.key}")"
		do_keysrv_cmd "add" "${host}" "${pp}" "${timeout}" "${f}"
	done

	# Wake-up System.
	[[ -n "${MAC}" && -n "${INTERFACE}" ]] && sudo etherwake -i "${INTERFACE}" -b "${MAC}"
}

# [END OF KEY SERVER & CLIENT FUNCTIONS]

# [START OF UDEV PROCESSING FUNCTIONS]

do_cryptdisksd_udev()
{
	local msg="${ACTION} " command=udev dir

	# Parse the udev command line and prepare the message to be put on the queue. Udev can only be run by root.
	if [[ ${UID} -ne 0 || -z "${ACTION}" ]]; then
		logger -p daemon.error "${MYNAME} udev failed to queue \"$@\""
		exit 1
	fi

	# Enter a loop to check if any of the arguments specified is a command, error exit if so, add parameter to message if ok.
	while [[ -n "$1" ]]; do
		do_parse_opt $@
		[[ $? -eq 0 ]] && msg+="$1 " || logger -p daemon.error "${MYNAME} cannot name crypt or dev \"$1\""
		shift
	done

	# Put the message (if any) on the queue.
	[[ "${msg}" == "${ACTION} " ]] && exit 1
	echo "${msg}" >${conf[FIFO]} 
	exit 0
}

do_udev_start_network()
{
	if [[ "${bootconf[MAC],,}" == "${1,,}" && -n "${bootconf[IP]}" ]]; then
		ip addr add ${bootconf[IP]} dev $2 >/dev/null 2>&1 || exit 1
	else
		exit 1
	fi
	ip link set dev $2 up >/dev/null 2>&1 || exit 1
	echo $2 >${CONFDIR}/network
	[[ -n "${bootconf[GATEWAY]}" ]] && ip route add default via ${bootconf[GATEWAY]} dev $2 >/dev/null 2>&1
	echo "#######" >/etc/resolv.conf
	for nameserver in ${bootconf[NAMESERVERS]}; do
		echo "nameserver ${nameserver}" >> /etc/resolv.conf
	done
	[[ -n "${bootconf[DOMAIN]}" ]] && echo "search ${bootconf[DOMAIN]}" >> /etc/resolv.conf
}

# [END OF UDEV PROCESSING FUNCTIONS]

# [START OF INITRD FUNCTIONS]

do_reset()
{
	do_unmount
	do_initrd_log "RESETTING"
	do_cecho -e "\n${PI}${BOLD}${RED}$@\n${PI}Resetting!${NOR}"
	sleep 5
	echo 1 >/proc/sys/kernel/sysrq
	echo b >/proc/sysrq-trigger
}

do_initrd()
{
	trap 'do_problem "Caught SIGINT or SIGTERM"' SIGINT SIGTERM
	local myname="${conf[DISTNAME]}-boot:" version="${conf[DISTVERSION]}" network=0 bootconfinfw=0 rootdir="/.root"
	local logdev="/dev/zram0" logdir="${rootdir}/var/log" keeplog=0 pid pid_logwriter fd_logwriter libmd="/dev/md/lib" libsz=1
	local etcmd="/dev/md/etc" etcdir="${rootdir}/etc" etcsz=1 init=/lib/systemd/systemd recovery="no" starting=0 FOREGROUND=1
	set -o pipefail
	PATH=/bin:/sbin

	do_initrd_log "starting system initialization"
	do_cecho -e "${PI}${BOLD}Starting System Initialization.${NOR}"
	cat >/usr/lib/udev/rules.d/99-net.rules << 'EOF'
ACTION!="change", GOTO="net_end"
SUBSYSTEM!="net", GOTO="net_end"

IMPORT{builtin}="net_id"
ACTION=="change", RUN+="/sbin/cryptdisksd udev start_network $attr{address} $name"

LABEL="net_end"
EOF

	cat > /.bashrc << 'EOF'
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi
alias reboot="cd /; umount /mnt; umount /boot; echo b >/proc/sysrq-trigger"
EOF

	cat > /.bash_profile << 'EOF'
if [ -f /.bashrc ]; then
        . /.bashrc
fi
EOF

	touch /etc/mtab
	dmesg -n 1
	mount -n -t devtmpfs devtmpfs /dev
	mount -n -t proc     proc     /proc
	mount -n -t sysfs    sysfs    /sys
	mount -n -t tmpfs    tmpfs    /run
	mount -n -t efivarfs efivarfs /sys/firmware/efi/efivars
	[[ ! -L /dev/fd ]] && ln -s /proc/self/fd /dev/fd
	exec 1>&- 2>&- {fd}< <(haveged -F 1>&- 2>&- 0<&-) >/dev/null 2>&1
	[[ ! -d ${conf[CRYPTDISKSDDIR]} ]] && mkdir -pv ${conf[CRYPTDISKSDDIR]}
	conf[LOGFILE]=${CONFDIR}/${myname::-1}.log
	exec {fd_con}>/dev/console {fd_logwriter}>&-; exec {fd_logwriter}> >(logwriter); pid_logwriter=$!

	do_initrd_cmd "Reading Boot Config from Firmware" do_parse_fwconf && bootconfinfw=1

	/lib/systemd/systemd-udevd --daemon --resolve-names=never 2>/dev/null
	udevadm trigger --settle
	udevadm trigger --prioritized-subsystem=usb,block --settle
	mdadm --assemble --scan >/dev/null 2>&1

	if [[ ${network} -eq 0 && ${bootconfinfw} -eq 1 ]]; then
		do_initrd_cmd "Starting Network" do_start_network && network=1
	fi

	if [[ $recovery = yes ]] ; then
		do_initrd_cmd "Mounting boot filesystem" do_mount_boot
		do_cecho -e "${PI}${RED}${BOLD}Entering Recovery Mode.${NOR}"
		setsid cttyhack bash -i
	fi

	if [[ ! -f /default ]]; then
		do_initrd_cmd "Importing Storage Pool ${storagepool} " \
		  do_import_storage "${bootconf[STORAGEPOOL]}" "${bootconf[STORAGEPREFIX]}" \
							"$(do_read_passphrase "${bootconf[STORAGEPP]}" "${network}" "${fd_con}" 0 "${_MYNAME}" || do_reset)"
		[[ $? -eq 1 ]] && touch /default
	fi

	do_initrd_cmd "Creating zram Drives" do_make_zram_fs "lz4hc,${bootconf[LOGSIZE]},log" "lz4hc,${etcsz},etc" "lz4hc,${libsz},lib"

	imgtype="$(file -b ${sysimg})"
	if [[ "${imgtype,,}" =~ ^openssl ]]; then
		do_initrd_cmd "Mounting ${sysimg##*/}" do_mount_root \
					"$(do_read_passphrase "${conf[SYSTEMPP]}" "${network}" "${fd_con}" 0 "${_MYNAME}" || do_reset)"
	elif [[ "${imgtype,,}" =~ ^squashfs ]]; then
		do_initrd_cmd "Mounting ${sysimg##*/}" do_mount_root 
	else
		do_initrd_log "unsupported system image type"
		do_problem "Unsupported System Image Type"
	fi

	do_initrd_cmd "Initializing Log Ram Drive" do_init_log

	# Check for default config
	if [[ -f /default ]]; then
		do_mount_boot || do_problem "Unable to Mount Boot."
		do_initrd_cmd "$([[ -f /boot/storage ]] && echo Loading || echo Creating) Default Config" do_make_default_config
	else
		do_mount_etc
	fi

	[[ "${network}" -eq 1 ]] && do_initrd_cmd "Stopping Network" do_stop_network

	killall -SIGTERM ssh systemd-udevd haveged >/dev/null 2>&1
	kill -SIGTERM ${pid_logwriter}
	exec {fd_logwriter}>&-

	[[ ${keeplog} -eq 1 ]] && cp ${CONFDIR}/${myname::-1}.log ${logdir}/
	do_unmount

	echo 3 >/proc/sys/vm/drop_caches

	exec switch_root /.root "${init}" "$@"
}

do_initrd_log()
{
	echo "${myname}: $@" >dev/kmsg
}

do_cecho()
{
	echo "$@" >/dev/console
}

do_problem()
{
	do_initrd_log "$@"
	do_cecho -e "${PI}${RED}${BOLD}Encountered a do_problem! Dropping you to a shell.${NOR}"
	do_cecho -e "${PI}${RED}${BOLD}The error encountered (if any given):${NOR}"
	do_cecho -e "${PI}${RED}${BOLD}$@${NOR}"
	setsid cttyhack bash -i
}

do_initrd_cmd()
{
	local msg="$1" cmd="$2" result=1
	do_cecho -ne "${PI}${BOLD}${msg}${NOR}"
	shift 2
	${cmd} $@
	result=$?
	if [[ -n "${pid}" ]]; then
		kill -SIGTERM ${pid} 2>/dev/null
		wait ${pid}
		pid=
	fi
	if [[ ${result} -eq 0 ]]; then
		do_initrd_log "${cmd} ${msg} - OK"
		do_cecho -e "${OK}"
	elif [[ ${result} -eq 2 ]]; then
		do_initrd_log "${cmd} ${msg} - WARN"
		do_cecho -e "${WARN}"
	else 
		do_initrd_log "${cmd} ${msg} - FAIL"
		do_cecho -e "${FAIL}"
	fi
	return ${result}
}

do_make_zram_fs()
{
	# Create zram filesystem
	local status=0 num_fs=$# i=1 zr alg size fs
	while [[ "${i}" -le "${num_fs}" ]]; do
		zr="zram$((i-1))" alg=$(echo ${!i} |cut -d',' -s -f 1)
		size=$(echo ${!i} |cut -d',' -s -f 2) fs=$(echo ${!i} |cut -d',' -s -f 3)
		if [[ -b /dev/${zr} ]]; then
			echo "1" > /sys/block/${zr}/reset
			echo "${alg}" > /sys/block/${zr}/comp_algorithm
			echo "${size}" > /sys/block/${zr}/disksize
		else
			zramctl ${zr} -a ${alg} -s ${size} || do_problem "Cannot Create ${zr}"
		fi
		if [[ -n "${fs}" ]]; then 
			if [[ ! "${fs}" == "etc" && ! "${fs}" == "lib" ]]; then
				mkfs.ext4 -F /dev/${zr} > /dev/null 2>&1 || do_problem "Cannot Create Filesystem on ${zr}"
				e2label /dev/${zr} ${fs} > /dev/null 2>&1 || do_problem "Cannot label ${fs} on ${zr}"
			elif [[ ! -f /default ]] && ! mdadm --add /dev/md/${fs} /dev/${zr} >/dev/null 2>&1; then
				do_initrd_log "unable to add ram backing device for ${fs}"
				status=2
			fi
		fi
		i=$((i+1))
	done
	return ${status}
}

do_parse_fwconf()
{
	if [[ ! -s ${conf[FWBOOTCONF]} ]]; then
		do_cecho -ne "${RED}  Not Found! Starting with default config.${NOR}"
		touch /default
	fi
	cat ${conf[FWBOOTCONF]} |tail -c +5 |grep -ve "^\s*#" >${conf[BOOTCONF]}
	do_reload_bootconf
	[[ -z "${bootconf[STORAGEPOOL]}" ]] && bootconf[STORAGEPOOL]=storage
	[[ -z "${bootconf[STORAGEPREFIX]}" ]] && bootconf[STORAGEPREFIX]=storage
	[[ -z "${bootconf[STORAGEPP]}" ]] && bootconf[STORAGEPP]=${conf[SYSTEMPP]} \
									  || bootconf[STORAGEPP]="$(do_eval_pp ${bootconf[STORAGEPP]})"
	[[ "${bootconf[STORAGETRIM]}" == "1" || "${bootconf[STORAGETRIM],,}" == "y" \
		|| "${bootconf[STORAGETRIM],,}" == "yes" ]] && bootconf[STORAGETRIM]=1 || bootconf[STORAGETRIM]=0
	[[ -z "${bootconf[STORAGEALGO]}" ]] && bootconf[STORAGEALGO]="${conf[ALGO]}" || conf[ALGO]="${bootconf[STORAGEALGO]}"
	[[ -z "${bootconf[STORAGEKEYSZ]}" ]] && bootconf[STORAGEKEYSZ]="${conf[KEYSZ]}" || conf[KEYSZ]="${bootconf[STORAGEKEYSZ]}"
	[[ -z "${bootconf[STORAGEHASH]}" ]] && bootconf[STORAGEHASH]="${conf[HASH]}" || conf[HASH]="${bootconf[STORAGEHASH]}"
	[[ -z "${bootconf[TIMEOUT]}" ]] && bootconf[TIMEOUT]=30
	[[ -z "${bootconf[LOGSIZE]}" ]] && bootconf[LOGSIZE]=2GiB
	if [[ -s ${conf[FWDIR]}/${conf[DISTNAME]}_${bootconf[BOOTSERVERKEYS]}-${conf[FWGUID]} ]] && \
	   cat ${conf[FWDIR]}/${conf[DISTNAME]}_${bootconf[BOOTSERVERKEYS]}-${conf[FWGUID]} \
		   |tail -c +5 >${CONFDIR}/${bootconf[BOOTSERVERKEYS]} && \
	   [[ -s ${conf[FWDIR]}/${conf[DISTNAME]}_${bootconf[BOOTUSERKEY]}-${conf[FWGUID]} ]] && \
	   cat ${conf[FWDIR]}/${conf[DISTNAME]}_${bootconf[BOOTUSERKEY]}-${conf[FWGUID]} \
			|tail -c +5 >${CONFDIR}/${bootconf[BOOTUSERKEY]} && \
	   [[ -n "${bootconf[BOOTUSER]}" && -n "${bootconf[BOOTSERVERS]}" ]]; then
		chmod 400 ${CONFDIR}/${bootconf[BOOTUSERKEY]}
	else
		network=2
		return 2
	fi
	return $([[ ! -e /default ]])$?
}

do_mount_boot()
{
	[[ ! -d /boot ]] && mkdir /boot
	[[ ! -L /dev/disk/by/label/boot ]] && mdadm --assemble --scan --name=boot >/dev/null 2>&1
	mount /dev/disk/by-label/boot /boot || do_problem "Unable to Mount boot"
}

do_mount_etc()
{
	[[ ! -d ${etcdir} ]] && mkdir ${etcdir}
	mount -n ${etcmd} ${etcdir} > /dev/null 2>&1 || do_problem "Unable to Mount etc"
}

do_init_log()
{
	mkdir -p ${logdir}
	mount -n ${logdev} ${logdir} > /dev/null 2>&1 || do_problem "Unable to Mount log ram drive"
	chown rsyslog:wheel ${logdir}
	ln -s /var/storage/logarchive ${logdir}/archive
	mkdir ${logdir}/samba
	chmod 750 ${logdir}/samba
	mkdir ${logdir}/journal
	chgrp 10 ${logdir}/journal
	chmod 2755 ${logdir}/journal
	mkdir ${logdir}/sa
	chmod 750 ${logdir}/sa
	mkdir ${logdir}/clamav
	chown clamav:clamav ${logdir}/clamav
	chmod 750 ${logdir}/clamav
}

do_start_network()
{
	udevadm trigger --prioritized-subsystem=usb,net --settle
	[[ ! -f ${CONFDIR}/network ]] && return 1 || return 0
}

do_import_storage()
{
	local nr=1 i=1 status=0 storagedev storageopt dev
	if [[ ! -z "${bootconf[STORAGEDEVS]}" ]]; then
		for storagedev in ${bootconf[STORAGEDEVS]}; do
			dev="$(findfs ${storagedev} 2>/dev/null)" 
			if [[ $? -ne 0 ]] ; then
				do_initrd_log "incorrect storage device entry (${storagedev}) in bootconf"
			elif [[ ! -b ${conf[DMDIR]}/${2}${nr} ]]; then
				if [[ ${bootconf[STORAGETRIM]} -eq 1 && ! "$(t_lsblk -rD ${dev}|head -n2|tail -n1|cut -d' ' -f3-4)" =~ 0B ]]; then
					storageopt="--allow-discards"
				fi
				storageopt+=" --cipher ${conf[ALGO]} --key-size ${conf[KEYSZ]} --hash ${conf[HASH]}"
				t_cryptsetup open --type plain ${storageopt} ${dev} ${2}${nr} <<<"$3"
				if [[ "$?" -eq 0 ]]; then
					nr=$((nr+1))
				else
					do_initrd_log "cannot unlock persistent storage device ${storagedev}"
					status=2
				fi
			else
				do_initrd_log "persistent storage device ${conf[DMDIR]}/${2}${nr} already present"
				status=2
			fi
		done 
		if [[ "${nr}" -eq 1 ]]; then
			do_initrd_log "no usable storage devices in bootconf, starting with default config"
			do_cecho -ne "${YEL}No Usable Storage Devices in Bootconf, Starting with Default Config.${NOR}"
			return 1
		else
			if ! zpool import $1 -f >/dev/null 2>&1; then
				do_initrd_log "unable to import storage pool $1, starting with default config"
				do_cecho -ne "${YEL}Unable to Import Storage Pool $1, Starting with Default Config.${NOR}"
				return 1
			fi
			while [[ "${i}" -le ${bootconf[TIMEOUT]} ]]; do
				[[ -b /dev/zvol/$1/etc || -b /dev/zvol/$1/lib ]] && mdadm --assemble --scan >/dev/null 2>&1
				[[ -b ${etcmd} && -b ${libmd} ]] && break
				sleep 1
				i=$((i+1))
			done
			if [[ ! -b ${etcmd} || ! -b ${libmd} ]]; then
				do_initrd_log "etc or lib zvol not found starting with default config"
				do_cecho -ne "${YEL}No lib or etc Zvol Found. Starting with Default Config.${NOR}"
				return 1
			fi
			etcsz=$(($(blockdev --getsize64 /dev/zvol/$1/etc) + 1))
			libsz=$(($(blockdev --getsize64 /dev/zvol/$1/lib) + 1))
		fi
	else
		do_initrd_log "no persistent storage devices in bootconf. starting with default config"
		do_cecho -ne "${YEL}No Persistent Storage Devices in Bootconf. Starting with Default Config.${NOR}"
		return 1
	fi
	return ${status}
}

do_make_default_config()
{
	local passphrase="" size="$(df -k /boot/ |tail -n1 |tr -s ' ' |cut -d' ' -f4)"
	local opt="--cipher ${conf[ALGO]} --key-size ${conf[KEYSZ]} --hash ${conf[HASH]}"
	[[ ${size} -lt $((1024*1024)) ]] && do_problem "Need at Least 1GB Free Space on /boot"
	mount -t tmpfs tmpfs -o size=1G,mode=0750,nosuid,noexec,nodev ${rootdir}/root
	ln -s /etc/bashrc ${rootdir}/root/.bashrc
	mkdir ${rootdir}/root/quarantine
	[[ "${imgtype,,}" =~ ^openssl ]] && \
		passphrase="$(do_read_passphrase "${conf[SYSTEMPP]}" "${network}" "${fd_con}" 0 "${_MYNAME}" || do_reset)"
	if [[ ! -f /boot/storage ]]; then
		touch /boot/storage
		truncate -s $((size/2*1024)) /boot/storage
		t_cryptsetup create --type plain "${opt}" storage /boot/storage <<<"${passphrase}" || do_problem "Unable to Create Storage Device."
		mkfs.ext4 ${conf[DMDIR]}/storage
		mount ${conf[DMDIR]}/storage /mnt
		cp -a ${rootdir}/var/storage/* /mnt
		cp -a ${rootdir}/etc /mnt
		cp -a ${rootdir}/var/lib /mnt
		rm -rf /mnt/clamav
		ssh-keygen -A -f /mnt >/dev/null 2>&1
		${rootdir}/bin/systemd-machine-id-setup >/dev/null 2>&1
		cp /etc/machine-id /mnt/etc/
		umount /mnt
	else
		t_cryptsetup open --type plain /boot/storage storage <<<"${passphrase}" || do_problem "Unable to Open Storage Device."
	fi
	mount ${conf[DMDIR]}/storage ${rootdir}/var/storage || do_problem "Unable to Mount Storage."
	mount -t tmpfs tmpfs -o size=2G ${rootdir}/var/storage/lib/clamav
	mount -o bind ${rootdir}/var/storage/etc ${rootdir}/etc
	mount -o bind ${rootdir}/var/storage/lib ${rootdir}/var/lib
}

do_stop_network()
{
	local interface="$(</${CONFDIR}/network)"
	ip route del default via ${bootconf[GATEWAY]} >/dev/null 2>&1 || return 1
	ip addr del ${bootconf[IP]} dev ${interface} >/dev/null 2>&1 || return 1
	ip link set dev ${interface} down >/dev/null 2>&1 || return 1
	return 0
}

do_unmount()
{
	cd /
	if mountpoint -q ${logdir}; then
		umount ${logdir} || do_problem "Could not unmount ${logdir}"
	fi
	if mountpoint -q /sys/firmware/efi/efivars; then
		/bin/umount /sys/firmware/efi/efivars || do_problem "Could not unmount efivarfs"
	fi
	if [[ ! -e /default ]] && mountpoint -q /boot; then
		/bin/umount /boot || do_problem "Could not unmount /boot"
	fi
	if mountpoint -q /mnt; then
		/bin/umount /mnt || do_problem "Could not unmount /mnt"
	fi
}

# [END OF INITRD FUNCTIONS]

# [START OF INTERACTIVE CONTROL FUNCTIONS]

do_echo_use()
{
	if [[ -z "${conf[RUNDIR]}" ]]; then
		do_init_conf || echo -e "${RED}${MYNAME}, Error Loading Configuration from ${CONFDIR}${NOR}"
	fi
	echo -e "${GREY}${BOLD}${MYNAME} (Encrypted Block Device Manager)${NOR}\n"
	case $1 in
	status)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tDisplays Status of Encrypted Block Devices"
		echo -e "\t\t\t\tCommand Has no Options or Arguments\n";;
	stop)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tStops the Encrypted Device Manager"
		echo -e "\t\t\t\tCommand Has no Options or Arguments\n";;
	reload)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tReloads the Configuration of the Encrypted Device Manager"
		echo -e "\t\t\t\tCommand Has no Options or Arguments\n";;
	add)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tAdd an Encrypted Block Device to the Manager\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hct ] { crypt | device } || { -p passphrase crypt device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-i${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
		echo -e "\t${BOLD}-p {passphrase}${NOR}\tUse {passphrase} for Crypt"
		echo -e "\t${BOLD}-t${NOR}\t\tEnable TRIM for Crypt\n\n"
		echo -e "The $1 Command Can Be Used it Two Ways.\nThe First ( ${BOLD}[ -i ] { crypt | device }${NOR} )" \
				"Will Add a Crypt or Device Which is Already on the Crypttab"
		echo -e "The Second ( ${BOLD}[ -i ] { -p passphrase crypt device }${NOR} ) Will Add a crypt (and Corresponding Backing" \
				"Device) to the Crypttab\nThe Option '${BOLD}-p passphrase${NOR}' Must Be Specified in the Second Case\n"
		echo -e "The Options and Arguments Can Be Specified in any Order"
		echo -e "${BOLD}${UL}${MYNAME} $1 -p passphrase crypt device${NOR}\tand\t${BOLD}${UL}${MYNAME} $1 crypt -i\n${MYNAME} $1" \
				"crypt -i device -p passphrase${NOR}\tand\t${BOLD}${UL}${MYNAME} $1 -t device -p passphrase crypt -i${NOR}"
		echo -e "Are All Valid $1 Command Specifications\n"			
		echo -e "The ${MYNAME} Will Look for Block Devices in \"${BOLD}${conf[BLOCKDEVSDIRS]}${NOR}\"\n";;
	del)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tRemove an Encrypted Block Device from the Manager\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -htc ] { crypt | device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-i${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
		echo -e "\t${BOLD}-t${NOR}\t\tRemove the crypt (and Corresponding Backing Device) from the Crypttab\n\n"
		echo -e "The Options and Arguments Can Be Specified in any Order\n";;
	putkey)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tPut Key File to Boot Servers\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h -c -s (-a -l) -f -k HOST ] passphrase${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-i${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
		echo -e "\t${BOLD}-k${NOR}\t\tPut key only to local keyserver for HOST"
		echo -e "\t${BOLD}-c${NOR}\t\tPut key only to cache"
		echo -e "\t${BOLD}-f${NOR}\t\tPut key only to firmware"
		echo -e "\t${BOLD}-s${NOR}\t\tPut key only to servers"
		echo -e "\t${BOLD}-u${NOR}\t\tUpdate boot servers"
		echo -e "\t${BOLD}-a${NOR}\t\tPut key to servers cache"
		echo -e "\t${BOLD}-l${NOR}\t\tUse local configured timeout values instead of keyserver values\n"
		echo -e "The option -i is a confirmation flag, when no other options are specified\nit disables confirmation," \
				"enables confirmation otherwise"
		echo -e "The options -s -f -c can be combined to put key to these places only\With -c an optional timeout can be" \
				"specified, if not configured values are used"
		echo -e "With -s a server can be specified and this may occur more than once\nIt may only occur once without server" \
				"to remove from all servers"
		echo -e "Multiple servers can be specified with , as separator"
		echo -e "When -s is used, -a will also add passphrase to boot servers cache\nOptionally a timeout for the passphrase" \
				"can be specified"	
		echo -e "When -a is used without a timeout value, by default the keyserver timeout values are used\nWith -l" \
				"the locally configured timeout values will be used"
		echo -e "${BOLD}${UL}(\"-s\" and \"-s server1 -s server2,server3\" are valid but \"-s -s server1\" or" \
				"\"-s server1 -s\" are not.)${NOR}"
		echo -e "${BOLD}${MYNAME} putkey { passphrase }${NOR}\t\t- without any option puts key to everywhere" \
				"asking for confirmation each step"
		echo -e "${BOLD}${MYNAME} putkey -i { passphrase }${NOR}\t\t- puts key to everywhere not asking for confirmation"
		echo -e "${BOLD}${MYNAME} putkey -i -c -f { passphrase }${NOR}\t- puts key to specified locations asking for confirmation"
		echo -e "${BOLD}${MYNAME} putkey -c -f { passphrase }${NOR}\t- puts key to specified locations not asking for confirmation";;
	rmkey)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tRemove Key File from Firmware and/or Boot Servers\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h -c -s (-a) -f -k ] passphrase${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-i${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
		echo -e "\t${BOLD}-k${NOR}\t\tRemove key only from local keyserver for HOST"
		echo -e "\t${BOLD}-c${NOR}\t\tRemove key only from cache"
		echo -e "\t${BOLD}-f${NOR}\t\tRemove key only from firmware"
		echo -e "\t${BOLD}-s${NOR}\t\tRemove key only from servers"
		echo -e "\t${BOLD}-a${NOR}\t\tRemove key from servers cache\n"
		echo -e "The option -i is a confirmation flag, when no other options are specified\nit disables confirmation," \
				"enables confirmation otherwise"
		echo -e "The options -s -f -c can be combined to remove key from these places only"
		echo -e "With -s a server can be specified and this may occur more than once\nIt may only occur once" \
				"without server to remove from all servers"
		echo -e "Multiple servers can be specified with , as separator"
		echo -e "When -s is used, -a can be used to also remove passphrase from boot servers cache"
		echo -e "${BOLD}${UL}(\"-s\" and \"-s server1 -s server2,server3\" are valid but \"-s -s server1\" or" \
				"\"-s server1 -s\" are not.)${NOR}"
		echo -e "${BOLD}${MYNAME} rmkey { passphrase }${NOR}\t\t- without any option removes key from everywhere asking for" \
				"confirmation each step"
		echo -e "${BOLD}${MYNAME} rmkey -i { passphrase }${NOR}\t\t- removes key from everywhere not asking for confirmation"
		echo -e "${BOLD}${MYNAME} rmkey -i -c -f { passphrase }${NOR}\t- removes key from specified locations" \
				"asking for confirmation"
		echo -e "${BOLD}${MYNAME} rmkey -c -f { passphrase }${NOR}\t- removes key from specified locations" \
				"not asking for confirmation";;
	smart)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tShow S.M.A.R.T. Information for Backing Device\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hax ] {crypt | device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-a|-x${NOR}\t\tShow all S.M.A.R.T. information (Only Atrributes Otherwise)"
		echo -e "\t${BOLD}-t${NOR}\t\tRun S.M.A.R.T. Long Self Test on Device\n";;
	erase)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tSecure Erase Device\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h ] {crypt | device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text";;
	keyserver)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\t${MYNAME} Keyserver\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h | -f | status HOST ]\n\r\tKeyserver requires at least one option.${NOR}\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-f${NOR}\t\tRun in Foreground (Debug) Mode. Can not be Started by root."
		echo -e "\t${BOLD}status HOST${NOR}\tDisplay Status of Keyserver for HOST";;
	bootsan)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tAdd Keys to Keyserver and Start Host\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h | -t timeout } HOST${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e " \t${BOLD}-t${NOR}\t\tSpecify Timeout Overriding Config\n";;
	*)
		echo -e " Usage:\n\t${BOLD}${MYNAME} { [ -hdf ] ${UL}COMMAND ...${NOR} }\n"
		echo -e "\tEncrypted Block Devices Manager, Command Line Requires at Least one Option or Command"
		echo -e "\tMultiple Commands May Be Specified in Order, Commands Can Have Multiple Options and Arguments"
		echo -e "\tAll Commands Options and Arguments Are cAsE iNSensItiVe, except for ${UL}Device Names${NOR}\n"
		echo -e "\tUse ${UL}${BOLD}${MYNAME} command -h${NOR} To Display Help for That Command${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-d${NOR}\t\tSet Configuration Directory (${BOLD}${UL}Default: /etc/${MYNAME}${NOR})"
		echo -e "\t${BOLD}-f${NOR}\t\tRun in Foreground (Debug) Mode. Can Only be Started by root"
		echo -e "\n\n Commands:\n\t${BOLD}status${NOR}\t\tDisplays Status of Encrypted Block Device Manager"
		echo -e "\t${BOLD}smart${NOR}\t\tDisplay S.M.A.R.T. Status of Encrypted Block Device"
		echo -e "\t${BOLD}erase${NOR}\t\tSecure Erase Encrypted Block Device"
		echo -e "\t${BOLD}stop${NOR}\t\tStop the Encrypted Device Manager"
		echo -e "\t${BOLD}reload${NOR}\t\tReload the Configuration of the Encrypted Device Manager"
		echo -e "\t${BOLD}add${NOR}\t\tAdd Encrypted Block Device to Manager"
		echo -e "\t${BOLD}del${NOR}\t\tDelete Encrypted Block Device from Manager"
		echo -e "\t${BOLD}putkey${NOR}\t\tPut Keyfile (Passphrase) to Boot Servers"
		echo -e "\t${BOLD}rmkey${NOR}\t\tRemove Keyfile (Passphrase) from Firmware"
		echo -e "\t${BOLD}keyserver${NOR}\tKeyserver Start or Status"
		echo -e "\t${BOLD}bootsan${NOR}\t\tAdd Keys to Keyserver and Start Host\n";;
	esac
	exit 127
}

do_parse_opt()
{
	# Parse command line options (-h -d -f). Function is run from main cli to parse as first options given.
	# Function can also run from the parse cmds function, it that case only -d option can be valid.
	local opt; OPTIND=1; getopts :fFd:D:hHiIlLcCaAxXk:K:sSp:P:tTuU opt
	opt="${opt,,}"
	case ${opt} in
	h|:) # if -h is specified as a command line option echo usage for the command running if run from parse cmds.
		do_echo_use "${command}";;
	a) # Option for smart -x or add to bootserver cache for putkey/rmkey
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(smart|putkey|rmkey)$ ]] && do_echo_use "${command}"
		if [[ "${command,,}" == "smart" ]]; then
			smartall=1
		else
			[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
			[[ ${_cache} == "1" ]] && _cache=0
			[[ -n "${add}" ]] && do_echo_use "${command}"
			add=-1 _add=1
		fi
		return 1;;
	k) # Option to put/del key from/to local keyserver..
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(putkey|rmkey)$ || -n "${ks}" || -z "${OPTARG}" ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		ks="${OPTARG}"
		return $((OPTIND-1));;
	l) # option for using local timeout values instead of keyserver values when adding keys to keyserver cache.
		[[ ${cmd} -eq 0 || ! "${command,,}" == "putkey" || ${loc} -ne 0 ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		loc=1
		return 1;;
	u) # option for updating remote keyserver.
		[[ ${cmd} -eq 0 || ! "${command,,}" == "putkey" || ${upd} -ne 0 ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		upd=1
		return 1;;
	x) # Option for smart -x
		[[ ${cmd} -eq 0 || ! "${command,,}" == "smart" ]] && do_echo_use "${command}"
		smartall=1
		return 1;;
	i) # Option to ask for confirmation for non critical actions.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(add|del|putkey|rmkey)$ ]] && do_echo_use "${command}"
		[[ ${confirm} -eq 1 ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		confirm=1
		return 1;;
	c) # Option to add/remove key from cache.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(putkey|rmkey)$ || ${key} -eq 1 ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		[[ -n "${cache}" ]] && do_echo_use "${command}"
		cache=-1 _cache=1
		return 1;;
	p) # Option to specify a passphrase name for the new crypt to be added to the crypttab.
		[[ ${cmd} -eq 0 || ! "${command,,}" == "add" || ${srv} == "1" || ${_srv} -eq 1 ]] && do_echo_use "${command}"
		crypttab=1
		pp="${OPTARG}"
		return $((OPTIND-1));;
	s) # Option to remove key from boot servers. We keep _srv to track how option is used
	   # 1 for first time option is encountered, 2 for consecutive. May only contain server names when it occurs more than once.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(putkey|rmkey)$ || ${srv} == "1" || ${_srv} -eq 1 ]] && do_echo_use "${command}"
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		[[ -z "${srv}" ]] && _srv=1 srv=1 || _srv=2
		return 1;;
	t) # Option trim enable foor add, remove crypt from crypttap for del command. Or Run smart self test.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(add|del|smart|bootsan)$ ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		if [[ "${command}" == "bootsan" ]]; then
			[[ -n "${timeout}" ]] && do_echo_use "${command}"
			timeout=-1
		elif [[ "${command}" == "add" ]]; then
			[[ ${trim} -eq 1 ]] && do_echo_use "${command}"
			trim=1
		elif [[ "${command}" == "del" ]]; then
			[[  ${crypttab} -eq 1 ]] && do_echo_use "${command}"
			crypttab=1
		elif [[ "${command}" == "smart" ]]; then
			[[  ${smarttest} -eq 1 ]] && do_echo_use "${command}"
			smarttest=1
		fi
		return 1;;
	d) # Set configuration directory. If no dir specified echo usage. Option is only valid for global, not for command.
		[[ ! -d ${OPTARG} ]] && echo "Configuration Directory ${OPTARG} Does not Exist"
		[[ ${cmd} -eq 1 || ! -d ${OPTARG} || ${_conf} -ne 0 ]] && do_echo_use "${command}"
		_conf=1
		CONFDIR=${OPTARG}
		# Shift the parameters and check if more arguments specified, continue with processing options if so.
		[[ $# -ge ${OPTIND} ]] && return $((OPTIND-1))
		shift $((OPTIND-1));;
	f) # Flag to run in foreground mode. Option to remove key from firmware.
		if [[ ( ${cmd} -eq 1 && ( ! "${command,,}" =~ ^(putkey|rmkey)$ || ${fw} -eq 1 ) ) || ${FOREGROUND} -eq 1 ]]; then
			do_echo_use "${command}"
		elif [[ "${command}" =~ ^(putkey|rmkey)$ ]]; then
			[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
			[[ ${_add} == "1" ]] && _add=0
			[[ ${_cache} == "1" ]] && _cache=0
			fw=1
			return 1
		fi
		FOREGROUND=1
		# If there are more options continue parsing. -f can only be followed by -d.
		shift
		[[ ! -z "$1" ]] && return 1;;
	?) # If run from parse cmds function, we need to check if the option specified matches a known command.
	   # If that is the case we have reached the end of the current command and can start processing the next.
		if [[ ${cmd} -eq 1 && ! -z "$1" ]] && ! do_parse_cmd check $1; then
			next_cmd=1
		elif [[ ${cmd} -eq 1 && ! -z "$1" ]]; then
			# We may get here if put/rmkey command contains -s server options. Check here if it was specified without server before.
			# If this is the last word in the command return 0 because we are done and it is the keynamen, not a server.
			[[ (${_srv} -eq 2 && ${srv} == 1) || (${timeout} == "-1"  && ! ${!OPTIND} =~ ^[0-9]+$) ]] && do_echo_use "${command}"
			if [[ ${timeout} == "-1" ]]; then
				timeout=$((${!OPTIND}*60))
				return 1
			fi
			# -s -c and -a have optional values, so check for next command first.
			if [[ -z "$2" && ! ( ${_cache} == "1" && ${cache} -eq -1 ) && ! ( ${_add} == "1" && ${add} -eq -1 ) ]]; then
				return 0
			elif ! do_parse_cmd check $2; then
				return 0
			elif [[ ${_srv} -ge 1 ]]; then
				[[ ${srv} == "1" ]] && srv=""
				srv+="${!OPTIND}," _srv=0
				return 1
			elif [[ ${_cache} == "1" || "${_add}" == "1" ]]; then
				( [[ -z "$2" ]] || ! do_parse_cmd check $2 ) && [[ $(wc -w <<<"${msg}") -eq 1 ]] && return 0
				[[ ! ${!OPTIND} =~ ^[0-9]+$ ]] && do_echo_use "${command}"
				[[ "${_add}" == "1" ]] && add=$((${!OPTIND}*60)) _add=0 || cache=$((${!OPTIND}*60)) _cache=0
				return 1
			fi
		elif [[ ${cmd} -eq 1 ]]; then
			# If there are no more arguments set to process next command, which will be none.
			next_cmd=1
		fi;;
	esac

	# Check rmkey server option for validity. If -s server was specified before and now only -s this is an error.
	[[ ${_srv} -eq 2 ]] && do_echo_use "${command}"
	[[ ${_srv} -eq 1 ]] && _srv=0

	# If foreground mode was requested execute. Echo command usage if specified in wrong place.
	if [[ ${FOREGROUND} -eq 1 ]]; then
		# If -f is not first option specified, it must be last (after -d) and no more options can be present.
		[[ ${nr} -gt 1 && ! -z "$1" ]] && do_echo_use "${command}"
		# Start in debug/foreground mode.
		if [[ ${UID} -ne 0 && $# -le 1 ]]; then
			echo "${MYNAME} foreground can only be started as root"
			exit 1
		fi
		do_systemd_daemon_start
		exit $?
	fi

	# Return 1 if next command is found, 0 otherwise.
	[[ ${next_cmd} -eq 1 ]] && return 1
	return 0
}

do_parse_cmd()
{
	# Parse the commands specified on the command line, one by one. If called with check, then return 1 on match.
	# This is to let the parse opt function know a match for a new command has been found.
	local command="${1,,}" check msg="$1 " s timeout=""
	if [[ "${command}" == "check" ]]; then 
		shift
		command="${1,,}" check=1;
	fi
	case ${command} in
	udev)
		[[ ${check} -eq 1 ]] && return 1
		do_cmd_parseopt $@
		shift
		do_init_conf daemon || return 1
		if [[ "$1" == "start_network" ]]; then
			do_reload_bootconf
			shift
			do_udev_start_network $@
		else
			do_cryptdisksd_udev $@
		fi
		return $#;;
	reload)
		[[ ${check} -eq 1 ]] && return 1
		do_cmd_parseopt $@
		do_init_conf daemon || return 1
		kill -SIGHUP $(<${conf[PIDFILE]})
		return 1;;
	status|shell|add|del|putkey|rmkey|smart|erase|stop|mountsysimg)
		[[ ${check} -eq 1 ]] && return 1
		do_cryptdisksd_cmd $@
		return $?;;
	bootsan)
		[[ ${check} -eq 1 ]] && return 1
		do_cmd_parseopt $@
		s=$?
		[[ $(wc -w <<<"${msg}") -ne 2 || "${timeout}" == "-1" ]] && do_echo_use "${command}"
		[[ -z "${timeout}" ]] && timeout=-1
		do_bootsan "${msg#* }" "${timeout}"
		return ${s};;
	*)
		[[ ${check} -ne 1 ]] && do_echo_use
		return 0;;
	esac
	return 0
}

do_cmd_parseopt()
{
	# If there are more arguments to process, check for command options or or for a new command to be processed.
	local next_cmd=0 res s=0 _srv=0
	shift
	while [[ ${next_cmd} -eq 0 ]]; do
		do_parse_opt $@
		res=$? 
		if [[ ${res} -eq 0 ]]; then
			msg+="$1 "
			shift
			s=$((s+1))
		else
			shift ${res}
			s=$((s+res))
		fi
	done
	return ${s}
}

do_term_cryptdisksd_cmd()
{
	trap 'echo "${RED}${MYNAME} unclean finish${NOR}"; exit 1;' SIGINT SIGTERM

	# Kill socat coproc if still active and remove the socket if still present. Restore stdin to the tty.
	if [[ ! -z "${pid_socat}" && "$(</proc/${pid_socat}/comm)" == "socat" ]]; then
		kill -SIGTERM ${pid_socat} 2>/dev/null
		[[ ${conf[LOGLEVEL]} -gt 2 ]] && echo -ne "\n\rKilled ${pid_socat}"
	fi
	if [[ -n "${sock}" && -e ${conf[CRYPTDISKSDDIR]}/${sock} ]]; then
		rm -f ${conf[CRYPTDISKSDDIR]}/${sock} && echo -e "\rRemoved ${conf[CRYPTDISKSDDIR]}/${sock}\r\n"
	fi
	[[ -e ${KEYSRVDIR}/${c}.$$.res ]] && rm -f ${KEYSRVDIR}/${c}.$$.res
	[[ -n "${stdin}" ]] && exec 0<&${stdin}-
	stty sane

	echo -e "${NOR}\r"
	exit 1
}

do_cryptdisksd_cmd()
{
	local crypttab=0 confirm=0 smartall=0 smarttest=0 cache srv add fw=0 loc=0 upd=0 trim=0 ks="" to
	local stty_opt="-echo" msg="$1 " pid_socat stdin pp fd_logwriter fd_journal s sock
	trap 'do_term_cryptdisksd_cmd' SIGINT SIGTERM
	exec {fd_logwriter}>/dev/null {fd_journal}>/dev/null

	# Parse the options to the command and store the nr. of parameters to shift for next command n s.
	# Check provided parameters and innitialize config.
	do_cmd_parseopt $@
	s=$?
	[[ -n "${ks}" ]] && HOME=$(getent passwd "${ks}" |cut -d':' -f6 2>/dev/null)
	[[ -z "${srv}" ]] && srv=0
	[[ -z "${cache}" ]] && cache=-2
	[[ -z "${add}" ]] && add=-3
	[[ ${add} -eq -1 && ${loc} -eq 1 ]] && add=-2
	if [[ "${command,,}" == "rmkey" && (	 $(wc -w <<<"${msg}") -ne 2 \
									  || ( ${add} == "-1" && "${srv}" == "0" && -z "${ks}" ) \
									  || ${cache} -ge 0 ) ]]; then
		do_echo_use "${command}"
	elif [[ "${command,,}" == "putkey" && ( 		( $(wc -w <<<"${msg}") -ne 2 && ${upd} -eq 0 ) \
										||  ( $(wc -w <<<"${msg}") -eq 1 && ( ${upd} -eq 0 || ${srv} == "0" || ${add} -ne -3 \
																						   || ${cache} -ne -2 || ${fw} -ne 0 ) \
																		 && ! ( ${srv} == "0" && ${add} -eq -3 && ${fw} -eq 0 \
																							  && ${cache} -eq -2 ) ) \
										|| ( ${loc} -eq 1 && ( ${add} -eq -3 || ${add} -ge 0 ) )
										|| ( ${add} -ne -3 && "${srv}" == "0" && -z "${ks}" ) ) ]]; then
		do_echo_use "${command}"
	elif [[ -n "${ks}" && -z "${HOME}" ]] || ! do_init_conf; then
		echo -e "${BOLD}${RED}Unable to Initialize$([[ -n "${ks}" && -z "${HOME}" ]] && echo ", ${host} is not a Valid Host" \
																					 || echo " Config").${NOR}"
		return ${s}
	fi

	# Execute local keyserver commands firsti and eturn if nothing else to do.
	[[ -n "${ks}" ]] && pp="$(do_eval_pp "$(cut -d' ' -f2 <<<"${msg}")")"
	if [[ -n "${ks}" && "${command,,}" == "rmkey" ]]; then
		do_keysrv_cmd "$([[ "${cache}" == "-1" ]] && echo rem || echo del)" "${ks}" "${pp}"
	elif [[ -n "${ks}" ]]; then
		do_keysrv_cmd "$([[ "${add}" != "-3" ]] && echo add || echo put)" "${ks}" "${pp}" "${add}"
	fi
	[[ -n "${ks}" && "${srv}" == "0" && ${fw} -eq 0 && ${cache} -lt 0 ]] && return ${s}
	
	# Start socat in background and attach stdin, listen on a socket in RUNDIR. 
	# The daemon will spawn a worker which will connect and start interactive session.
	if [[ ! -p ${conf[FIFO]} ]]; then
		echo "${MYNAME} not Running"
		return ${s}
	fi
	exec {stdin}<&0
	[[ "${command,,}" =~ ^(stop|mountsysimg)$ ]] && to="-t${conf[START_TIMEOUT]}" || to="-t${conf[QUEUE_TIMEOUT]}"
	sock=${conf[CRYPTDISKSDDIR]}/${MYNAME}-${BASHPID}.sock
	socat ${to} - UNIX-LISTEN:${sock},unlink-early,unlink-close,group=${conf[CRYPTDISKSD_GROUP]},mode=600 0<&${stdin}- 2>/dev/null &
	pid_socat=$!

	case ${command,,} in
	add)
		if [[ ( ${crypttab} -eq 1 && $(wc -w <<<"${msg}") -ne 3 ) || ( ${crypttab} -eq 0 && $(wc -w <<<"${msg}") -ne 2 ) ]]; then
			do_echo_use "${command}"
		fi
		msg+="$(do_eval_pp "${pp}") ${trim} ${confirm} ${crypttab}";;
	del)
		[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		msg+="${confirm} ${crypttab}";;
	status|shell|stop|mountsysimg)
		[[ $(wc -w <<<"${msg}") -ne 1 ]] && do_echo_use "${command}";;
	smart)
		[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		msg+="${smartall} ${smarttest}";;
	rmkey|putkey)
		msg+="$([[ $(wc -w <<<"${msg}") -eq 1 ]] && echo ":: ")${confirm} ${add} ${cache} ${fw} ${upd} ${srv}";;
	*)
		[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		msg+="${confirm}";;
	esac

	# Notify the daemon to connect to the socket and wait until it's finished. Then restore stdin and exit.
	[[ "${command,,}" == "smart" ]] && stty_opt+=" isig"
	[[ "${command,,}" == "shell" ]] && stty_opt+=" raw -isig"
	[[ ! ${command,,} =~ ^(smart|shell)$ ]] && stty_opt+=" raw isig"
	stty ${stty_opt}
	[[ ${conf[LOGLEVEL]} -gt 2 && "${command,,}" != "mountsysimg" ]] && echo -e "\rRequesting \"$@\" from ${MYNAME} - ${conf[FIFO]}\r"
	echo "control ${BASHPID},${pid_socat} ${msg}" >${conf[FIFO]}
	[[ "${command,,}" != "mountsysimg" ]] && echo -ne "\r"
	wait ${pid_socat}
	[[ "${command,,}" != "mountsysimg" ]] && echo -ne "\r"

	# Restore stdin, remove socket and exit.
	stty sane
	[[ -e ${sock} ]] && rm -f ${sock}

	[[ ${conf[LOGLEVEL]} -gt 3 && "${command,,}" != "mountsysimg" ]] && echo -e "\rDone Requesting \"$@\" from ${MYNAME}"

	return ${s}
}

do_keysrv_cmd()
{
	local cmd="${1,,}" host="$2" pp="$([[ ${1,,} != "status" ]] && do_eval_pp "$3")" timeout="$4" key="$5" res=1
	local fd_pp fd_fifo fd_logwriter fd_journal passphrase
	[[ ! -p ${conf[KEYSRV_FIFO]} ]] && echo -e "${BOLD}${RED}Keyserver for ${host} not Running.${NOR}" && return
	exec {fd_logwriter}>/dev/null {fd_journal}>/dev/null {fd_out}>&1

	## For add or put we need a passphrase first.
	[[ ${cmd} =~ ^(put|add)$ ]] && until [[ ${res} -eq 0 ]]; do
		passphrase="$(do_read_passphrase "${pp}" 0 ${fd_out} "$(($([[ -n "${key}" ]])$?+1))" "${MYNAME}")" && res=0 || echo
		echo -ne "${PI}"
	done

	# create fifo for anser and send requet.
	if ! mkfifo ${KEYSRVDIR}/${cmd}.$$.res >/dev/null 2>&1 || ! chgrp ${conf[KEYSRV_GROUP]} ${KEYSRVDIR}/${cmd}.$$.res \
														 || ! chmod 620 ${KEYSRVDIR}/${cmd}.$$.res; then
		echo -e "${BOLD}${RED}Unable to Create FIFO.${NOR}"
		return
	fi

	# Get result.
	exec {fd_fifo}<>${KEYSRVDIR}/${cmd}.$$.res
	echo "$$ ${cmd} ${pp} ${timeout}"$'\r'"${passphrase}" >${conf[KEYSRV_FIFO]}
	until ! read -t${conf[KEYSRV_TIMEOUT]} -ru${fd_fifo} res || [[ ${res} == "." ]]; do
		if [[ "${cmd}" == "status" ]]; then
			echo -e "${res}"
		elif [[ "${cmd}" == "put" ]]; then
			[[ "${res,,}" == "same" ]] && echo -e "${BOLD}${YEL}${pp} Passphrase Equal to Stored Passphrase on Keyserver.${NOR}"
			[[ "${res,,}" == "nok" ]]  && echo -e "${BOLD}${RED}Failed to Put ${pp} Passphrase to Keyserver.${NOR}"
			[[ "${res,,}" == "ok" ]]   && echo -e "${BOLD}${GRN}Put ${pp} Passphrase to Keyserver Succeeded.${NOR}"
		elif [[ "${cmd}" == "del" ]]; then
			[[ "${res,,}" == "same" ]] && echo -e "${BOLD}${YEL}${pp} Passphrase not Stored on Keyserver.${NOR}"
			[[ "${res,,}" == "nok" ]]  && echo -e "${BOLD}${RED}Failed to Del ${pp} Passphrase from Keyserver.${NOR}"
			[[ "${res,,}" == "ok" ]]   && echo -e "${BOLD}${GRN}Del ${pp} Passphrase from Keyserver Succeeded.${NOR}"
		elif [[ "${cmd}" == "add" ]]; then
			[[ "${res,,}" == "same" ]] && echo -e "${BOLD}${YEL}${pp} Passphrase Already Cached on Keyserver.${NOR}"
			[[ "${res,,}" == "nok" ]]  && echo -e "${BOLD}${RED}Failed to Cache ${pp} Passphrase on Keyserver.${NOR}"
			[[ "${res,,}" == "ok" ]]   && echo -e "${BOLD}${GRN}Cache ${pp} Passphrase on Keyserver Succeeded.${NOR}"
		elif [[ "${cmd}" == "rem" ]]; then
			[[ "${res,,}" == "same" ]] && echo -e "${BOLD}${YEL}${pp} Passphrase not Cached on Keyserver.${NOR}"
			[[ "${res,,}" == "nok" ]]  && echo -e "${BOLD}${RED}Failed to Remove ${pp} Passphrase from Keyserver Cache.${NOR}"
			[[ "${res,,}" == "ok" ]]   && echo -e "${BOLD}${GRN}Remove ${pp} Passphrase from Keyserver Cache Succeeded.${NOR}"
		fi
		[[ "${cmd}" != "status" ]] && break
	done
	[[ -z "${res}" ]] && echo -e "${BOLD}${RED}Keyserver for ${host} timeout!${NOR}"
	rm -f ${KEYSRVDIR}/${cmd}.$$.res
}

# [END OF INTERACTIVE CONTROL FUNCTIONS]

# [BEGIN OF EXECUTION FUNCTIONS]

do_systemd_daemon_start()
{
	# Check if we are started from systemd (PID 1).
	[[ ( ! "${UID}" -eq 0 || ! ${PPID} -eq 1 ) && ${FOREGROUND} -eq 0 ]] && do_echo_use
	local myname="daemon:${BASHPID}:" hostname="$(hostname)" pid_daemon=${BASHPID} time_start=$(do_timer) param
	local starting=-1 start_status=0 systemdconf="" crypttab="" pid_logwriter fd_logwriter fd_journal keeplog
	declare -gA conf keyserverconf keylife
	set -mo pipefail
	# 1 (stdout) 2 (stderr) and {fd_logwriter} (for subshells) point to a log writer.
	# {fd_journal} systemd journal messages which can be viewed with systemctl status and journalctl -xe
	# Running in foreground mode evrything goes to stdout of the user's terminal. And we wish him or her good luck with that.
	[[ ${FOREGROUND} -ne 1 ]] && exec 0>&- 0</dev/null {fd_journal}>&1- 1>/dev/null 2>&1
	[[ ${FOREGROUND} -eq 1 ]] && echo -n "Session Key: " && exec {fd_logwriter}>&1 {fd_journal}>&${fd_logwriter} 2>&1

	# Check config fie and dir.
	[[ -z "${CONFDIR}" && -s /etc/systemd/${MYNAME}.conf ]] && . /etc/systemd/${MYNAME}.conf
	[[ -z "${CONFDIR}" ]] && CONFDIR="/etc/${MYNAME}"
	[[ -z "${CONF}" ]] && CONF="${CONFDIR}/${MYNAME}.conf"
	[[ -z "${ID}" ]] && DISTNAME="unknown-linux" || DISTNAME="${ID}"
	[[ -z "${VERSION_ID}" ]] && DISTVERSION="0.00.000" || DISTVERSION="${VERSION_ID}"
	[[ -z "${FWDIR}" ]] && FWDIR="/sys/firmware/efi/efivars"
	[[ -z "${FWGUID}" ]] && FWGUID="ca25478a-acb8-44ac-8c55-d5d45dfe25c5"
	[[ -z "${CRYPTTAB}" ]] && CRYPTTAB="crypttab"
	if [[ "$1" == "daemon" && ! -d "${CONFDIR}" ]]; then
		do_log warning "${CONFDIR} not found, creating"
		mkdir -p ${CONFDIR}
	fi

	# Start new key session and init conf. On boot keys will be cached in user key ring. In initrd check kernel cmdline.
	keyctl new_session
	if ! do_init_conf daemon 1; then
		systemd-notify --stopping --status="${MYNAME}: Cannot Initialize Config" 
		exit 0
	fi
	echo ${pid_daemon} >${conf[PIDFILE]}
	[[ ${conf[DEBUGSHELL]} -eq 1 ]] && set -a
	[[ "${INITRD}" -eq 1 ]] && for param in $(</proc/cmdline); do
		[[ "${param}" =~ ^${MYNAME}.keeplog ]] && keeplog=1 && [[ "${param}" =~ ^.*\=[0-4]$ ]] && conf[LOGLEVEL]="${param%%*=}"
	done
	[[ "${INITRD}" -eq 1 && ! -d /etc/udev/rules.d ]] && mkdir -p /etc/udev/rules.d
	[[ "${INITRD}" -eq 1 ]] && cat > /etc/udev/rules.d/99-${conf[ETCDEV]}${conf[LIBDEV]}.rules <<-EOF
	SUBSYSTEM=="block", KERNEL=="zd*", ACTION=="add|change", ENV{MD_DEVNAME}=="${conf[ETCDEV]}|${conf[LIBDEV]}", ENV{MD_STARTED}=="unsafe", ENV{MD_FOREIGN}=="no", RUN+="/sbin/mdadm --run /dev/\$env{MD_DEVICE}"
	EOF
	systemd-notify --status="${MYNAME}: Starting Up, Timeout $((conf[START_TIMEOUT]+conf[QUEUE_TIMEOUT]*2))s"
	systemd-notify EXTEND_TIMEOUT_USEC=$(((conf[START_TIMEOUT]+conf[QUEUE_TIMEOUT]*2)*1000000))

	# Start the logwriter.
	[[ ! -d ${conf[LOGDIR]} ]] && mkdir -p ${conf[LOGDIR]}
	chgrp ${conf[CRYPTDISKSD_GROUP]} ${conf[LOGDIR]} ${conf[CRYPTDISKSDDIR]} ${conf[FIFO]}
	chmod 750 ${conf[LOGDIR]}
	chmod ${conf[CRYPTDISKSDDIR_MODE]} ${conf[CRYPTDISKSDDIR]}
	chmod ${conf[FIFO_MODE]} ${conf[FIFO]}
	[[ ${FOREGROUND} -eq 0 ]] && do_daemon_start_logwriter && do_log debug "initializing" || echo "Log Level: ${conf[LOGLEVEL]}"

	# Check if the queue exists first, exit with error if it isn't. It should be there, or something is wrong with socket.
	if [[ ! -p ${conf[FIFO]} ]]; then
		do_log error "queue not found" 
		systemd-notify --stopping --status="${MYNAME}: Queue not Found, Restart ${MYNAME}.socket" 
		exit 0
	fi

	# Parse and load the configuration, exit if either fails.
	if ! do_daemon_check_conf; then 
		systemd-notify --stopping --status="${MYNAME}: Failed to Load Configuration"
		exit 0
	fi

	# Check if there is a crypttab, log message if there isn't since everything we do is based on it.
	if [[ "${INITRD}" -eq 0 && ! -f ${conf[CRYPTTAB]} ]]; then
		echo -e "#Crypt\t\t\t#Device\t\t\t\t#Passphrase(/algorithm/key-size/hash)\t\t#TRIM" >${conf[CRYPTTAB]}
		do_log warning "crypttab not found, creating default"
		systemd-notify --status="${MYNAME}: Crypttab (${conf[CRYPTTAB]}) not Found, Creating Default"
		start_status=2
	fi

	do_systemd_daemon
}

do_systemd_keysrv_start()
{
	local myname="${MYNAME}-keyserver:" time_start=$(do_timer) host=${USER} fd_logwriter pid_logwriter fd_journal
	if [[ ${UID} -eq 0 ]]; then
		echo "${myname} can not  be started as root"
		exit 1
	fi
	[[ ${FOREGROUND} -ne 1 ]] && exec 0>&- 0</dev/null {fd_journal}>&1- 1>/dev/null 2>&1 \
							  || exec {fd_logwriter}>&1 {fd_journal}>&1 2>&1

	# Load the configuration.
	if ! do_init_conf keyserver; then
		systemd-noify --stopping --status="${myname} Cannot Initialize Config" 
		exit 0
	fi
	if [[ ! -d ${conf[KEYDIR]} ]] && ! mkdir ${conf[KEYDIR]}; then
		do_log error "cannot create key dir ${conf[KEYDIR]}, terminating"
		exit 0
	fi
	chgrp -R ${conf[KEYSRV_GROUP]} ${KEYSRVDIR} ${conf[KEYDIR]}
	chmod 770 ${KEYSRVDIR} 
	chmod 660 ${KEYSRVCONF}
	chmod 750 ${conf[KEYDIR]}
	chmod 640 ${conf[KEYDIR]}/*

	# Start Log Writer
	[[ ! -d ${conf[LOGDIR]} ]] && mkdir -p ${conf[LOGDIR]}
	chgrp ${conf[KEYSRV_GROUP]} ${conf[LOGDIR]}
	chmod 750 ${conf[LOGDIR]}
	[[ ${FOREGROUND} -ne 1 ]] && case ${conf[LOGLEVEL]} in
		0|1|2)  exec {fd_logwriter}> >(logwriter ${MYNAME}-keyserver.log);;
		3|4)    exec {fd_logwriter}> >(logwriter ${MYNAME}-keyserver.log) 1>&${fd_logwriter} 2>&1;;
	esac
	pid_logwriter=$!

	cd ${KEYSRVDIR}
	keyctl new_session >/dev/null 2>&1
	do_systemd_keysrv
}

do_cryptdisksd_cli()
{
	local nr=$# cmd=0 _conf=0 res fd_logwriter myname=${MYNAME}
	exec {fd_logwriter}>&1
	# Enter a loop to evaluate all command line options and commands specified.
	while true; do
		# Parse options, the return code will be the nr of parameters to shift or 0 if all options parsed.
		# Continue with processing commands fase if all options parsed.
		if [[ ${cmd} -eq 0 ]]; then 
			do_parse_opt $@
			res=$?
			shift ${res}
			[[ ${res} -ne 0 ]] && continue
		fi
		# Command line options are parsed, evaluate and execute commands specified. Return code will be nr of arguments to shift.
		# If after shifting there are no more commands to process we can exit.
		cmd=1
		do_parse_cmd $@
		res=$?
		shift ${res}
		[[ -z "$1" ]] && return 0
	done
}

if [[ -e /etc/os-release ]]; then 
	. /etc/os-release
elif [[ -e /usr/lib/os-release ]]; then
	. /usr/lib/os-release
fi
MYNAME="$(basename $0)" FOREGROUND=0 PATH=/bin:/sbin INITRD=$([[ ! -L /etc/initrd-release ]])$?; unset LC_NUMERIC

# Formatting parameters for console output.
RED="\033[31m" GREY="\033[34m" YEL="\033[33m" GRN="\033[32m" BOLD="\033[1m" NOR="\033[0m" RES="\033[2J"
PI="\r\033[9C" PR="\r\033[s" PD="\033[u\033[16C\033[s" PE="\033[u\033[56C\033[s" PP="\033[u\033[5C\033[s"
PT="\033[u\033[38C\033[s" PK="\r\033[37C\033[s" UL="\033[4m" ULO="\033[24m"
OK="\r${GRN}${BOLD}[  OK  ]${NOR}" WARN="\r${YEL}${BOLD}[ WARN ]${NOR}" FAIL="\r${RED}${BOLD}[ FAIL ]${NOR}"

# Check if we're started interactively (options must be specified) or from systemd (run without any options from PID 1).
if [[ $# -eq 0 ]]; then
	# No command line options specified. check if we're started from systemd, start daemon if so.
	do_systemd_daemon_start
elif [[ "$1" == "keyserver" ]]; then
	[[ -n "$3" ]] && HOME=$(getent passwd "$3" |cut -d':' -f6 2>/dev/null)
	if [[ $# -eq 1 || ( $# -eq 2 && "$2" == "-f" ) ]]; then
		[[ "$2" == "-f" ]] && FOREGROUND=1
		[[ "${FOREGROUND}" -eq 1 || "${PPID}" -eq "${MANAGERPID}" ]] && do_systemd_keysrv_start
		false
	elif [[ "$2" != "status" || $# -gt 3 ]]; then
		do_echo_use keyserver
	elif [[ -z "${HOME}" ]] || ! do_init_conf; then
		echo -ne "${RED}${BOLD}Unable to Initialize"
		[[ -z "${HOME}" ]] && echo -e ", $3 is not a Valid Host.${NOR}" || echo -e " Config.${NOR}"
		false
	elif [[ "$2" == "status" ]]; then
		do_keysrv_cmd "$2" "$3"
	fi
elif [[ "$(basename ${SHELL})" == "${MYNAME}" ]]; then
	# If we are started through sshd a system is requesting passphrases.
	[[ "$(</proc/${PPID}/comm)" != "sshd" ]] && exit 1
	exec {in}>&0- {out}>&1- 2>/dev/null {fd_logwriter}>&2 {fd_journal}>&2
	a=($2);	cmd="${a[0],,}" pp="${a[1]}" timeout="${a[2]}"
	do_sanboot
else
	# Command line options present, run in interactive mode.
	do_cryptdisksd_cli $@
fi
exit $?

# [END OF EXECUTION FUNCTIONS]
