#!/bin/bash

# Function Definitions. All functions for serialized commands shall have their nemae prefixed by do_ all others shall not.

do_init_conf()
{
	# Initialize System Variables. Default config in /etc/cryptdisks.d/cryptdisksd.conf. Systemd env CONF(DIR) will override.
	local _var _val IFS=$'\n'
	declare -gA conf
	[[ -z "${CONFDIR}" ]] && CONFDIR="/etc/${MYNAME:0:-1}.d"
	[[ ! -d "${CONFDIR}" ]] && return 1
	[[ -z "${CONF}" ]] && CONF="${CONFDIR}/${MYNAME}.conf"
	if [[ -s ${CONF} ]]; then for _var in $(cat ${CONF} |grep -ve "^\s*#"); do
		_val=${_var#*=} _var=${_var%%=*}
		conf[${_var^^}]="${_val}"
   	done fi
	[[ -z "${conf[LOGLEVEL]}" ]] && conf[LOGLEVEL]=0
	[[ -z "${conf[DEBUGSHELL]}" ]] && conf[DEBUGSHELL]=0
	[[ -z "${conf[RUNDIR]}" ]] && conf[RUNDIR]="/run"
	[[ -z "${conf[LOGDIR]}" ]] && conf[LOGDIR]="/var/log/${MYNAME}"
	[[ -z "${conf[LOGFILE]}" ]] && conf[LOGFILE]="/var/log/${MYNAME}.log"
	[[ -z "${conf[CRYPTDISKSDDIR]}" ]] && conf[CRYPTDISKSDDIR]=${conf[RUNDIR]}/${MYNAME}
	[[ -z "${conf[PIDFILE]}" ]] && conf[PIDFILE]="${conf[CRYPTDISKSDDIR]}/${MYNAME}.pid"
	[[ -z "${conf[CRYPTDISKSD_GROUP]}" ]] && conf[CRYPTDISKSD_GROUP]="disk"
	[[ -z "${conf[CRYPTDISKSDDIR_MODE]}" ]] && conf[CRYPTDISKSDDIR_MODE]=700
	[[ -z "${conf[FIFO]}" ]] && conf[FIFO]="${conf[CRYPTDISKSDDIR]}/${MYNAME}.queue"
	[[ -z "${conf[FIFO_MODE]}" ]] && conf[FIFO_MODE]=600
	[[ -z "${conf[CRYPTTAB]}" ]] && conf[CRYPTTAB]="${CONFDIR}/crypttab"
	[[ -z "${conf[BLOCKDEVSDIRS]}" ]] && conf[BLOCKDEVSDIRS]="/dev/disk/by-id"
	[[ -z "${conf[START_TIMEOUT]}" ]] && conf[START_TIMEOUT]=5
	[[ -z "${conf[LOCK_TIMEOUT]}" ]] && conf[LOCK_TIMEOUT]=5
	[[ -z "${conf[PP_TIMEOUT]}" ]] && conf[PP_TIMEOUT]=3
	[[ -z "${conf[QUEUE_TIMEOUT]}" ]] && conf[QUEUE_TIMEOUT]=2
	[[ -z "${conf[KEYLIFE]}" ]] && conf[KEYLIFE]=10
	[[ -z "${conf[CLEANUP_TIMER]}" ]] && conf[CLEANUP_TIMER]=60
	[[ -z "${conf[FWDIR]}" ]] && conf[FWDIR]="/sys/firmware/efi/efivars"
	[[ -z "${conf[FWGUID]}" ]] && conf[FWGUID]="ca25478a-acb8-44ac-8c55-d5d45dfe25c5"
	[[ -z "${conf[FWBOOTCONF]}" ]] && conf[FWBOOTCONF]="${conf[FWDIR]}/UglyLinuxBootCFG-${conf[FWGUID]}"
	[[ -z "${conf[BOOTCONF]}" ]] && conf[BOOTCONF]="${CONFDIR}/boot.conf"
	[[ -z "${conf[NET_ONLINE]}" ]] && conf[NET_ONLINE]=1
	[[ -z "${conf[NET_RETRIES]}" ]] && conf[NET_RETRIES]=2
	[[ -z "${conf[USER_TIEMOUT]}" ]] && conf[USER_TIMEOUT]=10
	conf[START_TIMEOUT]=$((conf[START_TIMEOUT]*60))
	conf[PP_TIMEOUT]=$((conf[PP_TIMEOUT]*60))
	conf[KEYLIFE]=$((conf[KEYLIFE]*60))

	# Initialize formatting parameters for console output.
	RED="\033[91m" GREY="\033[94m" YEL="\033[93m" GRN="\033[92m" BOLD="\033[1m" UL="\033[4m" NOR="\033[0m" RES="\0332J"
	PR="\033[s" PD="\033[u\033[16C\033[s" PE="\033[u\033[62C\033[s" PP="\033[u\033[6C\033[s" PT="\033[u\033[22C\033[s" PS="\033[u\033[21C"
}

# [BEGIN OF LOGGING FUNCTIONS]

trap_term_logwriter()
{
	trap 'logger -p daemon.warning "cryptdisksd: ${_myname} unclean finish after $(do_timer ${_time_start})s"; exit 1' SIGINT SIGTERM

	# When the log writer is killed, set the read timeout to 1s (no exit) to allow the writer to parse remaining log messages.
	local _date="$(date '+%d-%m %H:%M:%S.%3N')"
	logger -p daemon.info "cryptdisksd: ${_myname} terminating"
	[[ ${conf[LOGLEVEL]} -gt 0 ]] && echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${_myname} terminating after $(do_timer ${_time_start})s" >>${conf[LOGFILE]}
	exit 0
}

logwriter()
{
	trap 'trap_term_logwriter' SIGINT SIGTERM

	# The log write will parse lines from stdin, sent by various workers. The lines are written to log and sent to syslog.
	local myname="logger (${BASHPID}):" _time_start=$(do_timer) lf line

	# Initialize the log file. Set the correct access rights.
	[[ ! -d ${conf[LOGDIR]} ]] && mkdir -p ${conf[LOGDIR]}
	chgrp ${conf[CRYPTDISKSD_GROUP]} ${conf[LOGDIR]}
	chmod 750 ${conf[LOGDIR]}
	if [[ ! -z "$1" ]]; then
		conf[LOGFILE]=${conf[LOGDIR]}/$1
		touch ${conf[LOGFILE]}
	fi
	chgrp ${conf[CRYPTDISKSD_GROUP]} ${conf[LOGFILE]}
	chmod 640 ${conf[LOGFILE]}
	[[ ${conf[LOGLEVEL]} -gt 0 ]] && echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${myname} initialized" >>${conf[LOGFILE]}

	# Prepend every line recieved with date and time and write to logfile.
	while read -r lf line; do
		local _date="$(date '+%d-%m %H:%M:%S.%3N')"
		if [[ "${lf}" == "debug" && ${conf[LOGLEVEL]} -ge 1 ]]; then
			echo "${_date} ${hostname} ${line}" >>${conf[LOGFILE]}
		elif [[ "${lf}" == "debug2" && ${conf[LOGLEVEL]} -ge 3 ]]; then
			echo "${_date} ${hostname} ${line}" >>${conf[LOGFILE]}
		elif [[ ${lf} == "info" || ${lf} == "warning" || ${lf} == "error" ]]; then
			logger -p daemon.${lf} "cryptdisksd: ${line}"
			[[ ${conf[LOGLEVEL]} -ge 1 ]] && echo "${_date} ${hostname} ${line}" >>${conf[LOGFILE]}
		elif [[ ${conf[LOGLEVEL]} -ge 3 ]]; then
			echo "${_date} ${hostname} ${lf} ${line}" >>${conf[LOGFILE]}
		fi
	done
	echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${myname} finished after $(do_timer ${_time_start})s ($?)" >>${conf[LOGFILE]}
}

do_log()
{
	# Send a message to the log writer, or to systemd if that fails.
	echo "$@" >&${fd_logwriter} || echo "$@" >&${fd_journal}
}

do_timer()
{
	# Start a timer for debugging purposes. We will track to the ms.
	if [[ $# -eq 0 ]]; then
		# Started with no args, start a timer, echo the start time.
		echo ${EPOCHREALTIME:0:-3}
	elif [[ ${1,,} == "date" ]]; then
		# Output the exact date of the timestamp.
		echo "$(date --date @$2 +%Y-%m-%d.%H:%M:%S)"
	else
		# Started with start time as args, calculate and echo the time difference.
		echo "$(bc <<<"x=${EPOCHREALTIME:0:-3}-$1; if (x<1) print 0; x")"
	fi
}

# [END OF LOGGING FUNCTIONS]

# [BEGIN OF MAIN DAEMON FUNCTIONS]

trap_term_daemon()
{
	trap 'systemd-notify --pid=$$ --status="cryptdisksd: unclean finish after $(do_timer ${time_start})s"; exit 1' SIGINT SIGTERM

	# Main process received SIGTERM or SIGINT, shutdown reader and logwriter processes.
	systemd-notify --pid=$$ --stopping --status="cryptdisksd: terminating"
	do_log warning "${myname} terminating after ${time_active}s"
	do_daemon_check_conf
	for _pid in ${pid_ctrl[@]}; do
		if [[ "$(cat /proc/${pid_ctrl[${_pid}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${pid_ctrl[${_pid}]}
			wait ${pid_ctrl[${_pid}]}
			do_log debu2 "${myname} killed control process (PID: ${pid_ctrl[${_pid}]})"
		fi
	done
	if [[ ! -z "${pid_reader}" && "$(cat /proc/${pid_reader}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_reader}
		wait ${pid_reader}
	fi
	if [[ ! -z "${pid_logwriter}" && "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_logwriter}
		wait ${pid_logwriter}
	fi
	rm -f ${conf[PIDFILE]} ${conf[CRYPTDISKSDDIR]}/*.sock
	systemd-notify --pid=$$ --ready --status="cryptdisksd: finished after $(do_timer ${time_start})s"
	
	exit $1 
}

trap_hup_daemon()
{
	# Received reload request from systemd. Reload the config asap (no active commands/workers). confok, contains status.
	# 0 - Config is ok.
	# 1 - Config changed, or SIGHUP received
	# 2 - Notified reader of reload
	# When the reader is ready to reload it will notify us and we can reload the config and restart the reader.
	if [[ ${starting} -eq 0 && ${confok} -eq 0 ]]; then
		do_log warning "${myname} received SIGHUP, reload config asap"
		confok=2
		kill -SIGHUP ${pid_reader}
		do_log debug2 "${myname} notified reader (PID: ${pid_reader}) of config reload"
	fi
}

systemd_daemon()
{
	trap 'trap_term_daemon' SIGINT SIGTERM
	trap 'trap_hup_daemon' SIGHUP

	# The reader and all workers will be started with the following fds:
	# 1 (stdout) 2 (stderr) and {fd_logwriter} (for subshells) point to a log writer.
	# {fd_journal} systemd journal messages which can be viewed with systemctl status and journalctl -xe
	# {fd_daemon} the daemon process.
	local time_active=0.000 cleanup=0.000 msg="" confok=0 fd_daemon pid_reader fd_reader reader_alive=0 readerr=0 pid_putkey key passphrase read_to res _time_start
	declare -A active_mnt pid_ctrl fd_ctrl time_ctrl cached_pp

	# If we are booting up the master passphrase may be in the user keyring, revoke and cache in session keyring.
	key="$(keyctl search @u user "system:master" 2>/dev/null)"; passphrase="$(keyctl pipe "${key}" 2>/dev/null)"
	if [[ ! -z "${key}" ]]; then
		do_log debug "${myname} removed system:master passphrase from user keyring"
		keyctl revoke "${key}" 2>/dev/null
		keyctl unlink "${key}" @u 2>/dev/null
		key_clnt "PUT" "system:master" "${passphrase}" & pid_putkey=$!
		do_cache_pp "system:master" "${passphrase}" "${myname}" && cached_pp[system:master]=1
	fi
	
	# The readers and will send us messages about events, we need to keep track of time for (debug) logging and cleanup.
	# If we are starting up, read time-out is start timeout so cleanup etc will be done only after start
	# If we are in normal op, keep cleanup timer (60secs). The timeouts will be evaluated every command iteration.
	systemd-notify --pid=$$ --status="cryptdisksd: Starting Up, Timeout $((conf[START_TIMEOUT]+conf[QUEUE_TIMEOUT]*2))s"
	systemd-notify EXTEND_TIMEOUT_USEC=$(((conf[START_TIMEOUT]+conf[QUEUE_TIMEOUT]*2)*1000000))
	do_daemon_start_reader
	do_log debug "${myname} started reader (PID: ${pid_reader})"

	while true; do	
		# If we are starting up, read time-out when initial queue is empty so we can notify parent. If we are in normal operation, keep cleanup timer (60secs).
		do_log debug2 "${myname} running since $(do_timer date ${time_start})"
		time_active=$(do_timer ${time_start}) read_to=$([[ ${starting} -eq 0 ]] && echo ${conf[CLEANUP_TIMER]} || echo ${conf[START_TIMEOUT]})
	
		# Set the new queue read timeout, we will run a cleanup every conf[CLEANUP_TIMER]. Cleanup will not run before we are started.
		# Make sure the read timeout is never 0 as this will complicate things (read will not read if to = 0).
		# Parse the message into an arry the first element will be reader second the pid of the reader, rest is the message.
		[[ ${starting} -eq 0 && ${time_active:0:-4} -gt $((${cleanup:0:-4}+${conf[CLEANUP_TIMER]}-${conf[QUEUE_TIMEOUT]})) ]] && do_daemon_cleanup
		read_to="$(((read_to+conf[QUEUE_TIMEOUT])-(${time_active:0:-4}%read_to)))"
		read -t${read_to} -ru${fd_reader} -a msg
		res=$?
		
		# Evaluate the exit status of the message queue read and act accordingly.
		time_active=$(do_timer ${time_start})
		if [[ ${res} -eq 142 ]]; then 
			do_log debug2 "${myname} waking up from slumber"
			[[ ${starting} -eq 0 && ${read_to##* } -gt $((conf[CLEANUP_TIMER]/2)) ]] && do_daemon_cleanup
			if [[ ${starting} -ne 0 && ${time_active:0:-4} -ge ${conf[START_TIMEOUT]} ]]; then 
				# Start timeout reached, notify systemd.
				do_log warning "${myname} start timeout reached, notifying reader and systemd"
				starting=0 start_status=3
				do_daemon_notify_systemd
			fi
			continue
		elif [[ ${res} -gt 128 ]]; then
			# Should not happen, daemon process received unhandled signal from somewhere.
			do_log debug "${myname} read result ${res}, may have been trapped"
			do_daemon_cleanup 
			continue
		elif [[ ${res} -ne 0 ]]; then
			# Reader has terminated unexpectedly or fd has somehow been closed from reader end.
			do_log error "${myname} read error ${res} \"${msg[@]}\""
			reader_alive=2
			do_daemon_cleanup
			continue
		fi

		# Evaluate the start status. Check if we have a start timeout. If so we are started and will notify systemd.
		if [[ ${starting} -ne 0 && ${time_active:0:-4} -ge ${conf[START_TIMEOUT]} ]]; then
			# Check if we have a start timeout. If so we are started and will notify systemd.
			starting=0 start_status=3
			do_daemon_notify_systemd
			continue
		elif [[ -z "${msg[@]}" || ! ( "${msg[0],,}" == "reader" && ${msg[1]} -eq ${pid_reader} ) ]]; then
			# Should not occur, run cleanup if it does, if reader has exited next read will fail, see above.
			do_log error "${myname} received invalid message \"${msg[@]}\""
			reader_alive=2
			do_daemon_cleanup
			continue
		fi

		# Process the message sent by the reader.
		do_log debug "${myname} processing \"${msg[@]}\"" 
		reader_alive=0 _time_start=$(do_timer)

		case ${msg[2],,} in
		started|control|notify)
			do_daemon_${msg[2],,};;
		active)
			do_log debug "${myname} reader (PID: ${pid_reader}) ping received";;
		remove)
			do_daemon_unmount_crypt "${msg[3]}";;
		add)
			do_daemon_mount_crypt "${msg[3]}" "${msg[4]}" "${msg[5]}" "${msg[6]}";;
		reload)
			[[ ${confok} -lt 2 ]] && do_log warning "${myname} incorrect reload request from reader";
			[[ -e /proc/self/fd/${fd_reader} ]] && exec {fd_reader}>&-
			unset pid_reader
			do_daemon_cleanup;;
		*)	
			do_log debug "${myname} received invalid command from reader \"${msg[@]}\"";;
		esac

		do_log debug2 "${myname} processing \"${msg[@]}\" took $(do_timer ${_time_start})s total"
	done

	# We should never get here, exit with error if we do.
	do_log error "${myname} terminated unexpectedly after $(do_timer {time_start})s"
	systemd-notify --pid=$$ --status="cryptdisksd: Daemon Terminated Unexpectedly After $(do_timer {time_start})s (PID: ${BASHPID}))"
	trap_term_daemon 2
}

do_daemon_start_logwriter()
{
	# LOGLEVEL 0, log only to syslog (daemon facility). 
	# LOGLEVEL 1, log to syslog and debug to dedicated logfile.
	# LOGLEVEL 2 is loglevel 1 with components having dedicated log file.
	# LOGLEVEL 3, extra debug logging, stdout and stderr of processes also sent to log.
	# BEWARE PASSPHRASES WILL BE LOGGED ALSO!!!!
	# LOGLEVEL 4, sames as level 3 with components having dedicated log file.
	case ${conf[LOGLEVEL]} in
		0|1)  exec {fd_logwriter}> >(logwriter);;
		2)    exec {fd_logwriter}> >(logwriter daemon-${pid_daemon}.log);;
		3)    exec {fd_logwriter}> >(logwriter) 1>&${fd_logwriter} 2>&1;;
		4)    exec {fd_logwriter}> >(logwriter daemon-${pid_daemon}.log) 1>&${fd_logwriter} 2>&1;;
	esac
	pid_logwriter=$!
}

do_daemon_start_reader()
{
	# Set the group and mode for the rundir and queue.
	[[ ! -z ${fd_reader} ]] && exec {fd_reader}>&-
	chgrp ${conf[CRYPTDISKSD_GROUP]} ${conf[CRYPTDISKSDDIR]} ${conf[FIFO]}
	chmod ${conf[CRYPTDISKSDDIR_MODE]} ${conf[CRYPTDISKSDDIR]}
	chmod ${conf[FIFO_MODE]} ${conf[FIFO]}
	case ${conf[LOGLEVEL]} in
	0|1|2)
			# Start the reader with stdout and stderr redirected to /dev/null (silent).
			exec {fd_reader}< <(udev_reader {fd_daemon}>&1- 1>/dev/null 2>&1);;
	3|4)	
			# Start the reader with stdout and stderr redirected to the logwriter.
			exec {fd_reader}< <(udev_reader {fd_daemon}>&1- 1>&${fd_logwriter} 2>&1);;
	esac
	pid_reader=$!
}

do_daemon_notify_systemd()
{
	# Daemon notify about startup status.
	systemd-notify --ready --pid=$$
	case ${start_status} in 
	0)
		do_log info "${myname} startup completed succesfully in ${time_active}s"
		systemd-notify --pid=$$ --status="cryptdisksd: Startup completed succesfully in ${time_active}s (PID: ${BASHPID})";;
	1)
		do_log warning "${myname} startup completed with errors in ${time_active}s"
		systemd-notify --pid=$$ --status="cryptdisksd: Startup completed with errors in ${time_active}s (PID: ${BASHPID})";;
	2)
		do_log warning "${myname} startup completed with warnings in ${time_active}s"
		systemd-notify --pid=$$ --status="cryptdisksd: Startup completed with warnings in ${time_active}s (PID: ${BASHPID})";;
	3)
		do_log warning "${myname} startup timed out after ${time_active}s"
		systemd-notify --pid=$$ --status="cryptdisksd: Startup timed out after ${time_active}s (PID: ${BASHPID})"
		kill -SIGHUP ${pid_reader};;
	esac
}

do_daemon_check_conf()
{
	# Parse the configuration from firmware and compare it to the config stored in the confdir.
	# If there are any differences, the configuration in confidir will take precedence and overwrite the firmware.
	local diff _diff fwsrvvar fwsrvkey fwusrvar fwusrkey srvkey usrkey
	do_log debug "${myname} checking config"

	if [[ -s ${conf[FWBOOTCONF]} && ! -s ${conf[BOOTCONF]} ]]; then
		# Config in firware, not in confdir, copy fw to confdir.
		[[ ${confok} -eq 0 ]] && confok=1
		do_log debug "${myname} copying ${conf[FWBOOTCONF]} config to ${CONFDIR}"
		cat ${conf[FWBOOTCONF]} | tail -c +5 >${conf[BOOTCONF]} || return 1
	elif [[ -s ${conf[FWBOOTCONF]} && -s ${conf[BOOTCONF]} ]]; then
		# Compare the firmware config to confdir.
		diff="$(cat ${conf[FWBOOTCONF]} | tail -c +5)" _diff="$(cat ${conf[BOOTCONF]})"
		if ! diff -q <(echo "${diff}") <(echo "${_diff}") >/dev/null; then
			# Configs are different, overwrite confdir on startup firmware config otherwise.
			[[ ${confok} -eq 0 ]] && confok=1
			if [[ ${starting} -eq 0 ]]; then
				do_log warning "${myname} ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} differ, replacing ${conf[FWBOOTCONF]}"
				[[ -e ${conf[FWBOOTCONF]} ]] && chattr -i ${conf[FWBOOTCONF]}
				printf "\x07\x00\x00\x00\x00" >${conf[FWBOOTCONF]} || do_log error "${myname} error creating ${conf[FWBOOTCONF]}"
				efivar -n ${conf[FWGUID]}-UglyLinuxBootCFG -w -f ${conf[BOOTCONF]} 2>&1 || do_log error "${myname} error copying ${conf[BOOTCONF]} to ${conf[FWBOOTCONF]}"
				chattr +i ${conf[FWBOOTCONF]}
			else
				do_log warning "${myname} ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} differ, replacing ${conf[BOOTCONF]}"
				cat ${conf[FWBOOTCONF]} | tail -c +5 >${conf[BOOTCONF]}
			fi
		else
			do_log debug2 "${myname} ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} equal"
		fi
	elif [[ ! -s ${conf[FWBOOTCONF]} && -s ${conf[BOOTCONF]} ]]; then
		# No fwconfig store confdir.
		[[ ${confok} -eq 0 ]] && confok=1
		do_log debug "${myname} no firmware config, copying from ${conf[BOOTCONF]}"
		[[ -e ${conf[FWBOOTCONF]} ]] && chattr -i ${conf[FWBOOTCONF]}
		printf "\x07\x00\x00\x00\x00" >${conf[FWBOOTCONF]} || do_log error "${myname} error creating ${conf[FWBOOTCONF]}"
		efivar -n ${conf[FWGUID]}-UglyLinuxBootCFG -w -f ${conf[BOOTCONF]} || do_log error "${myname} error copying ${conf[BOOTCONF]} to ${conf[FWBOOTCONF]}"
		chattr +i ${conf[FWBOOTCONF]}
	else
		# No bootconf at all.
		do_log warning "${myname} no boot config found"
		bootconf[BOOTSERVERS]=""
	fi

	# If we are starting up, now is the time to load the config.	
	if [[ ${starting} -eq 1 ]]; then
		do_daemon_reload_conf	
	fi

	# Check if the service config or crypttab has changed on disk.
	if [[ ${starting} -eq 0 && ${confok} -eq 0 ]]; then
		if [[ ! -f ${conf[CRYPTTAB]} ]]; then
			do_log warning "${myname} ${conf[CRYPTTAB]} disappeared, terminating"
		fi
		if [[ ! -f ${CONF} ]]; then
		 	do_log error "${myname} ${CONF} disappeared, terminating"
			return 1
		fi
		diff="$(cat ${CONF} |grep -ve "^\s*#")"
		if ! diff -q <(echo "${diff}") <(echo "${systemdconf}") >/dev/null; then
			do_log error "${myname} ${CONF} changed, terminating"
			return 1
		fi
		diff="$(cat ${conf[CRYPTTAB]} |grep -ve "^\s*#" |tr "\t" " " |tr -s " ")"
		if ! diff -q <(echo "${diff}") <(echo "${crypttab}") >/dev/null; then
			do_log debug "${myname} crypttab changed, reloading asap"
			confok=1
		fi
	fi

	# Check the bootserver and user keys if present.
	[[ -z ${bootconf[BOOTSERVERS]} ]] && return
	fwsrvvar="${conf[FWGUID]}-UglyLinux${bootconf[BOOTSERVERKEYS]}" fwsrvkey="${conf[FWDIR]}/UglyLinux${bootconf[BOOTSERVERKEYS]}-${conf[FWGUID]}"
	fwusrvar="${conf[FWGUID]}-UglyLinux${bootconf[BOOTUSERKEY]}"    fwusrkey="${conf[FWDIR]}/UglyLinux${bootconf[BOOTUSERKEY]}-${conf[FWGUID]}"
	srvkey="${CONFDIR}/${bootconf[BOOTSERVERKEYS]}"                 usrkey="${CONFDIR}/${bootconf[BOOTUSERKEY]}"
	if [[ -s ${fwsrvkey} && -s ${srvkey} ]]; then
		# compare the keys, overwrite if necessary
		diff="$(cat ${fwsrvkey} | tail -c +5)" _diff="$(cat ${srvkey})"
		if ! diff -q <(echo "${diff}") <(echo "${_diff}") >/dev/null; then
			# Configs are different, overwrite firmware config
			do_log warning "${myname} ${fwsrvkey} and ${srvkey} differ, replacing ${fwsrvkey}"
			[[ -e ${fwsrvkey} ]] && chattr -i ${fwsrvkey}
			printf "\x07\x00\x00\x00\x00" >${fwsrvkey} || do_log error "${myname} error creating ${fwsrvkey}"
			efivar -n ${fwsrvvar} -w -f ${srvkey} || do_log error "${myname} error copying ${srvkey} to ${fwsrvkey}"
			chattr +i ${fwsrvkey}
		else
			do_log debug2 "${myname} ${fwsrvkey} and ${srvkey} equal"
		fi
	elif [[ -s ${fwsrvkey} && ! -s ${srvkey} ]]; then
		# Keys in fw not in confdir, copy
		do_log debug "${myname} copying ${fwsrvkey} to ${srvkey}"
		cat ${fwsrvkey} | tail -c +5 > ${srvkey} || return 1
	elif [[ ! -s ${fwsrvkey} && -s ${srvkey} ]]; then
		# No fwbootkeys, copy from confdir.
		do_log debug "${myname} no firmware bootserver keys, copying from ${srvkey}"
		[[ -e ${fwsrvkey} ]] && chattr -i ${fwsrvkey}
		printf "\x07\x00\x00\x00\x00" >${fwsrvkey} || do_log error "${myname} error creating ${fwsrvkey}"
		efivar -n ${fwsrvvar} -w -f ${srvkey} || do_log error "${myname} error copying ${srvkey} to ${fwsrvkey}"
		chattr +i ${fwsrvkey}
	else
		# No bootserverkeys at all
		do_log error "${myname} no bootserver keys found"
		bootconf[BOOTSERVERS]=""
	fi

	# No need to check user key, if server key not present.
	[[ -z ${bootconf[BOOTSERVERS]} ]] && return
	if [[ -s ${fwusrkey} && ! -s ${usrkey} ]]; then
		# Key in fw not in confdir, copy
		do_log debug "${myname} copying ${fwusrkey} to ${usrkey}"
		chattr -i ${fwusrkey}; chmod 400 ${fwusrkey}; chattr +i ${fwusrkey}
		cat ${fwusrkey} | tail -c +5 > ${usrkey} || return 1
		chmod 400 ${usrkey}
	elif [[ -s ${fwusrkey} && -s ${usrkey} ]]; then
		# compare the keys, overwrite if necessary
		diff="$(cat ${fwusrkey} | tail -c +5)" _diff="$(cat ${usrkey})"
		if ! diff -q <(echo "${diff}") <(echo "${_diff}") >/dev/null; then
			# Configs are different, overwrite firmware config
			do_log warning "${myname} ${fwusrkey} and ${usrkey} differ, replacing ${fwusrkey}"
			[[ -e ${fwusrkey} ]] && chattr -i ${fwusrkey}
			printf "\x07\x00\x00\x00\x00" >${fwusrkey} || do_log error "${myname} error creating ${fwusrkey}"
			efivar -n ${fwusrvar} -w -f ${usrkey} || do_log error "${myname} error copying ${usrkey} to ${fwusrkey}"
			chattr -i ${fwusrkey}; chmod 400 ${fwusrkey}; chattr +i ${fwusrkey}
		else
			do_log debug2 "${myname} ${fwusrkey} and ${usrkey} equal"
			chattr -i ${fwusrkey}; chmod 400 ${fwusrkey}; chattr +i ${fwusrkey}
			chmod 400 ${usrkey}
		fi
	elif [[ ! -s ${fwusrkey} && -s ${usrkey} ]]; then
		# No fwbootuserkey, copy from confdir
		do_log debug "${myname} no firmware bootuser key, copying from ${usrkey}"
		[[ -e ${fwusrkey} ]] && chattr -i ${fwusrkey}
		printf "\x07\x00\x00\x00\x00" >${fwusrkey} || do_log error "${myname} error creating ${fwusrkey}"
		efivar -n ${fwusrvar} -w -f ${usrkey} || do_log error "${myname} error copying ${usrkey} to ${fwusrkey}"
		chattr -i ${fwusrkey}; chmod 400 ${fwusrkey}; chattr +i ${fwusrkey}
	else
		# No bootuserkeys at all
		bootconf[BOOTSERVERS]=""
	fi
	return 0
}

do_daemon_reload_conf()
{
	do_log debug "${myname} loading configuration"
	local var val IFS=$'\n'
	unset bootconf crypttab systemdconf
	declare -gA bootconf

	# Load the crypttab and systemd conf into memory.
	[[ -s ${conf[CRYPTTAB]} ]] && crypttab="$(cat ${conf[CRYPTTAB]} |grep -ve "^\s*#"| tr "\t" " " |tr -s " ")" 
	[[ -s ${CONF} ]] && systemdconf="$(cat ${CONF} |grep -ve "^\s*#")"

	# Source the boot config if necessary.
	if [[ -s ${conf[BOOTCONF]} ]]; then for var in $(cat ${conf[BOOTCONF]} |grep -ve "^\s*#"); do
		val=${var#*=} var=${var%%=*}
		bootconf[${var^^}]="${val}"
   	done fi
}

do_daemon_cleanup()
{
	# Readers should not ever exit, the is an error / bug. Restart the reader
	local myname="daemon cleanup (${BASHPID}):" _time_start=$(do_timer) tab_crypt="" pp crypt_arr crypt _crypt dev trim time pid mnt_crypt
	cleanup=$(do_timer ${time_start})
	do_log debug "${myname} cleanup starting at ${time_active}"

	# Ping systemd.
	systemd-notify WATCHDOG=1 WATCHDOG_USEC=$(((2*conf[CLEANUP_TIMER])*1000000))

	# Check if the log writer is still active, restart it and the reader if necessary.
	if [[ "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" != "${MYNAME}" ]] || ! kill -0 ${pid_logwriter} && kill -SIGKILL ${pid_logwriter}; then
		do_log error "${myname} logwriter (PID: ${pid_logwriter}) terminated after ${time_active}s, restarting"
		systemd-notify "cryptdisksd: logwriter (PID: ${pid_logwriter}) terminated after ${time_active}s, restarting"
		if [[ ${conf[LOGLEVEL]} -ne 2 && ${conf[LOGLEVEL]} -ne 4 ]]; then
			[[ "$(cat /proc/${pid_reader}/comm 2>/dev/null)" == "${MYNAME}" ]] && kill -SIGTERM ${pid_reader} && unset pid_reader
			[[ -e /proc/self/fd/${fd_reader} ]] && exec {fd_reader}>&-
			do_log debug2 "${myname} killed reader (PID: ${pid_reader})"
		fi
		do_daemon_start_logwriter
	fi

	# Kill too long running control conections.
	for pid in ${!pid_ctrl[@]}; do
		time=$(do_timer ${time_ctrl[${pid}]})
		if [[ ${time:0:-4} -ge $((2*conf[PP_TIMEOUT])) ]]; then 
			do_log debug "${myname} cleanup killed control worker (PID: ${pid_ctrl[${pid}]})"
			if [[ ! -z "${pid_ctrl[${pid}]}" && "$(cat /proc/${pid_ctrl[${pid}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
				kill -SIGKILL ${pid_ctrl[${pid}]}
				do_log debug2 "${myname} killed ${pid_ctrl[${pid}]}"
			fi
			exec {pid_ctrl[${pid}]}>&-
			unset pid_ctrl[${pid}] fd_ctrl[${pid}] time_ctrl[${pid}]
		fi
	done
	[[ -z ${!pid_ctrl[@]} ]] && rm -f ${conf[CRYPTDISKSDDIR]}/*.sock

	# Check the config.
	if ! do_daemon_check_conf; then
		do_log error "${myname} failed to check config, terminating"
		systemd-notify --ready --pid=$$
		systemd-notify STOPPING=1 --pid=$$ --status="cryptdisksd: Failed to Load Configuration"
		trap_term_daemon
	fi
		
	if [[ ${starting} -eq 0 && ${confok} -eq 1 ]]; then
		# Config has changed, needs to be reloaded.
		confok=2
		kill -SIGHUP ${pid_reader}
		do_log debug2 "${myname} notified reader (PID: ${pid_reader}) of config reload"
	fi

	# Check if the reader is still alive and restart it if necessary.	
	if [[ -z ${pid_reader} || ${reader_alive} -eq 2 || "$(cat /proc/${pid_reader}/comm 2>/dev/null)" != "${MYNAME}" ]] || ! kill -0 ${pid_reader}; then
		[[ ${reader_alive} -eq 2 ]] && do_log error "${myname} reader (PID: ${pid_reader}) not functioning after ${time_active}s"
		systemd-notify --pid=$$ --status="cryptdisksd: reader (PID: ${pid_reader}) terminated after ${time_active}s"
		if [[ "$(cat /proc/${pid_reader}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${pid_reader}
			do_log debug2 "${myname} killed reader (PID: ${pid_reader})"
		fi
		[[ -e /proc/self/fd/${fd_reader} ]] && exec {fd_reader}>&-
		do_daemon_reload_conf
		confok=0 reader_alive=0
		do_daemon_start_reader
		# Check if any crpyts have been removed from the crypttab and try to remove then. Then trigger udev to add new devices.
		# We will set a list with all crypts in the crypttab and will check that list against active mounts later.
		tab_crypt="$(tr "\t" " " <<<"${crypttab}" |cut -d" " -f1)"
	elif [[ ${reader_alive} -eq 1 ]]; then
		do_log warning "${myname} have not received ping from reader (PID: ${pid_reader})"
		reader_alive=2
	fi
	reader_alive=$((reader_alive+1))

	# Check the active crypts and add to active list if not already present.
	mnt_crypt="$(dmsetup ls --target crypt |cut -f1 |grep -vi "No devices found")"
	for crypt in ${mnt_crypt}; do if [[ -z "${active_mnt[${crypt}]}" ]]; then
		crypt_arr=($(do_xcrypt_fromtab "${myname}" "${crypt}"))
		[[ "$(lsblk -rD /dev/mapper/${crypt} |head -n2 |tail -n1 |cut -d" " -f3)" == "0B" ]] && trim=0 || trim=1
		if [[ ! -z "${crypt_arr[@]}" ]]; then
			dev="${crypt_arr[1]}" pp="$(do_eval_pp "${crypt_arr[2]}")"
			active_mnt[${crypt}]="${dev} ${pp} ${trim} $(do_timer)"
		else
			dev=/dev/"$(dmsetup deps ${crypt} -o blkdevname |cut -d: -f2 |tr -d " ()" |cut -d: -f2)"
			active_mnt[${crypt}]="${dev} - ${trim} $(do_timer)"
		fi
		do_log debug "${myname} found ${dev} as ${crypt} TRIM ${trim} passphrase ${pp} adding to active list"
	fi done

	# Check for removed crypts and remove the from active list.
	for crypt in ${!active_mnt[@]}; do
		for _crypt in ${mnt_crypt}; do
			[[ "${crypt}" == "${_crypt}" ]] && continue 2
		done
		crypt_arr=(${active_mnt[${crypt}]})
		do_log warning "${myname} ${crypt_arr[0]} as ${crypt} TRIM ${crypt_arr[2]} passphrase ${crypt_arr[1]} mounted since $(do_timer date ${crypt_arr[3]}) dissapeared"
		unset active_mnt[${crypt}]
	done

	# If we have reloaded look up any managed crypts removed from crypttab and make them unmanaged.
	if [[ ! -z "${tab_crypt}" ]]; then for crypt in ${!active_mnt[@]}; do
		crypt_arr=(${active_mnt[${crypt}]})
		[[ "${crypt_arr[1]}" == "-" ]] && continue
		for _crypt in ${tab_crypt}; do
			[[ "${crypt}" == "${_crypt}" ]] && continue 2
		done
		do_log warning "${myname} ${crypt_arr[0]} as ${crypt} TRIM ${crypt_arr[2]} passphrase ${crypt_arr[1]} mounted since $(do_timer date ${crypt_arr[3]}) removed from crypttab"
		active_mnt[${crypt}]="${crypt_arr[0]} - ${crypt_arr[2]} ${crypt_arr[3]}"
	done fi

	do_log debug2 "${myname} cleanup took $(do_timer ${_time_start})s, cached passphrases: ${!cached_pp[@]} - active mounts: ${!active_mnt[@]}"
}

# [END OF MAIN DAEMON FUNCTIONS]

# [BEGIN OF DAEMON READER FUNCTIONS]

do_daemon_started()
{
	# Process the start status, sent by the reader and our own.
	[[ ${start_status} -eq 0 && ${msg[4]} -eq 0 ]] && start_status=0
	[[ ${start_status} -eq 2 || ${msg[4]} -eq 2 ]] && start_status=2
	[[ ${start_status} -eq 1 || ${msg[4]} -eq 1 ]] && start_status=1

	# Set the new starting status, will need to wait for active workers, or notify systemd we are started
	case ${msg[3]} in
	0)
		# Reader has completed startup succesfully
		do_log debug "${myname} reader has started succesfully"
		do_daemon_notify_systemd
		do_daemon_cleanup
		starting=0;;
	2)
		# We are in inital startup. The reader notifies us the queue is empty and is still waiting for passphrases..
		starting=2
		do_log debug "${myname} reader has processed queue and is awaiting passphrases";;
	*)
		# Incorrect
		do_log warning "${myname} received incorrect start status from reader";;
	esac
}

do_daemon_notify()
{
	local myname="daemon-notify (${BASHPID}):" _time_start=$(do_timer) pid_ctrl=${msg[3]} cmd="${msg[4],,}"
	do_log debug "${myname} processing \"${msg[@]:4}\""

	# Process a command received from a control sub-process and notify about the result.
	case ${cmd} in
	add)
		echo "$(do_daemon_mount_crypt "${msg[5]}" "${msg[6]}" "${msg[7]} "${msg[8]}"")$?" >&${fd_ctrl[${pid_ctrl}]}
		do_log debug "${myname} active mounts: ${!active_mnt[@]}" ;;
	del)
		echo "$(do_daemon_unmount_crypt "${msg[5]}")$?" >&${fd_ctrl[${pid_ctrl}]}
		do_log debug "${myname} active mounts: ${!active_mnt[@]}" ;;
	*)
		do_log debug "${myname} received invalid notify command \"${msg[@]:2}\"" ;;
	esac
	do_log debug2 "${myname} processing \"${msg[@]:4}\" took $(do_timer ${_time_start})s"
}

do_daemon_control()
{
	# Daemon received control command from cryptdisksd command line. Initialize common variables for control process (__*)
	local myname="daemon-control (${BASHPID}):" _time_start=$(do_timer) _pid_ctrl=${msg[3]%%,*}
	local pid_socat=${msg[3]##*,} cmd="${msg[4],,}" sock_ctrl="${conf[CRYPTDISKSDDIR]}/${MYNAME}-${_pid_ctrl}.sock"
	local _myname _crypt_arr _pid_logwriter _pid_putkey _confirm=0 _crypttab=0 _smartall=0 _smarttest=0 _kr=0 _fw=0 _srv="" _socat
	do_log debug "${myname} processing \"${msg[@]:4}\""

	# Process the command received and start the according control worker process.
	case ${cmd} in
	finished)
		do_log debug "${myname} control connection (PID: ${pid_ctrl[${_pid_ctrl}]}) finished"
		exec {fd_ctrl[${_pid_ctrl}]}>&-
		unset pid_ctrl[${_pid_ctrl}] fd_ctrl[${_pid_ctrl}] time_ctrl[${_pid_ctrl}]
		[[ -e ${sock_ctrl} ]] && rm -f ${sock_ctrl};;
	add|del|put|rmkey|status|smart|erase)
		exec {fd_ctrl[${_pid_ctrl}]}> >(daemon_control_${cmd}) 
		pid_ctrl[${_pid_ctrl}]=$!
		time_ctrl[${_pid_ctrl}]=$(do_timer);;
	*)
		do_log debug "${myname} invalid control command \"${msg[@]:4}\"";;
	esac
	
	do_log debug2 "${myname} processing \"${msg[@]:4}\" took $(do_timer ${_time_start})s"
}

do_daemon_mount_crypt()
{
	local add_crypt="$1" add_dev="$2" add_pp="$3" add_trim="$4" add_time=$(do_timer) crypt_arr=() key="$(keyctl request user "$3" 2>/dev/null)"  passphrase=""
	do_log debug "${myname} mounting ${add_dev} as ${add_crypt} TRIM ${add_trim} with ${add_pp} passphrase"

	# The passphrase should be cached by now, error exit if not.
	if [[ -z "${key}" ]]; then
		do_log error "${myname} passphrase ${add_pp} not cached!" 
		unset cached_pp[${add_pp}]
		return 4
	fi
	passphrase="$(keyctl pipe ${key} 2>/dev/null)"
	cached_pp[${add_pp}]=1

	# First check if the crypt is already mounted. If so, check if it's on the active list and add if not.	
	if dmsetup info "${add_crypt}" >/dev/null 2>&1; then
		[[ "$(lsblk -rD /dev/mapper/${add_crypt} |head -n2 |tail -n1 |cut -d" " -f3)" == "0B" ]] && add_trim=0 || add_trim=1
		if [[ -z "${active_mnt[${add_crypt}]}" ]]; then
			active_mnt[${add_crypt}]="${add_dev} ${add_pp} ${add_trim} ${add_time}"
			do_log debug "${myname} added ${add_dev} as ${add_crypt} TRIM ${add_trim} passphrase ${add_pp} to active list"
			return 0
		else
			crypt_arr=(${active_mnt[${add_crypt}]})
			do_log info "${myname} ${crypt_arr[0]} already active as ${add_crypt} TRIM ${crypt_arr[2]} passphrase ${crypt_arr[1]} since $(do_timer date ${crypt_arr[3]})"
			return 2
		fi
	else
		if [[ "$(lsblk -rD ${add_dev} |head -n2 |tail -n1 |cut -d" " -f3)" == "0B" ]]; then
			add_trim=0 key=3
			do_log info "${myname} requested TRIM for ${add_crypt} but device ${add_dev} does not support it"
		fi
		if cryptsetup open --type plain $([[ ${add_trim} -eq 1 ]] && echo "--allow-discards") "${add_dev}" "${add_crypt}" <<<"${passphrase}"; then
			# Mounted, add to active list.
			do_log info "${myname} mounted ${add_dev} as ${add_crypt} TRIM ${add_trim} passphrase ${_dd_pp}"
			do_log debug2 "${myname} mounting ${add_dev} as ${add_crypt} TRIM ${add_trim} passphrase \"${passphrase}\" took $(do_timer ${add_time})s"
			active_mnt[${add_crypt}]="${add_dev} ${add_pp} ${add_trim} ${add_time}"
			return $((0+key))
		else
			do_log error "${myname} error mounting ${add_dev} as ${add_crypt} TRIM ${add_trim} after $(do_timer ${add_time})s"
			start_status=1
			return 1
		fi
	fi
}

do_daemon_unmount_crypt()
{
	local _time_start=$(do_timer) del_crypt="$1" crypt_arr=()

	if dmsetup info "${del_crypt}" >/dev/null 2>&1; then
		crypt_arr=(${active_mnt[${del_crypt}]})
		if kpartx -d /dev/mapper/${del_crypt} && cryptsetup remove "${del_crypt}"; then
			do_log info "${myname} removed ${crypt_arr[0]} as ${del_crypt} TRIM ${crypt_arr[2]} passphrase ${crypt_arr[1]} mounted since $(do_timer date ${crypt_arr[3]})"
			do_log debug2 "${myname} removing ${del_crypt} took $(do_timer ${_time_start})s"
			unset active_mnt[${del_crypt}]
			return 0
		else
			do_log warning "${myname} failed to remove ${crypt_arr[0]} as ${del_crypt} TRIM ${crypt_arr[2]} passphrase ${crypt_arr[1]} mounted since $(do_timer date ${crypt_arr[3]})"
			[[ ${start_status} -eq 0 ]] && start_status=2
			return 1
		fi
	else
		do_log debug "${myname} crypt ${del_crypt} not present, skipping"
		unset active_mnt[${del_crypt}]
		[[ ${start_status} -eq 0 ]] && start_status=2
		return 2
	fi
}

# [END OF DAEMON READER FUNCTIONS]

# [BEGIN OF DAEMON CONTROL FUNCTIONS]
trap_term_control()
{
	trap 'do_log warning "${_myname} unclean exit after ${_time_start})s"; exit 1' SIGINT SIGTERM

	[[ "$(cat /proc/${pid_socat}/comm)" == "socat" ]] && kill -SIGTERM ${pid_socat}
	[[ $1 -eq 0 ]] && do_log debug2 "${_myname} finished after $(do_timer ${_time_start})s"
	if [[ $1 -ne 0 ]]; then
		do_log debug2 "${_myname} terminating after $(do_timer ${_time_start})s"
		if [[ ! -z "${_socat_PID}" && "$(cat /proc/${_socat_PID}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_socat_PID}
			wait ${_socat_PID}
			do_log debug2 "${_myname} killed socat coproc (PID: ${_socat_PID})"
		fi
		if [[ ! -z "${_pid_putkey}" ]]; then
			kill -SIGTERM ${_pid_putkey}
			wait ${_pid_putkey}
			do_log debug2 "${_myname} killed putkey worker (PID: ${_pid_putkey})"
		fi
		if [[ ! -z "${_pid_getpp}" ]]; then
			kill -SIGTERM ${_pid_getpp}
			wait ${_pid_getpp}
			do_log debug2 "${_myname} killed getpp worker (PID: ${_pid_getpp})"
		fi
		if [[ ! -z "${_pid_logwriter}" &&"$(cat /proc/${_pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_logwriter}
			wait ${_pid_logwriter}
		fi
	fi
	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}

	exit $1
}

daemon_control_status()
{
	# Connect to control socket and blurt status in some form of a pretty fashion.
	do_control_init "status" "Status Report"
	local _key _passphrase="" _waiting_mnt=${msg[5]} _tab_crypt __crypt_arr=() _crypt __crypt _pp _trim _time _status

	# Output the status to the coproc, which will transfer it to stdout of the requestor. First al active mounts.
	echo -e "\r${GREY}${BOLD}${PR}CRYPT${PD}DEVICE${PE}TRIM${PP}PASSPHRASE${PT}ACTIVE SINCE${PS}STATUS${NOR}\r" >&${_socat[1]}
	[[ -n "${bootconf[STORAGEPREFIX]}" ]] && __storageprefix="${bootconf[STORAGEPREFIX]}" || __storageprefix="storage"
	for _crypt in ${!active_mnt[@]}; do
		_status="" __crypt_arr=(${active_mnt[${_crypt}]}); _pp=${__crypt_arr[1]}
		[[ "${__crypt_arr[2]}" == "1" ]] && _trim="On" || _trim="Off"
		[[ "${__crypt_arr[1]}" == "-" && "${_crypt}" =~ ^${__storageprefix}[0-9]{1,2}$ && -n "${bootconf[STORAGEPP]}" ]] && _pp="$(do_eval_pp "${bootconf[STORAGEPP]}")" 
		[[ "${__crypt_arr[1]}" == "-" && "${_crypt}" =~ ^${__storageprefix}[0-9]{1,2}$ && -z "${bootconf[STORAGEPP]}" ]] && _pp="system:master" 
		[[ "${__crypt_arr[1]}" == "-" ]] && _status="${YEL}Online (U)" || _status="${GRN}Online (M)"
		echo -e "${PR}${_crypt}${PD}${__crypt_arr[0]##*/}${PE}${_trim}${PP}${_pp}${PT}$(do_timer date ${__crypt_arr[3]})${PS}${_status}${NOR}\r" >&${_socat[1]}
	done

	# Output all unmounted and waiting crypts.
	_tab_crypt="$(tr "\t" " " <<<"${crypttab}" |cut -d" " -f1)"
	for _crypt in ${_tab_crypt}; do
		for __crypt in ${!active_mnt[@]}; do
			[[ "${_crypt}" == "${__crypt}" ]] && continue 2
		done
		for __crypt in $(IFS=','; echo ${_waiting_mnt}); do
			__crypt_arr=($(IFS='|'; echo ${__crypt}))
			if [[ "${_crypt}" == "${__crypt_arr[1]}" ]]; then
				_status="${YEL}Waiting" _time=$(do_timer date ${__crypt_arr[4]})
				break
			fi
		done
		[[ ! "${_status}" == "${YEL}Waiting" ]] && _status="${RED}Offline" _time="-"
		__crypt_arr=($(do_xcrypt_fromtab "${_myname}" "${_crypt}"))
		[[ "${__crypt_arr[3]}" == "1" ]] && _trim="On" || _trim="Off"
		echo -e "${PR}${_crypt}${PD}${__crypt_arr[1]}${PE}${_trim}${PP}$(do_eval_pp ${__crypt_arr[2]})${PT}${_time}${PS}${_status}${NOR}\r" >&${_socat[1]}
	done
	echo >&${_socat[1]}

	# Output cached passphrases.
	[[ ${conf[LOGLEVEL]} -ge 1 ]] && echo -e "${PR}${GREY}${BOLD}Cached Passphrases:${PS}${NOR}${!cached_pp[@]}\r\n" >&${_socat[1]}
	if [[ ${conf[LOGLEVEL]} -ge 3 ]]; then
		# Output passphrases.
		echo -e "${PR}${GREY}${BOLD}PASSPHRASE${PS}VALUE${NOR}\r" >&${_socat[1]}
		for _pp in ${!cached_pp[@]}; do
			_key="$(keyctl request user "${_pp}")"; _passphrase="$(keyctl pipe "${_key}")"
			echo -ne "${PR}${_pp}:${PS}" >&${_socat[1]}
			[[ -z "${key}" ]] && echo -e "${RED}${BOLD}FAIL${NOR}\r" >&${_socat[1]} || echo -e "\"${_passphrase}\"${NOR}\r" >&${_socat[1]}
		done
		echo >&${_socat[1]}
	fi
	echo -e "${UL}${myname} Running Since $(do_timer date ${time_start}) ($(do_timer ${time_start})s)${NOR}\r" >&${_socat[1]}

	trap_term_control 0
}

daemon_control_smart()
{
	# Display SMART Information for Device
	do_control_init "smart" "Do S.M.A.R.T."
	local _crypt="${_crypt_arr[0]}" _dev="$(do_find_dev "${_myname}" "${_crypt_arr[1]}")"

	if [[ -z "${_crypt_arr[@]}" ]]; then
		echo -e "\r${RED}${BOLD}${msg[5]} not Found in Crypttab.${NOR}\r" >&${_socat[1]}
		trap_term_control 1
	elif [[ -z "${_dev}" ]]; then
		echo -e "\r${RED}${BOLD}${_dev} not Found in ${conf[BLOCKDEVSDIRS]}.${NOR}\r.${NOR}\r" >&${_socat[1]}
		trap_term_control 1
	fi

	[[ ${_smartall} -eq 1 ]] && smartctl -x ${_dev} >&${_socat[1]} 2>&1 || smartctl -A ${_dev} >&${_socat[1]} 2>&1
	if [[ ${_smarttest} -eq 1 ]]; then
		if dmsetup info "${_crypt}" >/dev/null 2>&1; then
			echo -e "\r${RED}${BOLD}${_crypt} Still Active.${NOR}\r" >&${_socat[1]}
			trap_term_control 1
		fi
		smartctl -t long ${_dev} >&${_socat[1]} 2>&1
	fi

	trap_term_control 0
}

daemon_control_erase()
{
	# Secure Erase Device.
	do_control_init "erase" "Secure Erase"
	local _crypt="${_crypt_arr[0]}" _dev="$(do_find_dev "${_myname}" "${_crypt_arr[1]}")" _res=""

	if [[ -z "${_crypt_arr[@]}" ]]; then
		echo -e "\r${RED}${BOLD}${msg[5]} not Found in Crypttab.${NOR}\r" >&${_socat[1]}
		trap_term_control 1
	elif [[ -z "${_dev}" ]]; then
		echo -e "\r${RED}${BOLD}Device ${_dev} not Found in ${conf[BLOCKDEVSDIRS]}.${NOR}\r" >&${_socat[1]}
		trap_term_control 1
	fi

	if dmsetup info "${_crypt}" >/dev/null 2>&1; then
		echo -e "\r${RED}${BOLD}${_crypt} Still Active.${NOR}\r" >&${_socat[1]}
		trap_term_control 1
	fi

	echo -ne "${RED}${BOLD}This Will Wipe all Data on ${_dev}, Are You Sure (y/N)? " >&${_socat[1]}
	read -t${conf[USER_TIMEOUT]} -rsn1 -u ${_socat[0]} _res
	echo -e "${NOR}${BOLD}${_res}${NOR}\r" >&${_socat[1]}

	if [[ "${_res,,}" == "y" ]]; then
		echo -e "${RED}${BOLD}Secure Erasing ${_dev} ${YEL}password: $(hostname)${NOR}\r" >&${_socat[1]}
		hdparm -I ${_dev} |grep "ENHANCED SECURITY ERASE UNIT" >/dev/null 2>&1 && _res="--security-erase-enhanced" || _res="--security-erase"
		hdparm --security-set-pass "$(hostname)" ${_dev}
		hdparm ${_res} "$(hostname)" ${_dev} &
	fi

	trap_term_control 0
}

daemon_control_put()
{
	# Put the passphrase to the boot servers.
	do_control_init "put" "Putting Key"
	local _passphrase="" _pp="$(do_eval_pp "${msg[5]}")"
	[[ "${_srv}" == "0" ]] && _srv=${bootconf[BOOTSERVERS]} 

	if do_control_get_passphrase "${_pp}"; then
		echo -e "\r${BOLD}${GRN}Putting ${_pp} Key to Boot Servers: ${GREY}${_srv}.${NOR}\r" >&${_socat[1]}
		wait ${_pid_putkey}
		echo -e "\r" >&${_socat[1]}
	fi

	trap_term_control 0
}

daemon_control_rmkey()
{
	# Remove the key file for the passphrase.
	do_control_init "rmkey" "Removing Key File"
	local _pp="$(do_eval_pp "${msg[5]}")" _res=0; local _keyfile="${conf[FWDIR]}/UglyLinux${_pp}.key-${conf[FWGUID]}"
	do_log debug "${_myname} removing key file ${_pp} from ${_kr} ${_fw} ${_srv}"
	
	if [[ S{_fw} -eq 1 && ! -e ${_keyfile} ]]; then
		echo -e "\r${BOLD}${RED}${_keyfile} Does not Exist.${NOR}\r" >&${_socat[1]}
		_res=1
	elif  [[ S{_fw} -eq 1 ]]; then
		if chattr -i ${_keyfile} && rm -f ${_keyfile}; then
			echo -e "\r${BOLD}${GRN}Removed ${_keyfile}.${NOR}\r" >&${_socat[1]}
		else
			echo -e "\r${BOLD}${RED}Failed to Remove ${_keyfile}.${NOR}\r" >&${_socat[1]}
			_res=1
		fi
	fi

	trap_term_control 0
}

daemon_control_del()
{
	# Remove and delete crypt from crypttab if requested.
	do_control_init "del" "Removing Crypt"
	local _del_crypt=${_crypt_arr[0]} _del_dev=${_crypt_arr[1]} _del_pp=${_crypt_arr[2]} _del_trim=${_crypt_arr[3]} _del_time=$(do_timer) _res=""

	# Check if specified crypt is on tab, user decides to exit or continue if it's not.
	if [[ -z "${_crypt_arr[@]}" ]]; then
		echo -ne "\r${RED}${BOLD}${_del_crypt} not on Crypttab, Continue Removing (y/N)? ${NOR}" >&${_socat[1]}
		read -t${conf[USER_TIMEOUT]} -rsn1 -u ${_socat[0]} _res
		echo -e "${BOLD}${_res}${NOR}\r" >&${_socat[1]}
		[[ ! "${_res,,}" == "y" || -z "${_res,,}" || "${_res,,}" == $'\r' ]] && trap_term_control 0
		_crypttab=0 _del_dev="-" _del_pp="-"
	fi
	echo "notify ${_pid_ctrl} ${cmd} ${_del_crypt}" >${conf[FIFO]}
	read -t${conf[USER_TIMEOUT]} -r _res
	case ${_res} in
	0)
		echo -e "\r${BOLD}${GRN}Removed ${_del_dev##*/} as ${_del_crypt} Using ${_del_pp} TRIM ${_del_trim} Passphrase, Active Since $(do_timer date ${_del_time})${NOR}\r" >&${_socat[1]};;
	2)
		echo -e "\r${BOLD}${YEL}${_del_crypt} not active${NOR}\r" >&${_socat[1]};;
	*)
		echo -e "\r${BOLD}${RED}Failed to Remove ${_del_dev##*/} as ${_del_crypt} Using ${_del_pp} Passphrase TRIM ${_del_trim}${NOR}\r" >&${_socat[1]};;
	esac
	if [[ ${_crypttab} -eq 1 && ( ${_res} -ne 0 || ${_confirm} -eq 1 ) ]]; then
		echo -ne "\r${BOLD}Continue Removing ${_del_crypt} from Crypttab (Y/n)?${NOR}" >&${_socat[1]}
		read -t${conf[USER_TIMEOUT]} -rsn1 -u ${_socat[0]} _res
		echo -e "${BOLD}${_res}${NOR}\r" >&${_socat[1]}
	fi
	if [[ ${_crypttab} -eq 1 && ( "${_res,,}" == "y" || "${_res}" == $'\r' || -z "${_res}" ) ]]; then
		sed -i "/^${_del_crypt}\\s/D" ${conf[CRYPTTAB]}
		kill -SIGHUP ${pid_daemon}
		echo -e "\r${BOLD}${GRN}Removed ${_del_dev} as ${_del_crypt} TRIM ${_del_trim} from Crypttab${NOR}\r" >&${_socat[1]}
	fi

	trap_term_control 0
}

daemon_control_add()
{
	# Add the crypt received on the cryptdiskd command line and to crypttab if requested.
	do_control_init "add" "Adding Crypt"
	local _add_crypt="${msg[5]}" _add_dev="${msg[6]}" _add_dev2 _add_pp"${msg[7]}" _add_trim="${msg[8]}" _res="" __crypt_arr _passphrase=""
	
	if [[ ${_crypttab} -eq 0 && -z "${_crypt_arr[0]}" ]]; then
		# Recevied add with just a crypt, if it's not on the tab exit.
		echo -e "\r${BOLD}${RED}${_add_crypt} not on Crypttab${NOR}\r" >&${_socat[1]}
		trap_term_control 1
	elif [[ ${_crypttab} -eq 1 ]]; then
		# Crypt should be added to tab, check if specified crypt and dev are already on tab.
		__crypt_arr=($(do_xcrypt_fromtab "${_myname}" "${_add_dev}"))
		if [[ -z "${_crypt_arr[@]}" && -z "${__crypt_arr[@]}" ]]; then
			# Crypt and dev not on tab, find device.
			_add_dev="$(do_find_dev "${_myname}" "${_add_dev}")" _add_dev2="$(do_find_dev "${_myname}" "${_add_crypt}")"
			if [[ -z "${_add_dev}" && -z "${_add_dev2}}" ]]; then
				echo -e "\r${BOLD}${RED}Neither ${_add_crypt} nor ${_add_dev} is a Valid Block Device in ${conf[BLOCKDEVDIRS]}.${NOR}\r" >&${_socat[1]}
				trap_term_control 1
			elif [[ ! -z "${_add_dev}" && ! -z "${_add_dev2}" ]]; then
				echo -e  "\r${BOLD}${RED}Both ${_add_crypt} and ${_add_dev} are Valid Block Devices in ${conf[BLOCKDEVDIRS]}'.${NOR}\r" >&${_socat[1]}
				trap_term_control 1
			elif [[ ! -z "${_add_dev2}" ]]; then
				# Device was specified before crypt, swap paramters.
				_add_crypt="${msg[6]}" _add_dev="${_add_dev2}"
			fi
		else
			# Crypt and/or dev already on tab.
			if [[ ! -z "${_crypt_arr[@]}" && ! -z "${__crypt_arr[@]}" ]]; then
				echo -e "\r${BOLD}${RED}${_myname} both ${_add_crypt} and ${_add_dev} Already on Crypttab.${NOR}\r" >&${_socat[1]}
			elif [[ ! -z "${_crypt_arr[@]}" ]]; then
				echo -e "\r${BOLD}${RED}${_add_crypt} Already on Crypttab.${NOR}\r" >&${_socat[1]}
			else
				echo -e "\r${BOLD}${RED}${_add_dev} Aready on Crypttab.${NOR}\r" >&${_socat[1]}
			fi
			trap_term_control 1
		fi
	fi
	if [[ ${_add_crypt}${_add_dev}${_add_pp} =~ ( |,|\||\$) ]]; then
		echo -e "\r${BOLD}${RED}Illegal Characters \" $,|\" in Crypt or Dev.${NOR}\r" >&${_socat[1]}
		trap_term_control 1
	elif ! do_control_get_passphrase "${_add_pp}"; then
		# if we do not get a passphrase we cannot mount, continue to add on tab after confirmation.
		echo -e "\r${BOLD}${RED}No Passphrase Received, Cannot Mount ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase.${NOR}\r" >&${_socat[1]}
		_confirm=1
	else
		# Notify the daemon about the crypt to mount and inspect result.
		echo -e "\r${BOLD}${GRN}Putting ${_pp} Key to Boot Servers: ${GREY}${_srv}.${NOR}\r" >&${_socat[1]}
		echo "notify ${_pid_ctrl} ${cmd} ${_add_crypt} ${_add_dev} ${_add_pp} ${_add_trim}" >${conf[FIFO]}
		read -t${conf[USER_TIMEOUT]} -r _res
		wait ${_pid_putkey}
		case ${_res} in
		0)
			echo -e "\r${BOLD}${GRN}Mounted ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase${NOR}\r" >&${_socat[1]};;
		1)
			echo -e "\r${BOLD}${RED}Failed to Mount ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase${NOR}\r" >&${_socat[1]};;
		2)
			echo -e "\r${BOLD}${YEL}${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase Already Active${NOR}\r" >&${_socat[1]};;
		3)
			echo -e "\r${BOLD}${YEL}Mounted ${_add_dev} as ${_add_crypt} ${BOLD}${RED}TRIM ${_add_trim} ${BOLD}${YEL}Using ${_add_pp} Passphrase${NOR}\r" >&${_socat[1]};;
		*)
			echo -e "\r${BOLD}${RED}TIMEOUT or ERROR! (${_res})${NOR}\r" >&${_socat[1]}
			trap_term_control 1;;
		esac
	fi

	if [[ ${_crypttab} -eq 1 ]]; then
		# Crypt should be added to tab, ask for confirmation if necessary (error or request by user).
		if [[ ${_res} -ne 0 || ${_confirm} -eq 1 ]]; then
			echo -ne "\r${RED}${BOLD}${_add_crypt} Continue Adding ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase to Crypttab? (Y/n)${NOR}\r" >&${_socat[1]}
			read -t${conf[USER_TIMEOUT]} -rsn1 -u ${_socat[0]} _res
			echo -e "${BOLD}${_res}${NOR}\r" >&${_socat[1]}
		fi
		if [[ "${_res,,}" == "y" || "${_res}" == $'\r' || -z "${_res}" ]]; then
			# Add the crypt to the crypttab and send reload signal to daemon.
			echo -e "${_add_crypt}\t${_add_dev##*/}\t${_add_pp}\t${_add_trim}" >>${conf[CRYPTTAB]}
			echo -e "\r${BOLD}${GRN}Added ${_add_dev} as ${_add_crypt} Passphrase ${_add_pp} TRIM ${_add_trim} to Crypttab.${NOR}\r" >&${_socat[1]}
			kill -SIGHUP ${pid_daemon}
		fi
	fi

	trap_term_control 0
}

do_control_init()
{
	trap 'trap_term_control' SIGINT SIGTERM

	# Initialize the control worker and connect to the requestor socket.
	_myname="daemon-$1 (${BASHPID}:${_pid_ctrl}):"
	[[ "${cmd,,}" =~ ^(add|del|smart|erase)$ ]] && _crypt_arr=($(do_xcrypt_fromtab "${_myname}" "${msg[5]}"))
	
	# Check if socket exists first.
	if [[ ! -S ${sock_ctrl} ]]; then
		do_log error "${_myname} ${sock_ctrl} is not a socket, pocket rocket or a locket"
		trap_term_control 1
	fi
	# Start logwriter with dedicated logfile when LOGLEVEL=2 or = 4. When level = 4 redirect out stdout and stderr to the logwriter.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && _pid_logwriter="1>&${fd_logwriter} 2>&1"
		exec {fd_logwriter}> >(logwriter control-$1-${BASHPID}.log ${_pid_logwriter})
		_pid_logwriter=$!
	fi

	# Open the client socket.
	do_log debug "${_myname} connecting to ${sock_ctrl}"
	coproc _socat ( socat - UNIX-CONNECT:${sock_ctrl} )
	[[ ${conf[LOGLEVEL]} -ge 3 ]] && echo -e "\r${_myname} Connected for $2.\r" >&${_socat[1]}

	# Check the command line, it should contain crypt, device and passphrase and two options (confirm / crypttab) for add or del.
	if [[ "${cmd}" == "put" ]]; then
		_confirm=${msg[$((${#msg[@]}-2))]} _srv=${msg[$((${#msg[@]}-1))]}
		do_log debug "${_myname} OYOYOY ${_srv}"
	elif [[ "${cmd}" == "smart" ]]; then
		_smartall=${msg[$((${#msg[@]}-2))]} _smarttest=${msg[$((${#msg[@]}-1))]}
	elif [[ "${cmd}" == "rmkey" ]]; then
		_confirm=${msg[$((${#msg[@]}-4))]} _kr=${msg[$((${#msg[@]}-3))]} _fw=${msg[$((${#msg[@]}-2))]} _srv=${msg[$((${#msg[@]}-1))]}
	elif [[ "${cmd}" =~ ^(add|del)$ ]]; then
		_confirm=${msg[$((${#msg[@]}-2))]} _crypttab=${msg[$((${#msg[@]}-1))]} 
	fi
	[[ -n "${_srv}" ]] && _srv=$(IFS=,; echo ${_srv})
	do_log debug "${_myname} control connection initialized (PID: ${_socat_PID} SOCK:${sock_ctrl})"
}

do_control_get_passphrase()
{
	# Ask to get passphrase from network, if not cached, or query the user for the passphrase.
	local _key="$(keyctl request user "$1")" _pp=$1 _res _fd_getpp _pid_getpp __fd_up __fd_user
	if [[ -n "${_key}" ]]; then
		# Passphrase is still cached, use it and notify the daemon about the crypt.
		_passphrase="$(keyctl pipe "${_key}")"
		echo -e "\r${BOLD}${GRN}Found Cached ${_pp} Passphrase${NOR}\r" >&${_socat[1]}
	else
		echo -e "\r${BOLD}${RED}Passphrase ${_pp} not Cached.${NOR}\r" >&${_socat[1]}
	fi

	# If confirm option is specified ask to retreive passphrase from boot servers.
	if [[ -z "${_key}" && ${_confirm} -eq 1 && ( ${conf[NET_ONLINE]} -eq 0 || "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ (online|partial)$ ) ]]; then
		echo -ne "\r${BOLD}${_pp} Passphrase Not Cached, Get Passphrase from Boot Servers (Y/n)?${NOR}" >&${_socat[1]}
		IFS= read -t${conf[USER_TIMEOUT]} -rsn1 -u ${_socat[0]} _res
		[[ "${_res}" == $'\r' || -z "${_res}" ]] && _res=y
		echo -e "${BOLD}${_res}${NOR}\r" >&${_socat[1]}
	fi

	# Get passphrase from bootservers, we can use the passphrase ssh worker for this.
	if [[ -z "${_key}" && ( ${conf[NET_ONLINE]} -eq 0 || "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ (online|partial)$ ) && ( ${_confirm} -eq 0 || "${_res,,}" == "y" ) ]]; then
		echo -e "\r${BOLD}Getting Passphrase from Boot Servers: ${NOR}${GREY}${bootconf[BOOTSERVERS]}${NOR}\r" >&${_socat[1]}
		exec {_fd_getpp}< <(key_clnt "GET" "${_pp}" {__fd_up}>&1- {__fd_user}>&${_socat[1]}-)
		_pid_getpp=$!
		read -t$((conf[PP_TIMEOUT]/conf[NET_RETRIES]+1)) -ru${_fd_getpp} _passphrase && _key=1 || echo -e "\r\n${RED}${BOLD}Failed to Get ${_pp} Passphrase from Boot Servers${NOR}\r" >&${_socat[1]}
		exec {_fd_getpp}>&-
		[[ "$(cat /proc/${_pid_getpp}/comm 2>/dev/null)" == "${MYNAME}" ]] && kill -SIGTERM ${_pid_getpp}
	fi

	# Query the user for the passphrase.
	if [[ -z "${_key}" ]]; then
		exec {_fd_getpp}< <(query_passphrase "${_pp}" {__fd_up}>&1- {__fd_user[0]}<&${_socat[0]}- {__fd_user[1]}>&${_socat[1]}-)
		_pid_getpp=$!
		read -t${conf[PP_TIMEOUT]} -ru${_fd_getpp} _passphrase && _key=1 || echo -e "\r\n${RED}${BOLD}Failed to Get ${_pp} Passphrase from Your Yourself and You${NOR}\r" >&${_socat[1]}
		exec {_fd_getpp}>&-
		[[ "$(cat /proc/${_pid_getpp}/comm 2>/dev/null)" == "${MYNAME}" ]] && kill -SIGTERM ${_pid_getpp}
	fi

	# Got passphrase, put and cache it.
	if [[ -n "${_key}" ]]; then
		[[ -z "${_passphrase}" ]] && echo -e "\r${BOLD}${YEL}Your ${_pp} Passphrase Has no Character, Just Like You.${NOR}\r" >&${_socat[1]}
		exec {__fd_user}>&${_socat[1]}
		key_clnt "PUT" "${_pp}" "${_passphrase}" ${_srv} & _pid_putkey=$!
		do_cache_pp "${_pp}" "${_passphrase}" "${_myname}"
	else
		echo -e "\r${RED}${BOLD}${_pp} Passphrase Timeout!${NOR}\r" >&${_socat[1]}
		return 1
	fi
}

# [END OF DAEMON CONTROL FUNCTIONS]

# [BEGIN OF DAEMON & READER SHARED FUNCTIONS]

do_xcrypt_fromtab()
{
	# Extract the line for the device received in the udev command from the crypttab into crypt_arr array.
	# Element 1 = cryptdisk name
	# Element 2 = cryptdisk block device
	# Element 3 = passphrase
	# Element 4 = TRIM
	local myname=$1 crypt_arr i
	for ((i=2;i<=$#;i++)); do
		crypt_arr=($(grep -iE "(^|\s)${!i}\s" <<<"${crypttab}" 2>/dev/null)) 
		[[ "${#crypt_arr[@]}" -eq 3 ]] && crypt_arr[3]=0
		if [[ "${#crypt_arr[@]}" -eq 0 ]]; then
			do_log debug "${myname} device ${!i} not found in crypttab"
		elif [[ "${#crypt_arr[@]}" -ne 4 || ${crypt_arr[0]}${crypt_arr[1]}${crypt_arr[2]} =~ (,| |\|\$) ]]; then
			do_log warning "${myname} incorrect crypttab entry ${crypt_arr[@]}"
			_status=2
		else
			do_log debug2 "${myname} device ${!i} found on crypttab"
			[[ "${crypt_arr[3]}" == "1" || "${crypt_arr[3],,}" == "y" || "${crypt_arr[3],,}" == "yes" ]] && crypt_arr[3]=1 || crypt_arr[3]=0
			echo "${crypt_arr[@]}"
			break
		fi
	done
}

do_eval_pp()
{
	# Evaluate the passphrase and prepend cryptdisks: or make system:master. 
  	if [[ ${1,,} =~ ^(1|master|system|system:master)$ ]]; then
   		echo "system:master"
	elif [[ ! ${1,,} =~ ^cryptdisks: ]]; then
		echo "cryptdisks:${1,,}"
	else 
		echo "${1,,}"
	fi
}

do_find_dev()
{
	local myname=$1 blockdevdir dev=$2
	for blockdevdir in ${conf[BLOCKDEVSDIRS]}; do if [[ -b ${blockdevdir}/${dev} ]]; then
		do_log debug "${myname} found ${blockdevdir}/${dev} for ${dev}"
		echo "${blockdevdir}/${dev}"
		return
	fi done
	do_log debug "${myname} ${dev} not found in ${conf[BLOCKDEVSDIRS]}"
}

do_check_passphrase()
{
	# Check the received passphrase against the stored key in firmware. Write key if it doesn't exist.
	local myname=$3
	if [ -s ${conf[FWDIR]}/UglyLinux$1.key-${conf[FWGUID]} ]; then
		if  $(cat ${conf[FWDIR]}/UglyLinux$1.key-${conf[FWGUID]} | tail -c +5 | openssl aes-256-cbc -d -salt -pbkdf2 -in - -out /dev/null -k "$2" 2>/dev/null); then
			do_log debug "${myname} passphrase check ok"
			return 0
		else
			do_log debug "${myname} passphrase check fail"
			if [[ "$4" == "rmkey" ]]; then 
				chattr -i ${conf[FWDIR]}/UglyLinux$1.key-${conf[FWGUID]} 
				rm -f ${conf[FWDIR]}/UglyLinux$1.key-${conf[FWGUID]}
			fi
			return 1
		fi
	else
		do_write_keyfile "$1" "$2" "${myname}" || return 3
		do_log debug "${myname} passphrase not checked"
		return 2
	fi
}

do_write_keyfile()
{
	# Write a keyfile for key received to firmware.
	local myname=$3
	if ! head -c256 /dev/urandom |openssl aes-256-cbc -e -salt -pbkdf2 -in - -out ${conf[CRYPTDISKSDDIR]}/$1.key -k "$2"; then
		do_log error "${myname} error creating ${conf[CRYPTDISKSDDIR]}/$1.key"
	elif ! efivar -n ${conf[FWGUID]}-UglyLinux$1.key -w -f ${conf[CRYPTDISKSDDIR]}/$1.key; then
		do_log error "${myname} error writing ${conf[FWDIR]}/UglyLinux$1.key-${conf[FWGUID]}"
	else
		do_log debug "${myname} wrote ${conf[FWDIR]}/UglyLinux$1.key-${conf[FWGUID]}"
	fi
	rm -f ${conf[CRYPTDISKSDDIR]}/$1.key
}

do_cache_pp()
{
	local myname=$3 key="$(keyctl request user "$1" 2>/dev/null)"
	
	# Cache if the passphrase is already cached.
	if [[ -z "${key}" ]]; then
		key="$(keyctl padd user "$1" @s <<<"$2" 2>/dev/null)"
	fi
	if [[ -z "${key}" ]]; then
		do_log warning "${myname} failed to cache $1 passphrase"
		return 1
	fi

	do_log debug "${myname} cached $1 passphrase indefinitely"
}

# Key client executes commands on keyservers and relays the result back to caller, which may be user on cli.
# We expect to be called with two or three parameters, depending on the command. And optionally a list of servers.
# 1. The command (GET / PUT / DEL)
# 2. The passphrase name
# 3. In case of PUT, the passphrase
# In case of GET we also need a redirection for {__fd_up} and for cli a {__fd_user} to relay the passphrase / status.
trap_term_key_clnt()
{
	trap 'do_log warning "${myname} unclean exit after $(do_timer ${_time_start})s"; exit 1' SIGINT SIGTERM

	# Reader received SIGTERM or SIGINT. See if we have any workers to kill and remove the queue.
	do_log debug2 "${myname} terminating after $(do_timer ${_time_start})s"

	for ts in ${pid_cmd}; do if [[ "$(cat /proc/${ts}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${ts}
		do_log debug2 "${myname} killed ${cmd} (PID: ${ts})"
		wait ${ts}
	fi done
	if [[ -n "${pid_ssh}" && "$(cat /proc/${pid_ssh}/comm 2>/dev/null)" == "ssh" ]]; then
		kill -SIGTERM ${pid_ssh}
		do_log debug2 "${myname} killed ssh (PID: ${pid_ssh})"
		wait ${pid_ssh}
	fi
	if [[ "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_logwriter}
		wait ${pid_logwriter}
	fi
	
}

key_clnt()
{
	trap 'trap_term_key_clnt' SIGINT SIGTERM

	local myname="${1,,}:$2 (${BASHPID}):" _time_start=$(do_timer) cmd="$1" pp="$2" timeout to ts pid_logwriter pid_cmd passphrase="" srv res
	[[ "${cmd,,}" == "put" ]] && passphrase="$3" srv="$4" to="to" || srv="$3" to="from"

	# If we are called with exactly one server, execute the command on that server.
	if [[ ( "${cmd,,}" == "put" && $# -eq 4 ) || ( "${cmd,,}" != "put" && $# -eq 3 ) ]]; then
		local pid_ssh pid_cmd pid_logwriter
		do_log debug "${myname} ${cmd} ${pp} key ${to} ${srv}"
		[[ ${starting} -eq 0 ]] && timeout=${conf[PP_TIMEOUT]} || timeout=${conf[START_TIMEOUT]}
		[[ "${cmd,,}" == "get" ]] && timeout=$((timeout/conf[NET_RETRIES]+1))
		exec {fd_ssh}< <(ssh -i ${CONFDIR}/${bootconf[BOOTUSERKEY]} -o UserKnownHostsFile=${CONFDIR}/${bootconf[BOOTSERVERKEYS]} ${bootconf[BOOTUSER]}@${srv} "${cmd}" "${pp}" "${passphrase}")
		pid_ssh=$!
		if ! read -t${timeout} -ru${fd_ssh} res; then
			[[ $? -eq 142 ]] && ts="timeout" || ts="failed"
			[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${RED}${srv}${NOR} " >&${__fd_user}
			do_log warning "${myname} ${cmd} ${pp} key ${to} ${srv} for ${bootconf[BOOTUSER]} ${ts}"
		elif [[ "${cmd,,}" != "get" && "${res,,}" == "ok" ]]; then
			[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${GRN}${srv}${NOR} " >&${__fd_user}
			do_log debug "${myname} ${cmd} ${pp} key ${to} ${srv} for ${bootconf[BOOTUSER]} succeeded"
		elif [[ "${cmd,,}" != "get" && "${res,,}" == "same" ]]; then
			[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${YEL}${srv}${NOR} " >&${__fd_user}
			do_log info "${myname} ${cmd} ${pp} key ${to} ${srv} for ${bootconf[BOOTUSER]} equal"
		elif [[ "${cmd,,}" == "get" && $(do_check_passphrase "${pp}" "${passphrase}" "${myname}")$? -ne 1 ]]; then
			do_log info "${myname} ${cmd} ${pp} key ${to} ${srv} for ${bootconf[BOOTUSER]} success"
			[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${GRN}${srv}${NOR} " >&${__fd_user}
			echo "${passphrase}" >&${__fd_up}
		else
			[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${RED}${srv}${NOR} " >&${__fd_user}
			do_log warning "${myname} ${cmd} ${pp} key ${to} ${srv} for ${bootconf[BOOTUSER]} failed"
		fi
		exit
	fi

	# When starting wait for network before trying to connect to servers.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && exec {fd_logwriter}> >(logwriter ${cmd,,}-${pp}-${BASHPID}.log) 1>&${fd_logwriter} 2>&1 || exec {fd_logwriter}> >(logwriter ${cmd,,}-${pp}-${BASHPID}.log)
		pid_logwriter=$!
	fi
	if [[ ${starting} -ne 0 && ${conf[NET_ONLINE]} -eq 1 ]]; then
		ts=$(do_timer) timeout=0
		until [[ ${timeout} -ge ${conf[START_TIMEOUT]} || "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ (online|partial)$ ]]; do
			sleep ${conf[QUEUE_TIMEOUT]} & wait $!
			timeout=$((timeout+$(do_timer ${ts} |cut -d. -f1)))
		done
	fi

	# For every boot server on command line start a command sub shell. If no list of servers was specified use all.
	# We will not retry PUT or DEL as this should just work if the other side is set up. Also no retry for getting the passphrase for cli user.
	[[ "${cmd,,}" == "put" ]] && srv="${@:4}" || srv="${@:3}"
	[[ -z "${srv}" ]] && srv="${bootconf[BOOTSERVERS]}"
	do_log debug "${myname} ${cmd} ${pp} key ${to} boot servers: ${srv}"
	timeout=0
	while [[ -n "${srv}" && ${timeout} -le ${conf[NET_RETRIES]} ]]; do
		for ts in ${srv}; do
			if [[ "${cmd,,}" == "put" ]]; then
				key_clnt "${cmd}" "${pp}" "${passphrase}" "${ts}" &
			else
				key_clnt "${cmd}" "${pp}" "${ts}" &
			fi
			pid_cmd+="$! "
		done
		wait ${pid_cmd}
		[[ "${cmd,,}" != "get" || -n "${__fd_user}" ]] && unset srv || timeout=$((timeout+1))
	done

	do_log debug2 "${myname} finished after $(do_timer ${_time_start})s"
}

akgjhaquery_passphrase()
{
	trap 'trap_term_query_passphrase' SIGINT SIGTERM

	# Ask for a pssphrase input by user through systemd-ask-password
	local myname="query:${1} (${BASHPID}):" _time_start=$(do_timer) pp=$1 pid_askpp fd_askpp pid_putkey CHAR DEL="$(printf "\x7F")" passphrase _passphrase ppchk
	do_log debug "${myname} query for ${pp} passphrase started"

	do_ask_passphrase "Enter ${pp} Passphrase: "

	# Received a passphrase from the user check it against key stored in firmware.
	local ppchk=$(do_check_passphrase "${pp}" "${passphrase}" "${myname}")$?
	case ${ppchk} in
	3)
		do_log error "${myname} Unable to confirm passphrase due to key error, giving up"
		trap_term_query_passphrase;;
	2)
		# Key not present in firmware, ask for confirmation from the user.
		_passphrase="${passphrase}"
		do_ask_passphrase "Created key file. Confirm ${pp} Passphrase: "
		# If the passphrase does not match, enter a loop until it does and wirte the keyfile if ok.
		until [[ "${_passphrase}" == "${passphrase}" ]]; do
			do_ask_passphrase "Passphrases do not Match. Enter ${pp} Passphrase: "
			_passphrase="${passphrase}"
			do_check_passphrase "${pp}" "${passphrase}" "${myname}" rmkey
			do_ask_passphrase "Confirm ${pp} Passphrase: "
			[[ "${_passphrase}" == "${passphrase}" ]] && do_write_keyfile "${pp}" "${passphrase}" "${myname}"
		done
		do_log debug "${myname} received passphrase after $(do_timer ${_time_start})s";;
	1)
		# Passphrase entered does not match stored key, keep asking until it does.
		until [[ ${ppchk} -eq 0 ]]; do
			do_log debug2 "${myname} query passphrase check failed"
			do_ask_passphrase "Incorrect Passphrase. Enter ${pp} Passphrase: "
			ppchk=$(do_check_passphrase "${pp}" "${passphrase}" "${myname}")$?
		done
		do_log debug "${myname} received passphrase after $(do_timer ${_time_start})s";;
	0)
		# Passphrase received is ok.
		do_log debug "${myname} received passphrase after $(do_timer ${_time_start})s";;
	esac
 
 	# Notify the reader, so it knows passphrase worker has finished.
	echo "${passphrase}" >&${__fd_up}
	
	do_log debug2 "${myname} took $(do_timer ${_time_start})s total"
}

do_ask_passphrase()
{
	if [[ -z "${__fd_user[@]}" ]]; then
		# Query for the passphrase in the background, record pid so we can kill if passphrase is received from server.
		exec {fd_askpp}< <(NOTIFY_SOCKET= systemd-ask-password --timeout=0 --id=${pp} "$1" {__fd_up}>&-)
		pid_askpp=$!
		read -ru${fd_askpp} passphrase
	else
		passphrase="" CHAR=""
		echo -ne "\r${BOLD}$1: ${NOR}" >&${__fd_user[1]}
		until [[ "${CHAR}" == $'\r' ]]; do
		   	read -t${conf[USER_TIMEOUT]} -rsn1 -u${__fd_user[0]} CHAR || exit
			if [[ "${CHAR}" == "${DEL}" && "${#passphrase}" -ge 1 ]]; then
				echo -ne "\b \b" >&${__fd_user[1]}
				passphrase="${passphrase::-1}"
			elif [[ ! "${CHAR}" == $'\r' ]]; then
				passphrase+="${CHAR}"
				echo -n "*" >&${__fd_user[1]}
			fi
		done
		echo -e "\r" >&${__fd_user[1]}
	fi
}

# [END OF DAEMON & READER SHARED FUNCTIONS]

# [BEGIN OF UDEV QUEUE READER FUNCTIONS

trap_term_reader()
{
	trap 'do_log warning "${_myname} unclean exit after $(do_timer ${_time_start})s"; exit 1' SIGINT SIGTERM

	# Reader received SIGTERM or SIGINT. See if we have any workers to kill and remove the queue.
	_time_active="$(do_timer ${_time_start})"
	do_log debug2 "${_myname} terminating after ${_time_active}s"

	# Kill all active passphrase workers.
	local _pp
	for _pp in ${!_pid_ppwrk[@]}; do
		if [[ ! -z "${_pid_ppwrk[${_pp}]}" && "$(cat /proc/${_pid_ppwrk[${_pp}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_ppwrk[${_pp}]}
			wait ${_pid_ppwrk[${_pp}]}
			do_log debug2 "${_myname} killed passphrase worker for ${_pp} (PID: ${_pid_ppwrk[${_pp}]})"
		fi
	done
	for _pp in ${!_pid_putkey[@]}; do
		if [[ ! -z "${_pid_putkey[${_pp}]}" && "$(cat /proc/${_pid_putkey[${_pp}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_putkey[${_pp}]}
			wait ${_pid_putkey[${_pp}]}
			do_log debug2 "${_myname} killed putkey worker for ${_pp} (PID: ${_pid_putkey[${_pp}]})"
		fi
	done
	for __pp in ${!_pid_shell[@]}; do
		if [[ "$(cat /proc/${_pid_shell[${__pp}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_shell[${__pp}]}
			wait ${_pid_shell[${__pp}]}
		fi
	done

	# If we are in startup we should not be terminated, exit with error. Otherwise exit with current status.
	if [[ "${_starting}" -ne 0 ]]; then
		do_log error "${_myname} terminated while in startup"
	fi
	if [[ "$(cat /proc/${_pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${_pid_logwriter}
		wait ${_pid_logwriter}
	fi

	exit 0
}

trap_hup_reader()
{
	# Received reload request from systemd. Reload the config when not handling command and no active workers.
	_time_active=$(do_timer ${_time_start})
	if [[ ${_starting} -eq 0 && ${_confok} -eq 0 ]]; then
		do_log warning "${_myname} received SIGHUP, reload config asap"
		if [[ -z "${_cmd}" ]]; then
			do_reader_cleanup
			if [[ -z "${!_waiting_mnt[@]}" ]]; then
				do_reader_notify_daemon "reload"
				trap_term_reader
			fi
		fi
		_confok=1
	elif [[ ${_starting} -ne 0 ]]; then
		do_log warning "${_myname} start timeout reached after ${_time_active}s, running cleanup"
		_starting=0
		do_reader_cleanup
		echo "ping" >${conf[FIFO]}
	fi
}

udev_reader()
{
	trap 'trap_term_reader' SIGINT SIGTERM
	trap 'trap_hup_reader' SIGHUP

	# The reader process will read commands from the queue. When command is read some atomical stuff needs to be done
	# At the very least we should check for any running password workers, start worker process and keep track of them all.
	# Just like the daemon process the reader will run a cleanup timer and do cleanup every conf[CLEANUP_TIMER].
	local _pid_reader=${BASHPID} _myname="reader (${BASHPID}):" _time_start=$(do_timer) _time_active=0.000 _read_to __myname _cmd=() __waiting_mnt IFS
 	local _nr_cmds=0 _start_status=0 _cleanup=0.000 _pid_logwriter _key= _fd_fifo _pp _confok=0 _starting=${starting} _crypt_arr _crypt _dev _trim _time _res
	declare -A _pid_ppwrk _pid_putkey _pid_shell _waiting_mnt
	
	# Start logwriter with dedicated logfile when LOGLEVEL=2 or = 4. When level = 4 redirect out stdout and stderr to the logwriter.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && exec {fd_logwriter}> >(logwriter reader-${_pid_reader}.log {fd_daemon}>&-) 1>&${fd_logwriter} 2>&1 \
									  || exec {fd_logwriter}> >(logwriter reader-${_pid_reader}.log {fd_daemon}>&-)
		_pid_logwriter=$!
	fi
	do_log info "${_myname} initializing"
	[[ ${_starting} -eq 0 ]] && udevadm trigger -s block

	exec {_fd_fifo}<>${conf[FIFO]}
	while true; do
		# If we are starting up, read time-out when initial queue is empty so we can notify parent.
		# If we are in normal op, keep cleanup timer (60secs).
		do_log debug2 "${_myname} running since $(do_timer date ${_time_start})"
		time_active=$(do_timer ${time_start})

		# Rceived SIGHUP. Do a config reload (restart the reader), when no active workers.
		if [[ ${_starting} -eq 0 && ${_confok} -eq 1 && -z "${!_waiting_mnt[@]}" ]]; then
			do_reader_notify_daemon "reload"
			trap_term_reader
		fi

		# Evaluate the queue read timeout, to see at which point in time we are.
		[[ ${_confok} -eq 1 || ${time_active:0:-4} -gt $((${_cleanup:0:-4}+${conf[CLEANUP_TIMER]}-${conf[QUEUE_TIMEOUT]})) ]] && do_reader_cleanup
		[[ ${_confok} -eq 1 || ${_starting} -eq 1 ]] && _read_to=${conf[QUEUE_TIMEOUT]} \
													 || _read_to=$(((conf[CLEANUP_TIMER]+conf[QUEUE_TIMEOUT])-((${time_active:0:-4}+conf[CLEANUP_TIMER]/2)%conf[CLEANUP_TIMER])))
        
		# Start reading from the queue.
		unset IFS
		read -t${_read_to} -ru${_fd_fifo} -a _cmd
		_res=$?

		if [[ ${_res} -eq 142 ]]; then
			# Read timed out. Set the starting status if we are starting up, or run cleanup.
			# Cleanup will start after conf[START_TIMEOUT] to give all initial workers the chance to finish.
			[[ ${_starting} -ne 1 && ${_read_to##* } -gt $((conf[CLEANUP_TIMER]/2)) ]] && do_reader_cleanup
			if [[ ${_starting} -ne 0 ]]; then
				local __starting=${_starting}
				[[ -z "${!_waiting_mnt[@]}" ]] && _starting=0 || _starting=2
				[[ ${_starting} -eq 0 ]] && do_reader_cleanup 
				[[ ${__starting} != ${_starting} ]] && do_reader_notify_daemon "started ${_starting} ${_start_status}"
			fi
			continue
		elif [[ ${_res} -gt 128 ]]; then
			# Should not happen, only if we received signal during read.
			do_log debug "${_myname} read result ${_res} may have been trapped"
			[[ ${_cleanup} -eq 0 ]] && do_reader_cleanup
		elif [[ ${_res} -ne 0 || -z "${_cmd[@]}" ]]; then
			do_log error "${_myname} read error, terminating after $(do_timer ${_time_start})s"
			do_reader_notify_daemon "reload"
			trap_term_reader
		fi

		# Parse the command, the first element in the array is the command itself, the other elements the arguments to the command.
		# From UDEV we will receive add and remove commands with one paramter only, the disk.
		__myname="${_myname} ${_nr_cmds} -" __time_start=$(do_timer) _nr_cmds=$((_nr_cmds+1))
		do_log debug "${__myname} new command received \"${_cmd[@]}\""
		case ${_cmd[0],,} in
		add|change)
			_crypt_arr=($(do_xcrypt_fromtab "${__myname}" "${_cmd[@]:1}"))
			[[ ! -z "${_crypt_arr[@]}" ]] && do_reader_add_crypt;;
		remove)
			_crypt_arr=($(do_xcrypt_fromtab "${__myname}" "${_cmd[1]}"))
			[[ ! -z "${_crypt_arr[@]}" ]] && do_reader_notify_daemon "remove ${_crypt_arr[0]}";;
		passphrase)
			IFS=','
			for _key in ${_waiting_mnt[${_cmd[1]}]}; do
				IFS=' ' _crypt_arr=(${_key})
				do_log debug2 "${__myname} daemon can mount ${_crypt_arr[1]} as ${_crypt_arr[0]} TRIM ${_crypt_arr[2]} using ${_cmd[1]} passphrase, waited for $(do_timer ${_crypt_arr[3]})s"
				do_reader_notify_daemon "add ${_crypt_arr[0]} ${_crypt_arr[1]} ${_cmd[1]} ${_crypt_arr[2]}"
			done 
			unset _waiting_mnt[${_cmd[1]}] _pid_ppwrk[${_cmd[1]}]
			if [[ ${_starting} -ne 0 && -z ${!_waiting_mnt[@]} ]]; then
				_starting=0
				do_reader_cleanup
				do_reader_notify_daemon "started ${_starting} ${_start_status}"
			fi;;
		control|notify)
			case ${_cmd[2],,} in
			status)
				__waiting_mnt="" IFS=','
				for _pp in ${!_waiting_mnt[@]}; do for _key in ${_waiting_mnt[${_pp}]}; do
					IFS=' ' _crypt_arr=(${_key})
					do_log debug2 "${__myname} adding waiting crypt ${_crypt_arr[0]} to status report"
					__waiting_mnt+="${_pp}|${_crypt_arr[0]}|${_crypt_arr[1]}|${_crypt_arr[2]}|${_crypt_arr[3]},"
				done; done
				do_reader_notify_daemon "${_cmd[@]} ${__waiting_mnt}";;
			smart|erase|finished|add|del|put|rmkey)
				do_reader_notify_daemon "${_cmd[@]}";;
			shell)
				local _pid_socat=${_cmd[1]##*,}
				reader_control_shell &
				_pid_shell[${_cmd[1]}]=$!;;
			*) 
				do_log debug "${__myname} received invalid control command \"${_cmd[@]:2}\"";;
			esac;;
		ping)
			do_log debug2 "${__myname} pong";;
		*)
			do_log debug "${__myname} received invalid command: \"${_cmd[@]}\"";;
		esac
		do_log debug2 "${__myname} processing command \"${_cmd[@]}\" took $(do_timer ${__time_start})s total"
	done

	# We should never get here, exit with error if we do.
	do_log error "${_myname} terminated unexpectedly after $(do_timer ${_time_start})s"
	trap_term_reader
}

do_reader_add_crypt()
{
	# The add command received from UDEV will contain 1 argument, the block device that is added.
	# At least a mount worker for adding the cryptdisk A passphrase worker process is spawned if there is not already 
	# one running for the passphrase. We will keep a list of passhrase workers and mount workers using that passphrase.
	local _add_crypt="${_crypt_arr[0]}"  _add_dev="$(do_find_dev "${__myname}" "${_crypt_arr[1]}")" _add_pp="$(do_eval_pp "${_crypt_arr[2]}")" _add_trim="${_crypt_arr[3]}" _key="" _passphrase=""
	[[ ${_starting} -eq 1 ]] && _key="$(keyctl search @u user "${_add_pp}" 2>/dev/null)" && _passphrase="$(keyctl pipe "${_key}" 2>/dev/null)"
	
	# Set the variables for the crypt to be added, search for the backing device in conf[BLOCKDEVSDIRS].	
	do_log debug "${__myname} adding ${_crypt_arr[1]} as ${_add_crypt} TRIM ${_add_trim} using ${_add_pp} passphrase"
	if [[ -z "${_add_dev}" ]]; then
		do_log warning "${__myname} ${_crypt_arr[1]} not found in ${conf[BLOCKDEVSDIRS]}"
		[[ _start_status -eq 0 ]] && _start_status=2
		return
	elif [[ ! -z "${_key}" ]]; then
		do_log info "${__myname} found cached ${_add_pp} passphrase in user keyring"
		keyctl revoke "${_key}" 2>/dev/null
		keyctl unlink "${_key}" @u 2>/dev/null
		key_clnt "PUT" "${_add_pp}" "${_passphrase}" & _pid_putkey[${_add_pp}]=$!
		do_cache_pp "${_add_pp}" "${_passphrase}" "${__myname}"
		do_reader_notify_daemon "add ${_add_crypt} ${_add_dev} ${_add_pp} ${_add_trim}"
		return 
	elif [[ ! -z "$(keyctl request user "${_add_pp}" 2>/dev/null)" ]]; then
		# Passphrase is still cached, uotify the daemon about the crypt.
		do_log info "${__myname} found cached ${_add_pp} passphrase" 
		do_reader_notify_daemon "add ${_add_crypt} ${_add_dev} ${_add_pp} ${_add_trim}"
		return 
	elif grep -e "${_add_crypt} ${_add_dev} ${__app_trim} " <<<${_waiting_mnt[${_add_pp}]}; then
		# Check if crypt is already waiting
		do_log debug "${__myname} ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} already on waiting list"
		return
	fi

	# No worker and no passphrase cached, start new worker.
	do_log debug "${__myname} adding ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} to waiting list for ${_add_pp} passphrase"
	_waiting_mnt[${_add_pp}]+="${_add_crypt} ${_add_dev} ${_add_trim} $(do_timer),"
	do_log debug2 "${__myname} waiting mnt for ${_add_pp}: ${_waiting_mnt[${_add_pp}]:0:-1}"
	if [[ -z "${_pid_ppwrk[${_add_pp}]}" ]]; then
		do_log debug "${__myname} no cached passphrase or active worker for ${_add_pp}, starting"
		udev_reader_ppwrk {_fd_fifo}>&- {fd_daemon}>&- &
		_pid_ppwrk[${_add_pp}]=$!
	fi

	do_log debug2 "${__myname} ${_cmd[0],,} ${_crypt_arr[@]} took $(do_timer ${__time_start})s"
}

do_reader_notify_daemon()
{
	[[ -z "${__myname}" ]] && local __myname="${_myname}"
	echo "reader ${_pid_reader} $@" >&${fd_daemon}
	do_log debug "${__myname} sent message \"$@\" to daemon (PID: ${pid_daemon})"
}

do_reader_cleanup()
{
	# Reader cleanup routine. Check all the active workers, se if they're still running, terminate after timeout.
	local __myname="reader cleanup (${BASHPID}):" __time_start=$(do_timer) __waiting_mnt="" IFS=, _crypt_arr _pp _mnt
	_cleanup=$(do_timer ${time_start}) _time_active=$(do_timer ${_time_start})
	do_log debug "${__myname} cleanup starting at ${_time_active}"

	# Check logwriter status, restart if necessary.
	if [[ ! -z ${_pid_logwriter} ]]; then
		if [[ "$(cat /proc/${_pid_logwriter}/comm 2>/dev/null)" != "${MYNAME}" ]] || ! kill -0 ${_pid_logwriter} && kill -SIGKILL ${_pid_logwriter}; then
			[[ ${conf[LOGLEVEL]} -eq 4 ]] && exec {fd_logwriter}> >(logwriter reader-${_pid_reader}.log) {_fd_fifo}>&- 1>&${fd_logwriter} 2>&1 || exec {fd_logwriter}> >(logwriter reader-${_pid_reader}.log)
			do_log error "${__myname} logwriter (PID: ${_pid_logwriter}) terminated after ${_time_active}s, restarted"
			_pid_logwriter=$!
		fi
	fi

	# Cleanup shells.
	if [[ ! -z "${!_pid_shell[@]}" ]]; then for	_pp in ${!_pid_shell[@]}; do
		[[ "$(cat /proc/${_pid_shell[${_pp}]}/comm 2>/dev/null)" != "${MYNAME}" ]] && unset _pid_shell[${_pp}]
	done fi

	# Remove too long outstanding mounts and passphrase workers.
	for _pp in ${!_waiting_mnt[@]}; do
		for _mnt in ${_waiting_mnt[${_pp}]}; do
			IFS=" " _crypt_arr=(${_mnt})
			if [[ $(do_timer ${_crypt_arr[3]} |cut -d. -f1) -ge $([[ ${_starting} -eq 0 ]] && echo ${conf[PP_TIMEOUT]} || echo ${conf[START_TIMEOUT]}) ]]; then
				do_log debug "${__myname} cleanup removed waiting mount for ${_pp}: ${_crypt_arr[0]} - ${_crypt_arr[1]} - ${_crypt_arr[2]}"
			else
				do_log debug2 "${__myname} cleanup readded waiting mount for ${_pp}: ${_crypt_arr[0]} - ${_crypt_arr[1]} - ${_crypt_arr[2]}"
				__waiting_mnt+="${_crypt_arr[0]} ${_crypt_arr[1]} ${_crypt_arr[2]} ${_crypt_arr[3]},"
			fi
		done
		if [[ ! -z "${__waiting_mnt}" ]]; then
			_waiting_mnt[${_pp}]="${__waiting_mnt}"
		elif [[ -n "${_pid_ppwrk[S{_pp}]}" && "$(cat /proc/${_pid_ppwrk[${_pp}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_ppwrk[S{_pp}]}
			do_log debug "${__myname} killed passphrase worker for ${_pp} (PID: ${_pid_ppwrk[S{_pp}]})"
		else
			unset _waiting_mnt[${_pp}] _pid_ppwrk[${_pp}]
		fi
	done
	
	# Notify daemon we are still active.
	do_reader_notify_daemon "active"

	[[ -z "${!_pid_ppwrk[@]}" ]] && _pp="no active workers" || _pp="active workers for ${!_pid_ppwrk[@]}"	
	do_log debug2 "${__myname} cleanup done in $(do_timer ${__time_start})s, ${_pp}"
}

trap_term_ppwrk()
{
	trap 'do_log warning "${__myname unclean exit after $(do_timer ${__time_start})s"; exit 1' SIGINT SIGTERM

	# Kill the workers and exit.
	do_log debug2 "${__myname} terminating after $(do_timer ${__time_start})s"
	if [[ ! -z ${__pid_getpp} && "$(cat /proc/${__pid_getpp}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_getpp}
		wait ${__pid_getpp}
		do_log debug2 "${__myname} killed get worker (PID: ${__pid_getpp})"
	fi
	if [[ ! -z ${__pid_keyclnt} && "$(cat /proc/${__pid_keyclnt}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_keyclnt}
		wait ${__pid_keyclnt}
		do_log debug2 "${__myname} killed key client worker (PID: ${__pid_keyclnt})"
	fi
	if [[ ! -z ${__pid_querypp} && "$(cat /proc/${__pid_querypp}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_querypp}
		wait ${__pid_querypp}
		do_log debug2 "${__myname} killed query worker (PID: ${__pid_querypp})"
	fi
	if [[ ! -z "${__pid_logwriter}" && "$(cat /proc/${__pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_logwriter}
		wait ${__pid_logwriter}
		do_log debug2 "${__myname} killed log writer (PID: ${__pid_logwriter})"
	fi
	if [[ ! -z ${__pid_putkey} && "$(cat /proc/${__pid_putkey}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		[[ $1 -ne 0 ]] && kill -SIGTERM ${__pid_putkey}
		wait ${__pid_putkey}
		do_log debug2 "${__myname} killed put key worker (PID: ${__pid_putkey})"
	fi

	exit $1
}

udev_reader_ppwrk()
{
	trap 'trap_term_ppwrk' SIGINT SIGTERM

	# We need to get a passphrase. We will start a worker to get the passphrase from the boot servers
	# and a worker to ask for the passphrase using systemd-ask-password at the same time.
	# The workers will notify the daemon if they get a passphrase.
	local __pid_ppwrk=${BASHPID} __myname="passphrase:${_add_pp} (${BASHPID}):" __time_start=$(do_timer) __time_active

	if [[ $# -ne 0 ]]; then
		# Start key client, wait for a little bit if appropriate, start the query worker and wait.
		local __pid_keyclnt __pid_querypp __pid_getpp __pid_logwriter __pid_putkey
		if [[ ${conf[NET_ONLINE]} -eq 0 || "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ (online|partial)$ ]]; then 
			key_clnt "GET" "${_add_pp}" & __pid_keyclnt=$!
			do_log debug "${__myname} started key client (PID: ${__pid_keyclnt})"
			sleep $((2*conf[QUEUE_TIMEOUT])) & wait $!
		fi
		query_passphrase ${_add_pp} & __pid_querypp=$!
		do_log debug "${__myname} started query user (PID: ${__pid_querypp})"
		wait ${__pid_keyclnt} ${__pid_querypp}
		trap_term_ppwrk 0
	fi
		
	# Start a logwriter when LOGLEVEL = 2 or 4, redirect our stdout and stderr to that logwiter whenn level = 4.
	local __fd_up __fd_getpp __pid_getpp __pid_logwriter __pid_putkey __passphrase=""
	[[ ${FOREGROUND} -ne 1 && ${conf[LOGLEVEL]} -eq 2 ]] && exec {fd_logwriter}> >(logwriter passphrase-${_add_pp}-${__pid_ppwrk}.log)
	[[ ${FOREGROUND} -ne 1 && ${conf[LOGLEVEL]} -eq 4 ]] && exec {fd_logwriter}> >(logwriter passphrase-${_add_pp}-${__pid_ppwrk}.log) 1>&${fd_logwriter} 2>&1
	__pid_logwriter=$!
	do_log debug "${__myname} started"

	# When starting we will wait max PP_TIMEOUT for the network to come up, or fail.
	[[ ${conf[NET_ONLINE]} -eq 1 && ${_starting} -ne 0 ]] && until [[ "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ (online|partial)$ ]]; do
		sleep ${conf[QUEUE_TIMEOUT]} & wait $!
		__time_active=$(do_timer ${__time_start})
		[[ ${__time_active%%.*} -ge ${conf[PP_TIMEOUT]} || "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ offline$ ]] && break
	done

	# Start the worker to get the passphrase from the boot servers or from the user. fd 4 will point back to us.
	exec {__fd_getpp}< <(udev_reader_ppwrk 1 {__fd_up}>&1-)
	__pid_getpp=$!
	do_log debug "${__myname} started get passphrase worker (PID: ${__pid_getpp})"

	# We should get a pssphrase or an empty response from the workers or timeout.
	[[ ${_starting} -ne 0 ]] && __to=${conf[START_TIMEOUT]} || __to=${conf[PP_TIMEOUT]}
	if ! read -t${__to} -u${__fd_getpp} __passphrase; then
		do_log warning "${__myname} timeout after $(do_timer ${__time_start})s"
		trap_term_ppwrk 1
	fi

	# Put key (back) to servers, cache and send to reader.
	key_clnt "PUT" "${_add_pp}" "${__passphrase}" & __pid_putkey=$!
	do_cache_pp "${_add_pp}" "${__passphrase}" "${__myname}" || trap_term_ppwrk 1
	echo "passphrase ${_add_pp}" >${conf[FIFO]}

	do_log debug2 "${__myname} took $(do_timer ${__time_start})s"
	trap_term_ppwrk 0
}

reader_control_shell()
{
	trap 'trap_term_control' SIGINT SIGTERM 

	# Open a debug shell, will run under root so be careful with this.
	local __myname="reader-shell ${_nr_shell} (${BASHPID}:${__pid_ctrl},${_pid_socat}):" __time_start=$(do_timer)
	local __socat_PID __pid_logwriter="" __pid_ctrl="${_cmd[1]%%,*}" __sock_ctrl="${conf[CRYPTDISKSDDIR]}/${MYNAME}-${_cmd[1]%%,*}.sock"

	# Start logwriter with dedicated logfile when LOGLEVEL=2 or = 4. When level = 4 redirect out stdout and stderr to the logwriter.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]]	&& exec {fd_logwriter}> >(logwriter shell-${_pid_reader}.log {_fd_fifo}>&- {fd_daemon}>&-) 1>&${fd_logwriter} 2>&1 \
										|| exec {fd_logwriter}> >(logwriter shell-${_pid_reader}.log {_fd_fifo}>&- {fd_daemon}>&-)
		__pid_logwriter=$!
	fi
	
	if [[ ! conf[DEBUGSHELL] -eq 1 ]]; then
		do_log error "${__myname} debug shell not enabled"
		kill -SIGTERM ${__pid_ctrl}
		trap_term_control 1
	fi
	
	# Open a connection to the listening socket. Check if it exists first.
	set +m
	TERM=xterm socat exec:"/bin/zsh --login",pty,stderr,sigint,setsid,sane UNIX-CONNECT:${__sock_ctrl} & __socat_PID=$!
	do_log warning "${__myname} debug shell started"
	wait ${__socat_PID}
	do_log warning "${__myname} debug shell ended"
	trap_term_control 0
}

# [END OF UDEV QUEUE READER FUNCTIONS]

# [START OF UDEV PROCESSING FUNCTIONS]

do_cryptdisksd_udev()
{
	[[ -z "${conf[FIFO]}" ]] && conf[FIFO]=/run/${MYNAME}/${MYNAME}.queue

	# Parse the udev command line and prepare the message to be put on the queue. Udev can only be run by root.
	if [[ ${UID} -ne 0 || -z "${ACTION}" ]]; then
		echo "${MYNAME} udev queue can only be started from udev"
		exit 1
	fi

	# Prepare the message, first check if there is a confdir specified on command line, or load from systemd if not so.
	local msg="${ACTION}" command=udev
	if [[ -z "${CONFDIR}" ]]; then
		local _t="$(grep -ie "^CONFDIR=\/" /etc/systemd/${MYNAME}.conf)"
		CONFDIR="${_t##*=}"
	fi
	shift
	
	# Enter a loop to check if any of the arguments specified is a command, error exit if so, add parameter to message if ok.
	while [[ ! -z "$1" ]]; do
		do_parse_opt $@
		[[ $? -eq 0 ]] && msg+=" $1" || logger -p daemon.error "${MYNAME} cannot name crypt or dev \"$1\""
		shift
	done

	# Put the message (if any) on the queue.
	[[ "${msg}" == "${ACTION}" ]] && exit 1 || echo "$@" >${conf[FIFO]} 
}

# [END OF UDEV PROCESSING FUNCTIONS]

# [START OF INTERACTIVE CONTROL FUNCTIONS]

do_echo_use()
{
	[[ -z "${conf[RUNDIR]}" ]] && { do_init_conf || echo -e "${RED}${MYNAME}, Error Loading Configuration from ${CONFDIR}${NOR}"; }
	echo -e "${GREY}${BOLD}${MYNAME} (Encrypted Block Device Manager)${NOR}\n"
	case $1 in
	status)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tDisplays Status of Encrypted Block Devices"
		echo -e "\t\t\t\tCommand Has no Options or Arguments\n";;
	stop)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tStops the Encrypted Device Manager"
		echo -e "\t\t\t\tCommand Has no Options or Arguments\n";;
	reload)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tReloads the Configuration of the Encrypted Device Manager"
		echo -e "\t\t\t\tCommand Has no Options or Arguments\n";;
	add)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tAdd an Encrypted Block Device to the Manager\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hct ] { crypt | device } || { -p passphrase crypt device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-c${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
		echo -e "\t${BOLD}-p {passphrase}${NOR}\tUse {passphrase} for Crypt"
		echo -e "\t${BOLD}-t${NOR}\t\tEnable TRIM for Crypt\n\n"
		echo -e "The $1 Command Can Be Used it Two Ways.\nThe First ( ${BOLD}[ -c ] { crypt | device }${NOR} ) Will Add a Crypt or Device Which is Already on the Crypttab"
		echo -e "The Second ( ${BOLD}[ -c ] { -p passphrase crypt device }${NOR} ) Will Add a crypt (and Corresponding Backing Device) to the Crypttab\nThe Option '${BOLD}-p passphrase${NOR}' Must Be Specified in the Second Case\n"
		echo -e "The Options and Arguments Can Be Specified in any Order"
		echo -e "${BOLD}${UL}${MYNAME} $1 -p passphrase crypt device${NOR}\tand\t${BOLD}${UL}${MYNAME} $1 crypt -c\n${MYNAME} $1 crypt -c device -p passphrase${NOR}\tand\t${BOLD}${UL}${MYNAME} $1 -t device -p passphrase crypt -c${NOR}"
		echo -e "Are All Valid $1 Command Specifications\n"			
		echo -e "The ${MYNAME} Will Look for Block Devices in \"${BOLD}${conf[BLOCKDEVSDIRS]}${NOR}\"\n";;
	del)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tRemove an Encrypted Block Device from the Manager\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -htc ] { crypt | device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-c${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
		echo -e "\t${BOLD}-t${NOR}\t\tRemove the crypt (and Corresponding Backing Device) from the Crypttab\n\n"
		echo -e "The Options and Arguments Can Be Specified in any Order\n";;
	put)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tPut Key File to Boot Servers\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hc ] passphrase${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-s${NOR}\t\tPut key to specified servers"
		echo -e "\t${BOLD}-c${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions\n"
		echo -e "With -s a server can be specified and this may occur more than once.\nIt may only occur once without server to put key to all servers."
		echo -e "Multiple servers can be specified with , as separator."
		echo -e "${BOLD}${UL}(\"-s\" and \"-s server1 -s server2,server3\" are valid but \"-s -s server1\" or \"-s server1 -s\" are not.)${NOR}";;
	rmkey)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tRemove Key File from Firmware and/or Boot Servers\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hckfs ] { passphrase }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-c${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
		echo -e "\t${BOLD}-k${NOR}\t\tRemove key only from keyring"
		echo -e "\t${BOLD}-f${NOR}\t\tRemove key only from firmware"
		echo -e "\t${BOLD}-s${NOR}\t\tRemove key only from servers\n"
		echo -e "The option -c is a confirmation flag, when no other options are specified\nit disables confirmation, enables confirmation otherwise.."
		echo -e "The options -s -f -k can be combined to remove key from these places only."
		echo -e "With -s a server can be specified and this may occur more than once.\nIt may only occur once without server to remove from all servers."
		echo -e "Multiple servers can be specified with , as separator."
		echo -e "${BOLD}${UL}(\"-s\" and \"-s server1 -s server2,server3\" are valid but \"-s -s server1\" or \"-s server1 -s\" are not.)${NOR}"
		echo -e "${BOLD}${MYNAME} { passphrase }${NOR}\t\t- without any option removes key from everywhere asking for confirmation each step."
		echo -e "${BOLD}${MYNAME} -c { passphrase }${NOR}\t\t- removes key from everywhere not asking for confirmation."
		echo -e "${BOLD}${MYNAME} -c -k -f { passphrase }${NOR}\t- removes key from specified locations asking for confirmation."
		echo -e "${BOLD}${MYNAME} -k -f { passphrase }${NOR}\t- removes key from specified locations not asking for confirmation.";;
	smart)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tShow S.M.A.R.T. Information for Backing Device\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hax ] {crypt | device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-a|-x${NOR}\t\tShow all S.M.A.R.T. information (Only Atrributes Otherwise)"
		echo -e "\t${BOLD}-t${NOR}\t\tRun S.M.A.R.T. Long Self Test on Device\n";;
	erase)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tSecure Erase Device\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h ] {crypt | device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text";;
	*)
		echo -e " Usage:\n\t${BOLD}${MYNAME} { [ -hdf ] ${UL}COMMAND ...${NOR} }\n"
		echo -e "\tEncrypted Block Devices Manager, Command Line Requires at Least one Option or Command"
		echo -e "\tMultiple Commands May Be Specified in Order, Commands Can Have Multiple Options and Arguments"
		echo -e "\tAll Commands Options and Arguments Are cAsE iNSensItiVe, except for ${UL}Device Names${NOR}\n"
		echo -e "\tUse ${UL}${BOLD}${MYNAME} command -h${NOR} To Display Help for That Command${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-d${NOR}\t\tSet Configuration Directory (${BOLD}${UL}Default: /etc/${MYNAME:0:-1}.d${NOR})"
		echo -e "\t${BOLD}-f${NOR}\t\tRun in Foreground (Debug) Mode. Can Only be Started by root."
		echo -e "\n\n Commands:\n\t${BOLD}status${NOR}\t\tDisplays Status of Encrypted Block Device Manager"
		echo -e "\t${BOLD}smart${NOR}\t\tDisplay S.M.A.R.T. Status of Encrypted Block Device" 
		echo -e "\t${BOLD}erase${NOR}\t\tSecure Erase Encrypted Block Device" 
		echo -e "\t${BOLD}stop${NOR}\t\tStop the Encrypted Device Manager" 
		echo -e "\t${BOLD}reload${NOR}\t\tReload the Configuration of the Encrypted Device Manager" 
		echo -e "\t${BOLD}add${NOR}\t\tAdd Encrypted Block Device to Manager" 
		echo -e "\t${BOLD}del${NOR}\t\tDelete Encrypted Block Device from Manager" 
		echo -e "\t${BOLD}put${NOR}\t\tPut Keyfile (Passphrase) to Boot Servers" 
		echo -e "\t${BOLD}rmkey${NOR}\t\tRemove Keyfile (Passphrase) from Firmware\n";;
	esac
	exit 127
}

do_parse_opt()
{
	# Parse command line options (-h -d -f). Function is run from main cli to parse as first options given.
	# Function can also run from the parse cmds function, it that case only -d option can be valid.
	local opt; OPTIND=1; getopts :fFd:D:hHcCaAxXkKsSp:P:tT opt
	opt="${opt,,}"
	case ${opt} in
	h|:) # if -h is specified as a command line option echo usage for the command running if run from parse cmds.
		do_echo_use "${command}";;
	a|x) # Option for smart -x
		[[ ${cmd} -eq 0 || ! "${command,,}" == "smart" ]] && do_echo_use "${command}"
		smartall=1
		return 1;;
	c) # Option to ask for confirmation for non critical actions.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(add|del|put|rmkey)$ ]] && do_echo_use "${command}"
		[[  ${confirm} -eq 1 ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		confirm=1
		return 1;;
	k) # Option to remove key from firmware.
		[[ ${cmd} -eq 0 || ! "${command,,}" == "rmkey" || ${key} -eq 1 ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		key=1
		return 1;;
	p) # Option to specify a passphrase name for the new crypt to be added to the crypttab.
		[[ ${cmd} -eq 0 || ! "${command,,}" == "add" ]] && do_echo_use "${command}"
		[[  ${crypttab} -eq 1 ]] && do_echo_use "${command}"
		crypttab=1
		add_pp="${OPTARG}"
		return $((OPTIND-1));;
	s) # Option to remove key from boot servers. We keep _srv to track how option is used
	   # 1 for first time option is encountered, 2 for consecutive. May only contain server names when it occurs more than once.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(put|rmkey)$ ]] && do_echo_use "${command}"
		[[ ${srv} == "1" || ${_srv} -eq 1 ]] && do_echo_use "${command}"
		[[ -z "${srv}" ]] && _srv=1 srv=1 || _srv=2
		return 1;;
	t) # Option trim enable foor add, remove crypt from crypttap for del command. Or Run smart self test.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(add|del|smart)$ ]] && do_echo_use "${command}"
		if [[ "${command}" == "add" ]]; then
			[[ ${add_trim} -eq 1 ]] && do_echo_use "${command}"
			add_trim=1
			return 1
		elif [[ "${command}" == "del" ]]; then
			[[  ${crypttab} -eq 1 ]] && do_echo_use "${command}"
			crypttab=1
			return 1
		elif [[ "${command}" == "smart" ]]; then
			[[  ${smarttest} -eq 1 ]] && do_echo_use "${command}"
			smarttest=1
			return 1
		fi;;
	d) # Set configuration directory. If no dir specified echo usage. Option is only valid for global, not for command.
		[[ ${cmd} -eq 1 ]] && do_echo_use "${command}"
		[[ ! -d ${OPTARG} ]] && echo "Configuration Directory ${OPTARG} Does not Exist"
		[[ ! -d ${OPTARG} || ${_conf} -ne 0 ]] && do_echo_use "${command}"
		_conf=1
		CONFDIR=${OPTARG}
		# Shift the parameters and check if more arguments specified, continue with processing options if so.
		[[ $# -ge ${OPTIND} ]] && return $((OPTIND-1))
		shift $((OPTIND-1));;
	f) # Flag to run in foreground mode. Option to remove key from firmware.
		[[ ( ${cmd} -eq 1 && ! "${command,,}" == "rmkey" ) || ${FOREGROUND} -eq 1 ]] && do_echo_use "${command}"
		if [[ "${command}" == "rmkey" ]]; then
			[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
			[[ ${fw} -eq 1 ]] && do_echo_use "${command}"
			fw=1
			return 1
		fi
		FOREGROUND=1
		# If there are more options continue parsing. -f can only be followed by -d.
		shift
		[[ ! -z "$1" ]] && return 1;;
	?) # If run from parse cmds function, we need to check if the option specified matches a known command.
	   # If that is the case we have reached the end of the current command and can start processing the next.
		if [[ ${cmd} -eq 1 || ${_srv} -ge 1 ]]; then
			if [[ ! -z "$1" ]]; then 
				if ! do_parse_cmd check $1; then
					next_cmd=1
				else
					# We may get here if rmkey command contains -s server options. Check here if it was specified without server before.
					[[ ${_srv} -eq 2 && ${srv} == 1 ]] && do_echo_use "${command}"
					if [[ ${_srv} -ge 1 ]]; then
						[[ ${srv} == "1" ]] && srv=""
						srv+="${!OPTIND}," _srv=0
						shift
						return 1
					fi
					shift
				fi
			else
				# If there are no more arguments set to process next command, which will be none.
				next_cmd=1
			fi
		fi;;
	esac

	# Check rmkey server option for validity. If -s server was specified before and now only -s this is an error and we catch it here.
	[[ ${opt} != s && ${_srv} -eq 2 ]] && do_echo_use "${command}"
	[[ ${opt} != s && ${_srv} -eq 1 ]] && _srv=0

	# All options are evaluated or confdir specified, initialize the configuration.
	if [[ ( ${cmd} -eq 0 && ( ${_conf} -eq 1 || -z "$1" ) ) || ( ${cmd} -eq 1 && ${_conf} -eq 0 ) ]]; then
		if ! do_init_conf; then
			echo "Error loading configuration from ${CONFDIR}"; exit 1
		else
			_conf=1
		fi
	fi

	# If foreground mode was requested execute. Echo command usage if specified in wrong place.
	if [[ ${FOREGROUND} -eq 1 ]]; then
		# If -f is not first option specified, it must be last (after -d) and no more options can be present.
		[[ ${nr} -gt 1 && ! -z "$1" ]] && do_echo_use "${command}"
		# Start in debug/foreground mode.
		if [[ ${UID} -ne 0 && $# -le 1 ]]; then
			echo "cryptdisksd daemon foreground can only be started as root"; exit 1
		fi
		echo "loglevel=${conf[LOGLEVEL]}"
		do_systemd_start
		exit $?
	fi

	# Return 1 if next command is found, 0 otherwise.
	[[ ${next_cmd} -eq 1 ]] && return 1
	return 0
}

do_parse_cmd()
{
	# Parse the commands specified on the command line, one by one. If called with check, then return 1 on match.
	# This is to let the parse opt function know a match for a new command has been found.
	local command="${1,,}" check
	if [[ "${command}" == "check" ]]; then 
		shift
		command="${1,,}" check=1;
	fi
	case ${command} in
	udev)
		[[ ${check} -eq 1 ]] && return 1
		do_cmd_parseopt $@
		do_cryptdisksd_udev $@
		return $#;;
	stop)
		[[ ${check} -eq 1 ]] && return 1
		do_cmd_parseopt $@
		/bin/kill -SIGTERM $(cat ${conf[PIDFILE]})
		return $#;;
	reload)
		[[ ${check} -eq 1 ]] && return 1
		do_cmd_parseopt $@
		/bin/kill -SIGHUP $(cat ${conf[PIDFILE]})
		return 1;;
	status|shell|add|del|put|rmkey|smart|erase)
		[[ ${check} -eq 1 ]] && return 1
		do_cryptdisksd_cmd $@
		return $?;;
	*)
		[[ ${check} -ne 1 ]] && do_echo_use "${command}"
		return 0;;
	esac
	return 0
}

do_cmd_parseopt()
{
	# If there are more arguments to process, check for command options or or for a new command to be processed.
	local next_cmd=0 res s=0 _srv=0
	shift
	while [[ ${next_cmd} -eq 0 ]]; do
		do_parse_opt $@
		res=$? 
		if [[ ${res} -eq 0 ]]; then
			msg+="$1 "
			shift
			s=$((s+1))
		else
			shift ${res}
			s=$((s+res))
		fi
	done
	return ${s}
}

trap_term_cryptdisksd_cmd()
{
	trap 'echo "${RED}${MYNAME} unclean finish${NOR}"; exit 1' SIGINT SIGTERM

	# Kill socat coproc if still active and remove the socket if still present. Restore stdin to the tty.
	if [[ ! -z "${pid_socat}" && "$(cat /proc/${pid_socat}/comm 2>/dev/null)" == "socat" ]]; then
		kill -SIGTERM ${pid_socat}
		[[ ${conf[LOGLEVEL]} -gt 2 ]] && echo -e "\rKilled ${pid_socat}"
	fi
	if [[ -e ${conf[CRYPTDISKSDDIR]}/${sock} ]]; then
		rm -f ${conf[CRYPTDISKSDDIR]}/${sock}
		echo -e "\rRemoved ${conf[CRYPTDISKSDDIR]}/${sock}\r\n"
	fi
	exec 0<&${stdin}-
	stty sane
	echo -e "${NOR}\r"
	exit 1
}

do_cryptdisksd_cmd()
{
	trap 'trap_term_cryptdisksd_cmd' SIGINT SIGTERM

	# Request status from daemon. Detach stdin and assign it to socat coproc, which will attach it to daemon stdout.
	if [[ ! "$(NOTIFY_SOCKET= systemctl is-active ${MYNAME:0:-1}.service 2>&1)" =~ activating|active ]]; then
		echo "${MYNAME} not Running"
		exit 1
	fi
	
	# Parse the options to the command and store the nr. of paramters to shift in s.
	local crypttab=0 confirm=0 smartall=0 smarttest=0 key=0 fw=0 srv="" add_pp="" add_trim=0 msg="$1 " stty_opt="" s sock pid_socat
	do_cmd_parseopt $@
	s=$? sock=${conf[CRYPTDISKSDDIR]}/${MYNAME}-${BASHPID}.sock

	case ${command} in
	add)
		if [[ ${crypttab} -eq 1 ]]; then
			[[ $(wc -w <<<"${msg}") -ne 3 ]] && do_echo_use "${command}"
		else
			[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		fi
		msg+="${add_pp} ${add_trim} ${confirm} ${crypttab}"
		stty_opt="raw -echo isig";;
	del)
		[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		msg+="${confirm} ${crypttab}"
		stty_opt="raw -echo isig";;
	status)
		[[ $(wc -w <<<"${msg}") -ne 1 ]] && do_echo_use "${command}"
		stty_opt="raw -echo isig";;
	smart)
		[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		msg+="${smartall} ${smarttest}"
		stty_opt="-echo isig";;
	put)
		[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		[[ -z "${srv}" ]] && srv=0
		msg+="${confirm} ${srv}"
		stty_opt="raw -echo isig";;
	rmkey)
		[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		[[ -z "${srv}" ]] && srv=0
		msg+="${confirm} ${key} ${fw} ${srv}"
		stty_opt="raw -echo isig";;
	shell)
		[[ $(wc -w <<<"${msg}") -ne 1 ]] && do_echo_use "${command}"
		stty_opt="raw -echo -isig";;
	*)
		[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		msg+="${confirm}"
		stty_opt="raw -echo isig";;
	esac

	# Set tty options, redirect STDIN
	stty ${stty_opt}
	local stdin
	exec {stdin}<&0-

	[[ ${conf[LOGLEVEL]} -gt 2 ]] && echo -e "Requesting \"$@\" \"${msg}\" from ${MYNAME}\r"

	# Start socat in background and attach stdin, listen on a socket in RUNDIR. 
	# The daemon will spawn a worker which will connect and start interactive session.
	socat -t1 - UNIX-LISTEN:${sock},unlink-early,unlink-close,group=${conf[CRYPTDISKSD_GROUP]},mode=600 0<&${stdin}- &
	pid_socat=$!
	# Notify the daemon to connect to the socket and wait until it's finished. Then restore stdin and exit.
	sleep .05
	echo "control ${BASHPID},${pid_socat} ${msg}" >${conf[FIFO]}
	wait ${pid_socat}

	# Restore stdin, remove socket and exit.
	exec 0<&${stdin}-
	stty sane
	[[ -e ${sock} ]] && rm -f ${sock}

	[[ ${conf[LOGLEVEL]} -gt 3 ]] && echo "Done requesting \"$@\" from ${MYNAME}"
	return ${s}
}

# [END OF INTERACTIVE CONTROL FUNCTIONS]

# [BEGIN OF EXECUTION FUNCTIONS]

do_systemd_start()
{
	# Check if we are started from systemd (PID 1).
	[[ ( ! "${UID}" -eq 0 || ! ${PPID} -eq 1 ) && ${FOREGROUND} -eq 0 ]] && do_echo_use
	local myname="daemon (${BASHPID}):" hostname="$(hostname)" pid_daemon=${BASHPID} starting=1 start_status=0 time_start=$(do_timer)
	local systemdconf="" crypttab="" pid_logwriter fd_logwriter fd_journal

	# Close stdin, fd3 to stdout (systemd journald) for reader and worker processes. Redirect stdout and stderr to /dev/null.
	# If we are running in foreground mode evrything goes to stdout of the user's terminal. And we wish him or her good luck with that.
	[[ ${FOREGROUND} -ne 1 ]] && exec 0>&- {fd_journal}>&1- 1>/dev/null 2>&1
	[[ ${FOREGROUND} -eq 1 ]] && exec {fd_logwriter}>&1 {fd_journal}>&${fd_logwriter}

	# Load config and start new key session and link the user key ring to the session key ring. On boot keys will be cached in user key ring. 
	set -m
	keyctl new_session
	keyctl link @u @s
	if ! do_init_conf; then
		systemd-notify STOPPING=1 --pid=$$ --status="cryptdisksd: Cannot Initialize Config" 
		systemd-notify --ready --pid=$$
		exit 0
	fi

	# Start the logwriter.
	[[ ${FOREGROUND} -ne 1 ]] && do_daemon_start_logwriter
	do_log info "${myname} initializing"

	# Here we go, we are started from systemd. We will first process to queue entirely and notify systemd if we're done.
	# The daemon and queue reader are recursive processes. They will re-enter themselves after processing a command. 
	# The reader spawns worker processes to get passphrases and the daemon will mount the actual cryptdisks. 
	# A cleanup will be run every minute. There we will detect if configuration has changed and remove timed out workers and mounts.
	[[ ${conf[DEBUGSHELL]} -eq 1 ]] && set -a
	echo ${pid_daemon} >${conf[PIDFILE]}

	# Check if the queue exists first, exit with error if it isn't. It should be there, or something is wrong with socket.
	if [[ ! -p ${conf[FIFO]} ]]; then
		do_log error "${myname} queue not found" 
		systemd-notify STOPPING=1 --pid=$$ --status="cryptdisksd: Queue not Found, Restart cryptdisksd.socket" 
		systemd-notify --ready --pid=$$
		exit 0
	fi

	# Parse and load the configuration, exit if either fails.
	if ! do_daemon_check_conf; then 
		do_log error "${myname} failed to load config" 
		systemd-notify STOPPING=1 --pid=$$ --status="cryptdisksd: Failed to Load Configuration"
		systemd-notify --ready --pid=$$
		exit 0
	fi

	# Check if there is a crypttab, log message if there isn't since everything we do is based on it.
	if [[ ! -f ${conf[CRYPTTAB]} ]]; then
		echo -e "#Crypt\t\t\t#Device\t\t\t\t#Passphrase\t\t#TRIM" >${conf[CRYPTTAB]}
		do_log warning "${myname} crypttab not found" 
		systemd-notify --pid=$$ --status="cryptdisksd: Crypttab (${conf[CRYPTTAB]}) not Found"
		start_status=2
	fi

	systemd_daemon
}

do_cryptdisksd_cli()
{
	local nr=$# cmd=0 _conf=0 res
	# Enter a loop to evaluate all command line options and commands specified.
	while true; do
		# Parse options, the return code will be the nr of parameters to shift or 0 if all options parsed.
		# Continue with processing commands fase if all options parsed.
		if [[ ${cmd} -eq 0 ]]; then 
			do_parse_opt $@
			res=$?
			shift ${res}
			[[ ${res} -ne 0 ]] && continue
		fi
		# Command line options are parsed, evaluate and execute commands specified. Return code will be nr of arguments to shift.
		# If after shifting there are no more commands to process we can exit.
		cmd=1
		do_parse_cmd $@
		res=$?
		shift ${res}
		[[ -z "$1" ]] && return 0
	done
}

MYNAME="$(basename $0)" FOREGROUND=0 PATH=/bin:/sbin
[[ ! -z "${LC_NUMERIC}" ]] && unset LC_NUMERIC

# Check if we're started interactively (options must be specified) or from systemd (run without any options from PID 1).
if [[ $# -eq 0 ]]; then
	# No command line options specified. check if we're started from systemd, start daemon if so.
	do_systemd_start
	exit 1
else
	# Command line options present, run in interactive mode.
	do_cryptdisksd_cli $@
	# Exit if there are no more commands to execute.
	exit $?
fi

# [END OF EXECUTION FUNCTIONS]

# We should never get here, error exit if we do.
echo "${MYNAME} Reached End of the Line, Bye Bye"
exit 1
