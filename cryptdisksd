#!/bin/bash

# Function Definitions. All functions for serialized commands shall have their nemae prefixed by do_ all others shall not.

do_init_conf()
{
	# Initialize System Variables. Default config in /etc/cryptdisks.d/cryptdisksd.conf. Systemd env CONF(DIR) will override.
	[[ -z "${CONFDIR}" ]] && CONFDIR="/etc/${MYNAME:0:-1}.d"
	[[ ! -d "${CONFDIR}" ]] && return 1
	[[ -z "${CONF}" ]] && CONF="${CONFDIR}/${MYNAME}.conf"
	unset conf
	declare -gA conf bootconf
	if [[ -s ${CONF} ]]; then
		local __var __val
		while IFS="=" read -r __var __val; do
			[[ ! -z "${__val}" ]] && conf[${__var^^}]="${__val}"
	   	done <<<"$(cat ${CONF} |grep -ve "^\s*#")"
	fi
	[[ -z "${conf[LOGLEVEL]}" ]] && conf[LOGLEVEL]=0
	[[ -z "${conf[DEBUGSHELL]}" ]] && conf[DEBUGSHELL]=0
	[[ -z "${conf[RUNDIR]}" ]] && conf[RUNDIR]="/run"
	[[ -z "${conf[LOGDIR]}" ]] && conf[LOGDIR]="/var/log/${MYNAME}"
	[[ -z "${conf[LOGFILE]}" ]] && conf[LOGFILE]="/var/log/${MYNAME}.log"
	[[ -z "${conf[CRYPTDISKSDDIR]}" ]] && conf[CRYPTDISKSDDIR]=${conf[RUNDIR]}/${MYNAME}
	[[ -z "${conf[PIDFILE]}" ]] && conf[PIDFILE]="${conf[CRYPTDISKSDDIR]}/${MYNAME}.pid"
	[[ -z "${conf[CRYPTDISKSD_GROUP]}" ]] && conf[CRYPTDISKSD_GROUP]="disk"
	[[ -z "${conf[CRYPTDISKSDDIR_MODE]}" ]] && conf[CRYPTDISKSDDIR_MODE]=700
	[[ -z "${conf[FIFO]}" ]] && conf[FIFO]="${conf[CRYPTDISKSDDIR]}/${MYNAME}.queue"
	[[ -z "${conf[FIFO_MODE]}" ]] && conf[FIFO_MODE]=600
	[[ -z "${conf[CRYPTTAB]}" ]] && conf[CRYPTTAB]="${CONFDIR}/crypttab"
	[[ -z "${conf[BLOCKDEVSDIRS]}" ]] && conf[BLOCKDEVSDIRS]="/dev/disk/by-id"
	[[ -z "${conf[START_TIMEOUT]}" ]] && conf[START_TIMEOUT]=5
	[[ -z "${conf[LOCK_TIMEOUT]}" ]] && conf[LOCK_TIMEOUT]=5
	[[ -z "${conf[PP_TIMEOUT]}" ]] && conf[PP_TIMEOUT]=3
	[[ -z "${conf[QUEUE_TIMEOUT]}" ]] && conf[QUEUE_TIMEOUT]=2
	[[ -z "${conf[KEYLIFE]}" ]] && conf[KEYLIFE]=10
	[[ -z "${conf[CLEANUP_TIMER]}" ]] && conf[CLEANUP_TIMER]=60
	[[ -z "${conf[FWDIR]}" ]] && conf[FWDIR]="/sys/firmware/efi/efivars"
	[[ -z "${conf[FWGUID]}" ]] && conf[FWGUID]="ca25478a-acb8-44ac-8c55-d5d45dfe25c5"
	[[ -z "${conf[FWBOOTCONF]}" ]] && conf[FWBOOTCONF]="${conf[FWDIR]}/UglyLinuxBootCFG-${conf[FWGUID]}"
	[[ -z "${conf[BOOTCONF]}" ]] && conf[BOOTCONF]="${CONFDIR}/boot.conf"
	[[ -z "${conf[NET_ONLINE]}" ]] && conf[NET_ONLINE]=1
	[[ -z "${conf[USER_TIEMOUT]}" ]] && conf[USER_TIMEOUT]=10
	conf[START_TIMEOUT]=$((conf[START_TIMEOUT]*60))
	conf[PP_TIMEOUT]=$((conf[PP_TIMEOUT]*60))
	conf[KEYLIFE]=$((conf[KEYLIFE]*60))

	# Initialize formatting parameters for console output.
	RED="\033[91m" GREY="\033[94m" YEL="\033[93m" GRN="\033[92m" BOLD="\033[1m" UL="\033[4m" NOR="\033[0m" RES="\0332J"
	PR="\033[s" PD="\033[u\033[16C\033[s" PE="\033[u\033[62C\033[s" PP="\033[u\033[6C\033[s" PT="\033[u\033[22C\033[s" PS="\033[u\033[21C"
}

# [BEGIN OF LOGGING FUNCTIONS]

trap_term_logwriter()
{
	trap 'logger -p daemon.warning "cryptdisksd: ${_myname} unclean finish after $(do_timer ${_time_start})s"; exit 1' SIGINT SIGTERM

	# When the log writer is killed, set the read timeout to 1s (no exit) to allow the writer to parse remaining log messages.
	local _date="$(date '+%d-%m %H:%M:%S.%3N')"
	logger -p daemon.info "cryptdisksd: ${_myname} terminating"
	[[ ${conf[LOGLEVEL]} -gt 0 ]] && echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${_myname} terminating after $(do_timer ${_time_start})s" >>${conf[LOGFILE]}
	exit 0
}

logwriter()
{
	trap 'trap_term_logwriter' SIGINT SIGTERM

	# The log write will parse lines from stdin, sent by various workers. The lines are written to log and sent to syslog.
	local _myname="logger (${BASHPID}):" _time_start=$(do_timer) _lf _line

	# Initialize the log file. Set the correct access rights.
	[[ ! -d ${conf[LOGDIR]} ]] && mkdir -p ${conf[LOGDIR]}
	chgrp ${conf[CRYPTDISKSD_GROUP]} ${conf[LOGDIR]}
	chmod 750 ${conf[LOGDIR]}
	if [[ ! -z "$1" ]]; then
		conf[LOGFILE]=${conf[LOGDIR]}/$1
		touch ${conf[LOGFILE]}
	fi
	chgrp ${conf[CRYPTDISKSD_GROUP]} ${conf[LOGFILE]}
	chmod 640 ${conf[LOGFILE]}
	[[ ${conf[LOGLEVEL]} -gt 0 ]] && echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${_myname} initialized" >>${conf[LOGFILE]}

	# Prepend every line recieved with date and time and write to logfile.
	while read -r _lf _line; do
		local _date="$(date '+%d-%m %H:%M:%S.%3N')"
		if [[ "${_lf}" == "debug" && ${conf[LOGLEVEL]} -ge 1 ]]; then
			echo "${_date} ${hostname} ${_line}" >>${conf[LOGFILE]}
		elif [[ "${_lf}" == "debug2" && ${conf[LOGLEVEL]} -ge 3 ]]; then
			echo "${_date} ${hostname} ${_line}" >>${conf[LOGFILE]}
		elif [[ ${_lf} == "info" || ${_lf} == "warning" || ${_lf} == "error" ]]; then
			logger -p daemon.${_lf} "cryptdisksd: ${_line}"
			[[ ${conf[LOGLEVEL]} -ge 1 ]] && echo "${_date} ${hostname} ${_line}" >>${conf[LOGFILE]}
		elif [[ ${conf[LOGLEVEL]} -ge 3 ]]; then
			echo "${_date} ${hostname} ${_lf} ${_line}" >>${conf[LOGFILE]}
		fi
	done
	echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${_myname} terminating after $(do_timer ${_time_start})s ($?)" >>${conf[LOGFILE]}
}

do_log()
{
	# Send a message to the log writer, or to systemd if that fails.
	echo "$@" >&${fd_logwriter} || echo "$@" >&${fd_journal}
}

do_timer()
{
	# Start a timer for debugging purposes. We will track to the ms.
	if [[ $# -eq 0 ]]; then
		# Started with no args, start a timer, echo the start time.
		echo ${EPOCHREALTIME:0:-3}
	elif [[ ${1,,} == "date" ]]; then
		# Output the exact date of the timestamp.
		local ___date="$(date --date @$2 +%Y-%m-%d.%H:%M:%S)"
		echo "${___date}"
	else
		# Started with start time as args, calculate and echo the time difference.
		local ___stime=$1
		local ___etime=${EPOCHREALTIME:0:-3}
		local ___dtime="$(bc <<<"x=${___etime}-${___stime}; if (x<1) print 0; x")"
		echo "${___dtime}"
	fi
}

# [END OF LOGGING FUNCTIONS]

# [BEGIN OF MAIN DAEMON FUNCTIONS]

trap_term_daemon()
{
	trap 'systemd-notify --pid=$$ --status="cryptdisksd: unclean finish after $(do_timer ${time_start})s"; exit 1' SIGINT SIGTERM

	# Main process received SIGTERM or SIGINT, shutdown reader and logwriter processes.
	systemd-notify --pid=$$ --stopping --status="cryptdisksd: terminating"
	do_log warning "${myname} terminating after ${time_active}s"
	do_daemon_check_conf
	for _pid in ${pid_ctrl[@]}; do
		if [[ "$(cat /proc/${pid_ctrl[${_pid}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${pid_ctrl[${_pid}]}
			wait ${pid_ctrl[${_pid}]}
			do_log debu2 "${myname} killed control process (PID: ${pid_ctrl[${_pid}]})"
		fi
	done
	if [[ ! -z "${pid_reader}" && "$(cat /proc/${pid_reader}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_reader}
		wait ${pid_reader}
	fi
	if [[ ! -z "${pid_logwriter}" && "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_logwriter}
		wait ${pid_logwriter}
	fi
	rm -f ${conf[PIDFILE]} ${conf[CRYPTDISKSDDIR]}/*.sock
	systemd-notify --pid=$$ --status="cryptdisksd: finished after $(do_timer ${time_start})s"
	
	exit $1 
}

trap_hup_daemon()
{
	# Received reload request from systemd. Reload the config asap (no active commands/workers). confok, contains status.
	# 0 - Config is ok.
	# 1 - Config changed, or SIGHUP received
	# 2 - Notified reader of reload
	# When the reader is ready to reload it will notify us and we can reload the config and restart the reader.
	if [[ ${starting} -eq 0 && ${confok} -eq 0 ]]; then
		do_log warning "${myname} received SIGHUP, reload config asap"
		confok=2
		kill -SIGHUP ${pid_reader}
		do_log debug2 "${myname} notified reader (PID: ${pid_reader}) of config reload"
	fi
}

systemd_daemon()
{
	trap 'trap_term_daemon' SIGINT SIGTERM
	trap 'trap_hup_daemon' SIGHUP

	# The reader and all workers will be started with the following fds:
	# 1 (stdout) 2 (stderr) and {fd_logwriter} (for subshells) point to a log writer.
	# {fd_journal} systemd journal messages which can be viewed with systemctl status and journalctl -xe
	# {fd_daemon} the daemon process.
	local time_active=0.000 cleanup=0.000 msg="" confok=0 fd_daemon pid_reader fd_reader reader_alive=0 readerr=0 pid_putkey key passphrase read_to res _time_start
	declare -A active_mnt pid_ctrl fd_ctrl time_ctrl cached_pp

	# If we are booting up the master passphrase may be in the user keyring, revoke and cache in session keyring.
	key="$(keyctl search @u user "system:master" 2>/dev/null)"
	passphrase="$(keyctl pipe "${key}" 2>/dev/null)"
	if [[ ! -z "${key}" ]]; then
		do_log debug "${myname} removed system:master passphrase from user keyring"
		keyctl revoke "${key}" 2>/dev/null
		keyctl unlink "${key}" @u 2>/dev/null
		put_key "system:master" "${passphrase}" & do_cache_pp "system:master" "${passphrase}" "${myname}" && cached_pp[system:master]=1
		pid_putkey=$!
	fi
	
	# The readers and will send us messages about events, we need to keep track of time for (debug) logging and cleanup.
	# If we are starting up, read time-out is start timeout so cleanup etc will be done only after start
	# If we are in normal op, keep cleanup timer (60secs). The timeouts will be evaluated every command iteration.
	systemd-notify --pid=$$ --status="cryptdisksd: Starting Up, Timeout $((conf[START_TIMEOUT]+conf[QUEUE_TIMEOUT]*2))s"
	systemd-notify EXTEND_TIMEOUT_USEC=$(((conf[START_TIMEOUT]+conf[QUEUE_TIMEOUT]*2)*1000000))
	do_daemon_start_reader
	do_log debug "${myname} started reader (PID: ${pid_reader})"

	while true; do	
		# If we are starting up, read time-out when initial queue is empty so we can notify parent.
		# If we are in normal operation, keep cleanup timer (60secs).
		do_log debug2 "${myname} running since $(do_timer date ${time_start})"
		time_active=$(do_timer ${time_start})
	
		# Set the new queue read timeout, we will run a cleanup every conf[CLEANUP_TIMER]. Cleanup will not run before we are started.
		case ${starting} in
			0)
				# Do a cleanup if the timer is about to expire.
				if [[ ${time_active:0:-4} -gt $((${cleanup:0:-4}+${conf[CLEANUP_TIMER]}-${conf[QUEUE_TIMEOUT]})) ]] || [[ ${res} -eq 142 && ${read_to##* } -gt $((conf[CLEANUP_TIMER]/2)) ]]; then
					do_daemon_cleanup
				fi
				read_to="$(((${conf[CLEANUP_TIMER]}+${conf[QUEUE_TIMEOUT]})-(${time_active:0:-4}%${conf[CLEANUP_TIMER]})))";;
			1|2)
				# Make sure the read timeout is never 0 as this will complicate things (read will not read if to = 0).
				read_to="$(((${conf[START_TIMEOUT]}+${conf[QUEUE_TIMEOUT]})-(${time_active:0:-4}%${conf[START_TIMEOUT]})))";;
		esac
		
		# Start reading from the reader message queue. Parse the message into an arry the first element will be reader second the pid of the reader, rest is the message.
		IFS=" " read -t${read_to} -ru${fd_reader} -a msg
		res=$?
		
		# Evaluate the exit status of the message queue read and act accordingly.
		time_active=$(do_timer ${time_start})
		if [[ ${res} -eq 142 ]]; then 
			case ${starting} in 
				1|2|3)
					# Start timeout reached, notify systemd.
					do_log debug2 "${myname} start timeout reached, notifying reader and systemd"
					starting=0
					start_status=3
					do_daemon_notify_systemd
					;;
				0)
					# Queue timeout for cleanup.
					do_log debug2 "${myname} waking up from slumber"
					;;
			esac
			do_log debug2 "${myname} running since $(do_timer date ${time_start})"
			continue
		elif [[ ${res} -gt 128 ]]; then
			# Should not happen, daemon process received unhandled signal from somewhere.
			do_log debug "${myname} read result ${res}, may have been trapped"
			do_daemon_cleanup 
			continue
		elif [[ ${res} -ne 0 ]]; then
			# Reader has terminated unexpectedly or fd has somehow been closed from reader end.
			if [[ ${readerr} -eq 0 ]]; then 
				do_log error "${myname} read error ${res} \"${msg[@]}\""
			elif [[ $((readerr%20)) -eq 0 ]]; then
				reader_alive=2
				do_daemon_cleanup
			elif [[ ${readerr} -gt 99 ]]; then
				do_log error "${myname} too many read errors, terminating"
				trap_term_daemon 1
			fi
			readerr=$((readerr+1))
			continue
		fi
		readerr=0

		# Evaluate the start status. Check if we have a start timeout. If so we are started and will notify systemd.
		if [[ ${starting} -ne 0 && ${time_active:0:-4} -ge ${conf[START_TIMEOUT]} ]]; then
			# Check if we have a start timeout. If so we are started and will notify systemd.
			starting=0 start_status=3
			do_daemon_notify_systemd
			continue
		fi
		
		if [[ -z "${msg[@]}" || ! ( "${msg[0],,}" == "reader" && ${msg[1]} -eq ${pid_reader} ) ]]; then
			# Should not occur, run cleanup if it does, if reader has exited next read will fail, see above.
			do_log error "${myname} received invalid message \"${msg[@]}\""
			reader_alive=2
			do_daemon_cleanup
			continue
		fi

		# Process the message sent by the reader.
		do_log debug "${myname} processing \"${msg[@]}\"" 
		reader_alive=0 _time_start=$(do_timer)

		case ${msg[2]} in
			started|control|notify)
				do_daemon_${msg[2]};;
			active)
				do_log debug "${myname} reader (PID: ${pid_reader}) ping received";;
			remove)
				do_daemon_unmount_crypt "${msg[3]}";;
			add)
				do_daemon_mount_crypt "${msg[3]}" "${msg[4]}" "${msg[5]}" "${msg[6]}";;
			reload)
				[[ ${confok} -lt 2 ]] && do_log warning "${myname} incorrect reload request from reader";
				[[ -e /proc/self/fd/${fd_reader} ]] && exec {fd_reader}>&-
				unset pid_reader
				do_daemon_cleanup;;
			*)	
				do_log debug "${myname} received invalid command from reader \"${msg[@]}\"";;
		esac

		do_log debug2 "${myname} processing \"${msg[@]}\" took $(do_timer ${_time_start})s total"
	done

	# We should never get here, exit with error if we do.
	time_active="$(do_timer ${time_start})"
	do_log error "${myname} terminated unexpectedly after ${time_active}s"
	systemd-notify --pid=$$ --status="cryptdisksd: Daemon Terminated Unexpectedly After ${time_active}s (PID: ${BASHPID}))"
	trap_term_daemon 2
}

do_daemon_start_logwriter()
{
	# LOGLEVEL 0, log only to syslog (daemon facility). 
	# LOGLEVEL 1, log to syslog and debug to dedicated logfile.
	# LOGLEVEL 2 is loglevel 1 with components having dedicated log file.
	# LOGLEVEL 3, extra debug logging, stdout and stderr of processes also sent to log.
	# BEWARE PASSPHRASES WILL BE LOGGED ALSO!!!!
	# LOGLEVEL 4, sames as level 3 with components having dedicated log file.
	case ${conf[LOGLEVEL]} in
		0|1) 	exec {fd_logwriter}> >(logwriter);;
		2)		exec {fd_logwriter}> >(logwriter daemon-${pid_daemon}.log);;
		3)		exec {fd_logwriter}> >(logwriter) 1>&${fd_logwriter} 2>&1;;
		4)		exec {fd_logwriter}> >(logwriter daemon-${pid_daemon}.log) 1>&${fd_logwriter} 2>&1;;
	esac
	pid_logwriter=$!
}

do_daemon_start_reader()
{
	# Set the group and mode for the rundir and queue.
	[[ ! -z ${fd_reader} ]] && exec {fd_reader}>&-
	chgrp ${conf[CRYPTDISKSD_GROUP]} ${conf[CRYPTDISKSDDIR]} ${conf[FIFO]}
	chmod ${conf[CRYPTDISKSDDIR_MODE]} ${conf[CRYPTDISKSDDIR]}
	chmod ${conf[FIFO_MODE]} ${conf[FIFO]}
	case ${conf[LOGLEVEL]} in
		0|1|2)	# Start the reader with stdout and stderr redirected to /dev/null (silent).
				exec {fd_reader}< <(udev_reader {fd_daemon}>&1- 1>/dev/null 2>&1);;
		3|4)	# Start the reader with stdout and stderr redirected to the logwriter.
				exec {fd_reader}< <(udev_reader {fd_daemon}>&1- 1>&${fd_logwriter} 2>&1);;
	esac
	pid_reader=$!
}

do_daemon_notify_systemd()
{
	# Daemon notify about startup status.
	systemd-notify --ready --pid=$$
	case ${start_status} in 
		0)
			do_log info "${myname} startup completed succesfully in ${time_active}s"
			systemd-notify --pid=$$ --status="cryptdisksd: Startup completed succesfully in ${time_active}s (PID: ${BASHPID})";;
		1)
			do_log warning "${myname} startup completed with errors in ${time_active}s"
			systemd-notify --pid=$$ --status="cryptdisksd: Startup completed with errors in ${time_active}s (PID: ${BASHPID})";;
		2)
			do_log warning "${myname} startup completed with warnings in ${time_active}s"
			systemd-notify --pid=$$ --status="cryptdisksd: Startup completed with warnings in ${time_active}s (PID: ${BASHPID})";;
		3)
			do_log warning "${myname} startup timed out after ${time_active}s"
			systemd-notify --pid=$$ --status="cryptdisksd: Startup timed out after ${time_active}s (PID: ${BASHPID})"
			kill -SIGHUP ${pid_reader};;
	esac
}

do_daemon_check_conf()
{
	# Parse the configuration from firmware and compare it to the config stored in the confdir.
	# If there are any differences, the configuration in confidir will take precedence and overwrite the firmware.
	do_log debug "${myname} checking config"

	if [[ -s ${conf[FWBOOTCONF]} && ! -s ${conf[BOOTCONF]} ]]; then
		# Config in firware, not in confdir, copy fw to confdir.
		[[ ${confok} -eq 0 ]] && confok=1
		do_log debug "${myname} copying ${conf[FWBOOTCONF]} config to ${CONFDIR}"
		cat ${conf[FWBOOTCONF]} | tail -c +5 >${conf[BOOTCONF]} || return 1
	elif [[ -s ${conf[FWBOOTCONF]} && -s ${conf[BOOTCONF]} ]]; then
		# Compare the firmware config to confdir.
		local __diff="$(cat ${conf[FWBOOTCONF]} | tail -c +5)"
		local __diff1="$(cat ${conf[BOOTCONF]})"
		if ! diff -q <(echo "${__diff}") <(echo "${__diff1}") >/dev/null; then
			# Configs are different, overwrite confdir on startup firmware config otherwise.
			[[ ${confok} -eq 0 ]] && confok=1
			if [[ ${starting} -eq 0 ]]; then
				do_log warning "${myname} ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} differ, replacing ${conf[FWBOOTCONF]}"
				[[ -e ${conf[FWBOOTCONF]} ]] && chattr -i ${conf[FWBOOTCONF]}
				printf "\x07\x00\x00\x00\x00" >${conf[FWBOOTCONF]} || do_log error "${myname} error creating ${conf[FWBOOTCONF]}"
				efivar -n ${conf[FWGUID]}-UglyLinuxBootCFG -w -f ${conf[BOOTCONF]} 2>&1 || do_log error "${myname} error copying ${conf[BOOTCONF]} to ${conf[FWBOOTCONF]}"
				chattr +i ${conf[FWBOOTCONF]}
			else
				do_log warning "${myname} ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} differ, replacing ${conf[BOOTCONF]}"
				cat ${conf[FWBOOTCONF]} | tail -c +5 >${conf[BOOTCONF]}
			fi
		else
			do_log debug2 "${myname} ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} equal"
		fi
	elif [[ ! -s ${conf[FWBOOTCONF]} && -s ${conf[BOOTCONF]} ]]; then
		# No fwconfig store confdir.
		[[ ${confok} -eq 0 ]] && confok=1
		do_log debug "${myname} no firmware config, copying from ${conf[BOOTCONF]}"
		[[ -e ${conf[FWBOOTCONF]} ]] && chattr -i ${conf[FWBOOTCONF]}
		printf "\x07\x00\x00\x00\x00" >${conf[FWBOOTCONF]} || do_log error "${myname} error creating ${conf[FWBOOTCONF]}"
		efivar -n ${conf[FWGUID]}-UglyLinuxBootCFG -w -f ${conf[BOOTCONF]} || do_log error "${myname} error copying ${conf[BOOTCONF]} to ${conf[FWBOOTCONF]}"
		chattr +i ${conf[FWBOOTCONF]}
	else
		# No bootconf at all.
		do_log warning "${myname} no boot config found"
		bootconf[BOOTSERVERS]=""
	fi

	# If we are starting up, now is the time to load the config.	
	if [[ ${starting} -eq 1 ]]; then
		do_daemon_reload_conf	
	fi

	# Check if the service config or crypttab has changed on disk.
	if [[ ${starting} -eq 0 && ${confok} -eq 0 ]]; then
		if [[ ! -f ${conf[CRYPTTAB]} ]]; then
			do_log warning "${myname} ${conf[CRYPTTAB]} disappeared, terminating"
		fi
		if [[ ! -f ${CONF} ]]; then
		 	do_log error "${myname} ${CONF} disappeared, terminating"
			return 1
		fi
		local __diff="$(cat ${CONF} |grep -ve "^\s*#")"
		if ! diff -q <(echo "${__diff}") <(echo "${systemdconf}") >/dev/null; then
			do_log error "${myname} ${CONF} changed, terminating"
			return 1
		fi
		local __diff="$(cat ${conf[CRYPTTAB]} |grep -ve "^\s*#")"
		if ! diff -q <(echo "${__diff}") <(echo "${crypttab}") >/dev/null; then
			do_log debug "${myname} crypttab changed, reloading asap"
			confok=1
		fi
	fi

	# Check the bootserver and user keys if present.
	[[ -z ${bootconf[BOOTSERVERS]} ]] && return
	local _fwsrvvar="${conf[FWGUID]}-UglyLinux${bootconf[BOOTSERVERKEYS]}"
	local _fwsrvkey="${conf[FWDIR]}/UglyLinux${bootconf[BOOTSERVERKEYS]}-${conf[FWGUID]}"
	local _srvkey="${CONFDIR}/${bootconf[BOOTSERVERKEYS]}"
	local _fwusrvar="${conf[FWGUID]}-UglyLinux${bootconf[BOOTUSERKEY]}"
	local _fwusrkey="${conf[FWDIR]}/UglyLinux${bootconf[BOOTUSERKEY]}-${conf[FWGUID]}"
	local _usrkey="${CONFDIR}/${bootconf[BOOTUSERKEY]}"
	if [[ -s ${_fwsrvkey} && -s ${_srvkey} ]]; then
		# compare the keys, overwrite if necessary
		local _diff="$(cat ${_fwsrvkey} | tail -c +5)"
		local _diff1="$(cat ${_srvkey})"
		if ! diff -q <(echo "${_diff}") <(echo "${_diff1}") >/dev/null; then
			# Configs are different, overwrite firmware config
			do_log warning "${myname} ${_fwsrvkey} and ${_srvkey} differ, replacing ${_fwsrvkey}"
			[[ -e ${_fwsrvkey} ]] && chattr -i ${_fwsrvkey}
			printf "\x07\x00\x00\x00\x00" >${_fwsrvkey} || do_log error "${myname} error creating ${_fwsrvkey}"
			efivar -n ${_fwsrvvar} -w -f ${_srvkey} || do_log error "${myname} error copying ${_srvkey} to ${_fwsrvkey}"
			chattr +i ${_fwsrvkey}
		else
			do_log debug2 "${myname} ${_fwsrvkey} and ${_srvkey} equal"
		fi
	elif [[ -s ${_fwsrvkey} && ! -s ${_srvkey} ]]; then
		# Keys in fw not in confdir, copy
		do_log debug "${myname} copying ${_fwsrvkey} to ${_srvkey}"
		cat ${_fwsrvkey} | tail -c +5 > ${_srvkey} || return 1
	elif [[ ! -s ${_fwsrvkey} && -s ${_srvkey} ]]; then
		# No fwbootkeys, copy from confdir.
		do_log debug "${myname} no firmware bootserver keys, copying from ${_srvkey}"
		[[ -e ${_fwsrvkey} ]] && chattr -i ${_fwsrvkey}
		printf "\x07\x00\x00\x00\x00" >${_fwsrvkey} || do_log error "${myname} error creating ${_fwsrvkey}"
		efivar -n ${_fwsrvvar} -w -f ${_srvkey} || do_log error "${myname} error copying ${_srvkey} to ${_fwsrvkey}"
		chattr +i ${_fwsrvkey}
	else
		# No bootserverkeys at all
		do_log error "${myname} no bootserver keys found"
		bootconf[BOOTSERVERS]=""
	fi

	# No need to check user key, if server key not present.
	[[ -z ${bootconf[BOOTSERVERS]} ]] && return
	if [[ -s ${_fwusrkey} && ! -s ${_usrkey} ]]; then
		# Key in fw not in confdir, copy
		do_log debug "${myname} copying ${_fwusrkey} to ${_usrkey}"
		chattr -i ${_fwusrkey}; chmod 400 ${_fwusrkey}; chattr +i ${_fwusrkey}
		cat ${_fwusrkey} | tail -c +5 > ${_usrkey} || return 1
		chmod 400 ${_usrkey}
	elif [[ -s ${_fwusrkey} && -s ${_usrkey} ]]; then
		# compare the keys, overwrite if necessary
		local _diff="$(cat ${_fwusrkey} | tail -c +5)"
		local _diff1="$(cat ${_usrkey})"
		if ! diff -q <(echo "${_diff}") <(echo "${_diff1}") >/dev/null; then
			# Configs are different, overwrite firmware config
			do_log warning "${myname} ${_fwusrkey} and ${_usrkey} differ, replacing ${_fwusrkey}"
			[[ -e ${_fwusrkey} ]] && chattr -i ${_fwusrkey}
			printf "\x07\x00\x00\x00\x00" >${_fwusrkey} || do_log error "${myname} error creating ${_fwusrkey}"
			efivar -n ${_fwusrvar} -w -f ${_usrkey} || do_log error "${myname} error copying ${_usrkey} to ${_fwusrkey}"
			chattr -i ${_fwusrkey}; chmod 400 ${_fwusrkey}; chattr +i ${_fwusrkey}
		else
			do_log debug2 "${myname} ${_fwusrkey} and ${_usrkey} equal"
			chattr -i ${_fwusrkey}; chmod 400 ${_fwusrkey}; chattr +i ${_fwusrkey}
			chmod 400 ${_usrkey}
		fi
	elif [[ ! -s ${_fwusrkey} && -s ${_usrkey} ]]; then
		# No fwbootuserkey, copy from confdir
		do_log debug "${myname} no firmware bootuser key, copying from ${_usrkey}"
		[[ -e ${_fwusrkey} ]] && chattr -i ${_fwusrkey}
		printf "\x07\x00\x00\x00\x00" >${_fwusrkey} || do_log error "${myname} error creating ${_fwusrkey}"
		efivar -n ${_fwusrvar} -w -f ${_usrkey} || do_log error "${myname} error copying ${_usrkey} to ${_fwusrkey}"
		chattr -i ${_fwusrkey}; chmod 400 ${_fwusrkey}; chattr +i ${_fwusrkey}
	else
		# No bootuserkeys at all
		bootconf[BOOTSERVERS]=""
	fi
	return 0
}

do_daemon_reload_conf()
{
	do_log debug "${myname} loading configuration"
	crypttab="" systemdconf=""

	# Load the crypttab into memory.
	[[ -s ${conf[CRYPTTAB]} ]] && crypttab="$(cat ${conf[CRYPTTAB]} |grep -ve "^\s*#")" 

	# Source the boot config if necessary.
	local __var __val
	for __var in ${!bootconf[@]}; do
		unset bootconf[${__var}]
	done
	if [[ -s ${conf[BOOTCONF]} ]]; then
		while IFS="=" read -r __var __val; do
			[[ ! -z "${__val}" ]] && bootconf[${__var^^}]="${__val}"
	   	done <<<"$(cat ${conf[BOOTCONF]} |grep -ve "^\s*#")"
	fi
	[[ -s ${CONF} ]] && systemdconf="$(cat ${CONF} |grep -ve "^\s*#")"
}

do_daemon_cleanup()
{
	# Readers should not ever exit, the is an error / bug. Restart the reader
	local myname="daemon cleanup (${BASHPID}):" _time_start=$(do_timer) _logwriter_running _tab_crypt="" _pp _crypt_arr _crypt __crypt _dev _trim _time _pid  _mnt_crypt
	cleanup=$(do_timer ${time_start})
	do_log debug "${myname} cleanup starting at ${time_active}"

	# Ping systemd.
	systemd-notify WATCHDOG=1 WATCHDOG_USEC=$(((2*conf[CLEANUP_TIMER])*1000000))

	# Check if the log writer is still active, restart it and the reader if necessary.
	if [[ ! -z ${pid_logwriter} ]]; then
		if [[ "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" != "${MYNAME}" ]] || ! kill -0 ${pid_logwriter} && kill -SIGKILL ${pid_logwriter}; then
			do_log error "${myname} logwriter (PID: ${pid_logwriter}) terminated after ${time_active}s, restarting"
			systemd-notify "cryptdisksd: logwriter (PID: ${pid_logwriter}) terminated after ${time_active}s, restarting"
			if [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]] && [[ ! -z "${pid_reader}" && "$(cat /proc/${pid_reader}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
				kill -SIGTERM ${pid_reader} && unset pid_reader
				[[ -e /proc/self/fd/${fd_reader} ]] && exec {fd_reader}>&-
				do_log debug2 "${myname} killed reader (PID: ${pid_reader})"
			fi
			do_daemon_start_logwriter
		fi
	fi

	# Kill too long running control conections.
	for _pid in ${!pid_ctrl[@]}; do
		_time=$(do_timer ${time_ctrl[${_pid}]})
		if [[ ${_time:0:-4} -ge $((conf[PP_TIMEOUT]+conf[QUEUE_TIMEOUT])) ]]; then 
			do_log debug "${myname} cleanup killed control worker (PID: ${pid_ctrl[${_pid}]})"
			if [[ ! -z "${pid_ctrl[${_pid}]}" && "$(cat /proc/${pid_ctrl[${_pid}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
				kill -SIGKILL ${pid_ctrl[${_pid}]}
				do_log debug2 "${myname} killed ${pid_ctrl[${_pid}]}"
			fi
			exec {pid_ctrl[${_pid}]}>&-
			unset pid_ctrl[${_pid}] fd_ctrl[${_pid}] time_ctrl[${_pid}]
		fi
	done
	[[ -z ${!pid_ctrl[@]} ]] && rm -f ${conf[CRYPTDISKSDDIR]}/*.sock

	# Check the config.
	if ! do_daemon_check_conf; then
		do_log error "${myname} failed to check config, terminating"
		systemd-notify --ready --pid=$$
		systemd-notify STOPPING=1 --pid=$$ --status="cryptdisksd: Failed to Load Configuration"
		trap_term_daemon
	fi
		
	if [[ ${starting} -eq 0 && ${confok} -eq 1 ]]; then
		# Config has changed, needs to be reloaded.
		confok=2
		kill -SIGHUP ${pid_reader}
		do_log debug2 "${myname} notified reader (PID: ${pid_reader}) of config reload"
	fi

	# Check if the reader is still alive and restart it if necessary.	
	if [[ ${reader_alive} -eq 2 || "$(cat /proc/${pid_reader}/comm 2>/dev/null)" != "${MYNAME}" ]] || ! kill -0 ${pid_reader}; then
		do_log error "${myname} reader (PID: ${pid_reader}) not functioning after ${time_active}s"
		systemd-notify --pid=$$ --status="cryptdisksd: reader (PID: ${pid_reader}) terminated after ${time_active}s"
		if [[ "$(cat /proc/${pid_reader}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${pid_reader}
			do_log debug2 "${myname} killed reader (PID: ${pid_reader})"
		fi
		[[ -e /proc/self/fd/${fd_reader} ]] && exec {fd_reader}>&-
		do_daemon_reload_conf
		confok=0
		reader_alive=0
		do_daemon_start_reader
		# Check if any crpyts have been removed from the crypttab and try to remove then. Then trigger udev to add new devices.
		# We will set a list with all crypts in the crypttab and will check that list against active mounts later.
		_tab_crypt="$(tr "\t" " " <<<"${crypttab}" |cut -d" " -f1)"
	elif [[ ${reader_alive} -eq 1 ]]; then
		do_log warning "${myname} have not received ping from reader (PID: ${pid_reader})"
		reader_alive=2
	else
		reader_alive=1
	fi

	# Check the active crypts and add to active list if not already present.
	_mnt_crypt="$(dmsetup ls --target crypt |cut -f1 |grep -vi "No devices found")"
	for _crypt in ${_mnt_crypt}; do
		if [[ -z "${active_mnt[${_crypt}]}" ]]; then
			_crypt_arr=($(do_xcrypt_fromtab "${myname}" "${_crypt}"))
			[[ "$(lsblk -rD /dev/mapper/${_crypt} |head -n2 |tail -n1 |cut -d" " -f3)" == "0B" ]] && _trim=0 || _trim=1
			if [[ ! -z "${_crypt_arr[@]}" ]]; then
				_dev="${_crypt_arr[1]}"
				_pp="$(do_eval_pp "${_crypt_arr[2]}")"
				active_mnt[${_crypt}]="${_dev} ${_pp} ${_trim} $(do_timer)"
			else
				_dev=/dev/"$(dmsetup deps ${_crypt} -o blkdevname |cut -d: -f2 |tr -d " ()" |cut -d: -f2)"
				active_mnt[${_crypt}]="${_dev} - ${_trim} $(do_timer)"
			fi
			do_log debug "${myname} found ${_dev} as ${_crypt} TRIM ${_trim} passphrase ${_pp} adding to active list"
		fi
	done

	# Check for removed crypts and remove the from active list.
	for _crypt in ${!active_mnt[@]}; do
		for __crypt in ${_mnt_crypt}; do
			[[ "${_crypt}" == "${__crypt}" ]] && continue 2
		done
		IFS=" " read -r _dev _pp _trim _time <<<"${active_mnt[${_crypt}]}"
		do_log warning "${myname} ${_dev} as ${_crypt} TRIM ${_trim} passphrase ${_pp} mounted since $(do_timer date ${_time}) dissapeared"
		unset active_mnt[${_crypt}]
	done

	# If we have reloaded look up any managed crypts removed from crypttab and try to unmount them.
	if [[ ! -z "${_tab_crypt}" ]]; then
		for _crypt in ${!active_mnt[@]}; do
			IFS=" " read -r _dev _pp _trim _time <<<"${active_mnt[${_crypt}]}"
			[[ "${_pp}" == "-" ]] && continue
			for __crypt in ${_tab_crypt}; do
				[[ "${_crypt}" == "${__crypt}" ]] && continue 2
			done
			do_log warning "${myname} ${_dev} as ${_crypt} TRIM ${_trim} passphrase ${_pp} mounted since $(do_timer date ${_time}) removed from crypttab"
			do_daemon_unmount_crypt "${_crypt}"
		done

		# Trigger udev to mount any new devices on the crypttab not already mounted.
		do_log debug "${myname} triggering udev"
		udevadm trigger -s block -c change
	fi

	do_log debug2 "${myname} cleanup took $(do_timer ${_time_start})s, cached passphrases: ${!cached_pp[@]} - active mounts: ${!active_mnt[@]}"
}

# [END OF MAIN DAEMON FUNCTIONS]

# [BEGIN OF DAEMON READER FUNCTIONS]

do_daemon_started()
{
	# Process the start status, sent by the reader and our own.
	[[ ${start_status} -eq 0 && ${msg[4]} -eq 0 ]] && start_status=0
	[[ ${start_status} -eq 2 || ${msg[4]} -eq 2 ]] && start_status=2
	[[ ${start_status} -eq 1 || ${msg[4]} -eq 1 ]] && start_status=1

	# Set the new starting status, will need to wait for active workers, or notify systemd we are started
	case ${msg[3]} in
		0)
			# Reader has completed startup succesfully
			do_log debug "${myname} reader has started succesfully"
			do_daemon_notify_systemd
			do_daemon_cleanup
			starting=0;;
		2)
			# We are in inital startup. The reader notifies us the queue is empty and is still waiting for passphrases..
			starting=2
			do_log debug "${myname} reader has processed queue and is awaiting passphrases";;
		*)
			# Incorrect
			do_log warning "${myname} received incorrect start status from reader"
	esac
}

do_daemon_notify()
{
	local _pid_ctrl=${msg[3]} _cmd="${msg[4],,}" _myname="daemon-notify (${BASHPID}):" _time_start=$(do_timer)
	local _sock_ctrl="${conf[CRYPTDISKSDDIR]}/${MYNAME}-${_pid_ctrl}.sock"
	do_log debug "${_myname} processing \"${msg[@]:4}\""

	# Process a command received from a control sub-process and notify about the result.
	case ${_cmd} in
	add)
		[[ -z "$(do_find_dev "${_myname}" "${msg[6]}")" ]] && echo 255 >&${fd_ctrl[${_pid_ctrl}]}
		echo "$(do_daemon_mount_crypt "${msg[5]}" "${msg[6]}" "${msg[7]} "${msg[8]}"")$?" >&${fd_ctrl[${_pid_ctrl}]}
		do_log debug "${myname} active mounts: ${!active_mnt[@]}" ;;
	del)
		echo "$(do_daemon_unmount_crypt "${msg[5]}")$?" >&${fd_ctrl[${_pid_ctrl}]}
		do_log debug "${myname} active mounts: ${!active_mnt[@]}" ;;
	*)
		do_log debug "${_myname} received invalid notify command \"${msg[@]:2}\"" ;;
	esac
	do_log debug2 "${_myname} processing \"${msg[@]:4}\" took $(do_timer ${_time_start})s"
}

do_daemon_control()
{
	# Daemon received control command from cryptdisksd command line. Initialize common variables for control process (__*)
	local _pid_ctrl=${msg[3]} _cmd="${msg[4],,}"; local _sock_ctrl="${conf[CRYPTDISKSDDIR]}/${MYNAME}-${_pid_ctrl}.sock"
	local _myname="daemon-control (${BASHPID}):" _time_start=$(do_timer)
	local __myname __crypt_arr __pid_logwriter __pid_putkey __time_start __confirm=0 __crypttab=0 __smartall=0 __smarttest=0 __socat
	do_log debug "${_myname} processing \"${msg[@]:4}\""

	# Set the FD redirections as per the loglevel.	
	case ${conf[LOGLEVEL]} in
		0|1|3)
			local _fd_r="1>/dev/null 2>&1" ;;
		2|4)
			local _fd_r="1>{fd_logwriter} 2>&1" ;;
	esac

	# Process the command received and start the according control worker process.
	case ${_cmd} in
		finished)
			do_log debug "${_myname} control connection (PID: ${pid_ctrl[${_pid_ctrl}]}) finished"
			exec {fd_ctrl[${_pid_ctrl}]}>&-
			unset pid_ctrl[${_pid_ctrl}] fd_ctrl[${_pid_ctrl}] time_ctrl[${_pid_ctrl}]
			[[ -e ${_sock_ctrl} ]] && rm -f ${_sock_ctrl}
			;;
		add|del|put|rmkey|status|smart|erase)
			exec {fd_ctrl[${_pid_ctrl}]}> >(daemon_control_${_cmd} "$fd_r}") 
			pid_ctrl[${_pid_ctrl}]=$!
			time_ctrl[${_pid_ctrl}]=$(do_timer) 
			;;
		*)
			do_log debug "${_myname} invalid control command \"${msg[@]:4}\""
			;;
	esac
	
	do_log debug2 "${_myname} processing \"${msg[@]:4}\" took $(do_timer ${_time_start})s"
}

do_daemon_mount_crypt()
{
	local _add_crypt="$1" _add_dev="$2" _add_pp="$3" _add_trim="$4" _add_time=$(do_timer) _key _passphrase=""
	do_log debug "${myname} mounting ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} with ${_add_pp} passphrase"

	# The passphrase should be cached by now, error exit if not.
	_key="$(keyctl request user "${_add_pp}" 2>/dev/null)"
	_passphrase="$(keyctl pipe ${_key} 2>/dev/null)"
	if [[ -z "${_key}" ]]; then
		do_log error "${myname} passphrase ${_add_pp} not cached!" 
		unset cached_pp[${_add_pp}]
		return 4
	fi
	cached_pp[${_add_pp}]=1

	# First check if the crypt is already mounted. If so, check if it's on the active list and add if not.	
	if dmsetup info "${_add_crypt}" >/dev/null 2>&1; then
		[[ "$(lsblk -rD /dev/mapper/${_add_crypt} |head -n2 |tail -n1 |cut -d" " -f3)" == "0B" ]] && _add_trim=0 || _add_trim=1
		if [[ -z "${active_mnt[${_add_crypt}]}" ]]; then
			active_mnt[${_add_crypt}]="${_add_dev} ${_add_pp} ${_add_trim} ${_add_time}"
			do_log debug "${myname} added ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} passphrase ${_add_pp} to active list"
			return 0
		else
			IFS=" " read -r _add_dev _add_pp _add_trim _add_time <<< "${active_mnt[${_add_crypt}]}"
			do_log info "${myname} ${_add_dev} already active as ${_add_crypt} TRIM ${_add_trim} since $(do_timer date ${_add_time})"
			return 2
		fi
	else
		if [[ "$(lsblk -rD ${_add_dev} |head -n2 |tail -n1 |cut -d" " -f3)" == "0B" ]]; then
			_add_trim=0 _key=3
			do_log info "${myname} requested TRIM for ${_add_crypt} but device ${_add_dev} does not support it"
		fi
		if cryptsetup open --type plain $([[ ${_add_trim} -eq 1 ]] && echo "--allow-discards") "${_add_dev}" "${_add_crypt}" <<<"${_passphrase}"; then
			# Mounted, add to active list.
			do_log info "${myname} mounted ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} passphrase ${_dd_pp}"
			do_log debug2 "${myname} mounting ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} passphrase \"${_passphrase}\" took $(do_timer ${_add_time})s"
			active_mnt[${_add_crypt}]="${_add_dev} ${_add_pp} ${_add_trim} ${_add_time}"
			return $((0+${_key}))
		else
			do_log error "${myname} error mounting ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} after $(do_timer ${_add_time})s"
			start_status=1
			return 1
		fi
	fi
}

do_daemon_unmount_crypt()
{
	local __del_crypt="$1" __time_start=$(do_timer)
	if dmsetup info "${__del_crypt}" >/dev/null 2>&1; then
		local __del_dev __del_pp _del_time 
		IFS=" " read -r __del_dev __del_pp __del_trim __del_time <<<"${active_mnt[${__del_crypt}]}"
		if kpartx -d /dev/mapper/${__del_crypt} && cryptsetup remove "${__del_crypt}"; then
			do_log info "${myname} removed ${__del_dev} as ${__del_crypt} TRIM ${__del_trim} passphrase ${__del_pp} mounted since $(do_timer date ${__del_time})"
			do_log debug2 "${myname} removing ${__del_crypt} took $(do_timer ${__time_start})s"
			unset active_mnt[${__del_crypt}]
			return 0
		else
			do_log warning "${myname} failed to remove ${__del_dev} as ${__del_crypt} TRIM ${__del_trim} passphrase ${__del_pp} mounted since $(do_timer date ${__del_time})"
			[[ ${start_status} -eq 0 ]] && start_status=2
			return 1
		fi
	else
		do_log debug "${myname} crypt ${__del_crypt} not present, skipping"
		unset active_mnt[${__del_crypt}]
		[[ ${start_status} -eq 0 ]] && start_status=2
		return 2
	fi
}

# [END OF DAEMON READER FUNCTIONS]

# [BEGIN OF DAEMON CONTROL FUNCTIONS]
trap_term_control()
{
	trap 'do_log warning "${__myname} unclean exit after ${__time_start})s"; exit 1' SIGINT SIGTERM

	if [[ ! -z "${__socat_PID}" && "$(cat /proc/${__socat_PID}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__socat_PID}
		wait ${__socat_PID}
		do_log debug2 "${__myname} killed socat coproc (PID: ${__socat_PID})"
	fi
	if [[ ! -z "${__pid_putkey}" ]]; then
		kill -SIGTERM ${__pid_putkey}
		wait ${__pid_putkey}
		do_log debug2 "${__myname} killed putkey worker (PID: ${__pid_putkey})"
	fi
	if [[ ! -z "${__pid_getpp}" ]]; then
		kill -SIGTERM ${__pid_getpp}
		wait ${__pid_getpp}
		do_log debug2 "${__myname} killed getpp worker (PID: ${__pid_putkey})"
	fi
	do_log debug2 "${__myname} terminating after $(do_timer ${__time_start})s"
	if [[ ! -z "${__pid_logwriter}" &&"$(cat /proc/${__pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_logwriter}
		wait ${__pid_logwriter}
	fi
	rm -f ${_sock_ctrl}
	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}

	exit $1
}

daemon_control_status()
{
	# Connect to control socket and blurt status in some form of a pretty fashion.
	do_control_init "status" "Status Report"
	local __key __passphrase="" __crypt __dev __pp __trim __time __status __storageprefix="storage"

	# Output the status to the coproc, which will transfer it to stdout of the requestor. First al active mounts.
	echo -e "\r${GREY}${BOLD}${PR}CRYPT${PD}DEVICE${PE}TRIM${PP}PASSPHRASE${PT}ACTIVE SINCE${PS}STATUS${NOR}\r" >&${__socat[1]}
	[[ -n "${bootconf[STORAGEPREFIX]}" ]] && __storageprefix="${bootconf[STORAGEPREFIX]}"
	for __crypt in ${!active_mnt[@]}; do
		__status=""
		IFS=" " read -r __dev __pp __trim __time <<<"${active_mnt[${__crypt}]}"
		[[ "${__trim}" == "1" ]] && __trim="On" || __trim="Off"
		if [[ "${__pp}" == "-" ]]; then
			if [[ "${__crypt}" =~ ^${__storageprefix}[0-9]{1,2}$ ]]; then
				__status="${GRN}Online (M)"
				if [[ -n "${bootconf[STORAGEPP]}" ]]; then
					__pp="$(do_eval_pp "${bootconf[STORAGEPP]}")"
				else
					__pp="system:master"
				fi
			else
				__status="${YEL}Online (U)"
			fi
		else
			__status="${GRN}Online (M)"
		fi
		__time=$(do_timer date ${__time}); __dev=${__dev##*/}
		echo -e "${PR}${__crypt}${PD}${__dev}${PE}${__trim}${PP}${__pp}${PT}${__time}${PS}${__status}${NOR}\r" >&${__socat[1]}
	done

	# Output all unmounted and waiting crypts.
	local __tab_crypt="$(tr "\t" " " <<<"${crypttab}" |cut -d" " -f1)" ___crypt ____crypt __crypt_arr=()
	for __crypt in ${__tab_crypt}; do
		__status=""
		for ___crypt in ${!active_mnt[@]}; do
			[[ "${__crypt}" == "${___crypt}" ]] && continue 2
		done
		for __pp in ${!waiting_mnt[@]}; do
			while IFS=" " read -r ____crypt __dev __trim __time; do 
				if [[ "${__crypt}" == "${____crypt}" ]]; then
					__status="${YEL}Waiting"
					__time=$(do_timer date ${__time})
					break 2
				fi
			done <<<"${waiting_mnt[${__pp}]}"
		done
		if [[ ! "${__status}" == "${YEL}Waiting" ]]; then
			__status="${RED}Offline"
			__time="-"
		fi
		__crypt_arr=($(do_xcrypt_fromtab "${__myname}" "${__crypt}"))
		__dev=${__crypt_arr[1]##*/}
		__pp="$(do_eval_pp "${__crypt_arr[2]}")"
		[[ "${__crypt_arr[3]}" == "1" ]] && __trim="On" || __trim="Off"
		echo -e "${PR}${__crypt}${PD}${__dev}${PE}${__trim}${PP}${__pp}${PT}${__time}${PS}${__status}${NOR}\r" >&${__socat[1]}
	done
	echo >&${__socat[1]}

	if [[ ${conf[LOGLEVEL]} -ge 1 ]]; then
		# Output cached passphrases.
		echo -e "${PR}${GREY}${BOLD}Cached Passphrases:${PS}${NOR}${!cached_pp[@]}\r\n" >&${__socat[1]}
	fi
	if [[ ${conf[LOGLEVEL]} -ge 3 ]]; then
		# Output passphrases.
		echo -e "${PR}${GREY}${BOLD}PASSPHRASE${PS}VALUE${NOR}\r" >&${__socat[1]}
		for __pp in ${!cached_pp[@]}; do
			__key="$(keyctl request user "${__pp}")" 
			__passphrase="$(keyctl pipe "${__key}")"
			echo -ne "${PR}${__pp}${PS}" >&${__socat[1]}
			if [[ -z "${key}" ]]; then
				echo -me "${RED}${BOLD}FAIL${NOR}" >&${__socat[1]}
			else
				echo -n  "\"${__passphrase}\"" >&${__socat[1]}
			fi
			echo -e "${NOR}\r" >&${__socat[1]}
		done
		echo >&${__socat[1]}
	fi

	echo -e "${UL}${myname} Running Since $(do_timer date ${time_start}) ($(do_timer ${time_start})s)${NOR}\r" >&${__socat[1]}

	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}
	do_log debug2 "${__myname} finished after $(do_timer ${__time_start})s"
}

daemon_control_smart()
{
	# Display SMART Information for Device
	do_control_init "smart" "Do S.M.A.R.T."
	local __crypt="${__crypt_arr[0]}" __dev="$(do_find_dev "${__myname}" "${__crypt_arr[1]}")"

	if [[ -z "${__crypt_arr[@]}" ]]; then
		echo -e "\r${RED}${BOLD}${msg[5]} not Found in Crypttab.${NOR}\r" >&${__socat[1]}
		trap_term_control 1
	elif [[ -z "${__dev}" ]]; then
		echo -e "\r${RED}${BOLD}${__dev} not Found in ${conf[BLOCKDEVSDIRS]}.${NOR}\r.${NOR}\r" >&${__socat[1]}
		trap_term_control 1
	fi

	if [[ ${__smartall} -eq 1 ]]; then
		smartctl -x ${__dev} >&${__socat[1]} 2>&1
	else
		smartctl -A ${__dev} >&${__socat[1]} 2>&1
	fi
	if [[ ${__smarttest} -eq 1 ]]; then
		if dmsetup info "${__crypt}" >/dev/null 2>&1; then
			echo -e "\r${RED}${BOLD}${__crypt} Still Active.${NOR}\r" >&${__socat[1]}
			trap_term_control 1
		fi
		smartctl -t long ${__dev} >&${__socat[1]} 2>&1
	fi

	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}
	do_log debug2 "${__myname} finished after $(do_timer ${__time_start})s"
}

daemon_control_erase()
{
	# Secure Erase Device.
	do_control_init "erase" "Secure Erase"
	local __crypt="${__crypt_arr[0]}" __dev="$(do_find_dev "${__myname}" "${__crypt_arr[1]}")" __res=""

	if [[ -z "${__crypt_arr[@]}" ]]; then
		echo -e "\r${RED}${BOLD}${msg[5]} not Found in Crypttab.${NOR}\r" >&${__socat[1]}
		trap_term_control 1
	elif [[ -z "${__dev}" ]]; then
		echo -e "\r${RED}${BOLD}Device ${__dev} not Found in ${conf[BLOCKDEVSDIRS]}.${NOR}\r" >&${__socat[1]}
		trap_term_control 1
	fi

	if dmsetup info "${__crypt}" >/dev/null 2>&1; then
		echo -e "\r${RED}${BOLD}${__crypt} Still Active.${NOR}\r" >&${__socat[1]}
		trap_term_control 1
	fi

	echo -ne "${RED}${BOLD}This Will Wipe all Data on ${__dev}, Are You Sure (y/N)? " >&${__socat[1]}
	IFS= read -t${conf[USER_TIMEOUT]} -rsn1 -u ${__socat[0]} __res
	echo -e "${NOR}${BOLD}${__res}${NOR}\r" >&${__socat[1]}

	if [[ "${__res,,}" == "y" ]]; then
		echo -e "${RED}${BOLD}Secure Erasing ${__dev} ${YEL}password: $(hostname)${NOR}\r" >&${__socat[1]}
		hdparm --security-set-pass "$(hostname)" ${__dev}
		hdparm --security-erase-enhanced "$(hostname)" ${__dev} &
	fi

	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}
	do_log debug2 "${__myname} finished after $(do_timer ${__time_start})s"
}

daemon_control_put()
{
	# Put the passphrase to the boot servers.
	do_control_init "put" "Putting Key"
	local  __passphrase="" __pp="$(do_eval_pp "${msg[5]}")" __res="" __pid_putkey

	if do_control_get_passphrase "${__pp}"; then
		echo -e "\r${BOLD}${GRN}Putting ${__pp} Key to Boot Servers.${NOR}\r" >&${__socat[1]}
		wait ${__pid_putkey}
	else
		echo -e "\r${BOLD}${RED}No Passphrase Received, Bye Bye.${NOR}\r" >&${__socat[1]}
	fi

	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}
	do_log debug2 "${__myname} finished after $(do_timer ${__time_start})s"
}

daemon_control_rmkey()
{
	# Remove the key file for the passphrase.
	do_control_init "rmkey" "Removing Key File"
	local __pp="$(do_eval_pp "${msg[5]}")" __res=""; local __keyfile="${conf[FWDIR]}/UglyLinux${__pp}.key-${conf[FWGUID]}"
	
	if [[ ! -e ${__keyfile} ]]; then
		echo -e "\r${BOLD}${RED}${__keyfile} Does not Exist.${NOR}\r" >&${__socat[1]}
		trap_term_control 1
	elif chattr -i ${__keyfile} && rm -f ${__keyfile}; then
		echo -e "\r${BOLD}${GRN}Removed ${__keyfile}.${NOR}\r" >&${__socat[1]}
		trap_term_control 0
	else
		echo -e "\r${BOLD}${RED}Failed to Remove ${__keyfile}.${NOR}\r" >&${__socat[1]}
		trap_term_control 1
	fi

	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}
	do_log debug2 "${__myname} finished after $(do_timer ${__time_start})s"
}

daemon_control_del()
{
	# Remove and delete crypt from crypttab if requested.
	do_control_init "del" "Removing Crypt"
	local __del_crypt=${__crypt_arr[0]} __del_dev=${__crypt_arr[1]} __del_pp=${__crypt_arr[2]} __del_trim=${__crypt_arr[3]} __del_time=$(do_timer) __res=""

	# Check if specified crypt is on tab, user decides to exit or continue if it's not.
	if [[ -z "${__crypt_arr[@]}" ]]; then
		echo -ne "\r${RED}${BOLD}${__del_crypt} not on Crypttab, Continue Removing (y/N)? ${NOR}" >&${__socat[1]}
		IFS= read -t${conf[USER_TIMEOUT]} -rsn1 -u ${__socat[0]} ___res
		echo -e "${BOLD}${___res}${NOR}\r" >&${__socat[1]}
		[[ ! "${___res,,}" == "y" || -z "${___res,,}" || "${___res,,}" == $'\r' ]] && trap_term_control 0
		__crypttab=0 __del_dev="-" __del_pp="-"
	fi
	echo "notify ${_pid_ctrl} ${_cmd} ${__del_crypt}" >${conf[FIFO]}
	IFS= read -t${conf[USER_TIMEOUT]} -n1 -r __res
	case ${__res} in
	0)
		echo -e "\r${BOLD}${GRN}Removed ${__del_dev##*/} as ${__del_crypt} Using ${__del_pp} TRIM ${__del_trim} Passphrase, Active Since $(do_timer date ${__del_time})${NOR}\r" >&${__socat[1]};;
	2)
		echo -e "\r${BOLD}${YEL}${__del_crypt} not active${NOR}\r" >&${__socat[1]};;
	*)
		echo -e "\r${BOLD}${RED}Failed to Remove ${__del_dev##*/} as ${__del_crypt} Using ${__del_pp} Passphrase TRIM ${__del_trim}${NOR}\r" >&${__socat[1]};;
	esac
	if [[ ${__crypttab} -eq 1 && ( ${__res} -ne 0 || ${__confirm} -eq 1 ) ]]; then
		echo -ne "\r${BOLD}Continue Removing ${__del_crypt} from Crypttab (Y/n)?${NOR}" >&${__socat[1]}
		IFS= read -t${conf[USER_TIMEOUT]} -rsn1 -u ${__socat[0]} __res
		echo -e "${BOLD}${__res}${NOR}\r" >&${__socat[1]}
	fi
	if [[ ${__crypttab} -eq 1 && ( "${__res,,}" == "y" || "${__res}" == $'\r' || -z "${__res}" ) ]]; then
		sed -i "/^${__del_crypt}\\s/D" ${conf[CRYPTTAB]}
		kill -SIGHUP ${pid_daemon}
		echo -e "\r${BOLD}${GRN}Removed ${__del_dev} as ${__del_crypt} TRIM ${__del_trim} from Crypttab${NOR}\r" >&${__socat[1]}
	fi

	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}
	do_log debug2 "${__myname} finished after $(do_timer ${__time_start})s"
}

daemon_control_add()
{
	# Add the crypt received on the cryptdiskd command line and to crypttab if requested.
	do_control_init "add" "Adding Crypt"
	local __add_crypt="${msg[5]}" __add_dev="${msg[6]}" __add_dev2 __add_pp"${msg[7]}" __add_trim="${msg[8]}" __res="" __crypt_arr2 __passphrase="" __pid_putkey
	
	if [[ ${__crypttab} -eq 0 && -z "${__crypt_arr[0]}" ]]; then
		# Recevied add with just a crypt, if it's not on the tab exit.
		echo -e "\r${BOLD}${RED}${__add_crypt} not on Crypttab${NOR}\r" >&${__socat[1]}
		trap_term_control 1
	elif [[ ${__crypttab} -eq 1 ]]; then
		# Crypt should be added to tab, check if specified crypt and dev are already on tab.
		__crypt_arr2=($(do_xcrypt_fromtab "${__myname}" "${__add_dev}"))
		if [[ -z "${__crypt_arr[@]}" && -z "${__crypt_arr2[@]}" ]]; then
			# Crypt and dev not on tab, find device.
			__add_dev="$(do_find_dev "${__myname}" "${__add_dev}")" __add_dev2="$(do_find_dev "${__myname}" "${__add_crypt}")"
			if [[ -z "${__add_dev}" && -z "${__add_dev2}}" ]]; then
				echo -e "\r${BOLD}${RED}Neither ${__add_crypt} nor ${__add_dev} is a Valid Block Device in ${conf[BLOCKDEVDIRS]}.${NOR}\r" >&${__socat[1]}
				trap_term_control 1
			elif [[ ! -z "${__add_dev}" && ! -z "${__add_dev2}" ]]; then
				echo -e  "\r${BOLD}${RED}Both ${__add_crypt} and ${__add_dev} are Valid Block Devices in ${conf[BLOCKDEVDIRS]}'.${NOR}\r" >&${__socat[1]}
				trap_term_control 1
			elif [[ ! -z "${__add_dev2}" ]]; then
				# Device was specified before crypt, swap paramters.
				__add_crypt="${msg[6]}" __add_dev="${__add_dev2}"
			fi
		else
			# Crypt and/or dev already on tab.
			if [[ ! -z "${__crypt_arr[@]}" && ! -z "${__crypt_arr2[@]}" ]]; then
				echo -e "\r${BOLD}${RED}${__myname} both ${__add_crypt} and ${__add_dev} Already on Crypttab.${NOR}\r" >&${__socat[1]}
			elif [[ ! -z "${__crypt_arr[@]}" ]]; then
				echo -e "\r${BOLD}${RED}${__add_crypt} Already on Crypttab.${NOR}\r" >&${__socat[1]}
			else
				echo -e "\r${BOLD}${RED}${__add_dev} Aready on Crypttab.${NOR}\r" >&${__socat[1]}
			fi
			trap_term_control 1
		fi
	fi
	if ! do_control_get_passphrase "${__add_pp}"; then
		# if we do not get a passphrase we cannot mount, continue to add on tab after confirmation.
		echo -e "\r${BOLD}${RED}No Passphrase Received, Cannot Mount ${__add_dev} as ${__add_crypt} TRIM ${__add_trim} Using ${__add_pp} Passphrase.${NOR}\r" >&${__socat[1]}
		__confirm=1
	else
		# Notify the daemon about the crypt to mount and inspect result.
		echo "notify ${_pid_ctrl} ${_cmd} ${__add_crypt} ${__add_dev} ${__add_pp} ${__add_trim}" >${conf[FIFO]}
		IFS= read -t${conf[USER_TIMEOUT]} -n1 -r __res
		case ${__res} in
		0)
			echo -e "\r${BOLD}${GRN}Mounted ${__add_dev} as ${__add_crypt} TRIM ${__add_trim} Using ${__add_pp} Passphrase${NOR}\r" >&${__socat[1]};;
		1)
			echo -e "\r${BOLD}${RED}Failed to Mount ${__add_dev} as ${__add_crypt} TRIM ${__add_trim} Using ${__add_pp} Passphrase${NOR}\r" >&${__socat[1]};;
		2)
			echo -e "\r${BOLD}${YEL}${__add_dev} as ${__add_crypt} TRIM ${__add_trim} Using ${__add_pp} Passphrase Already Active${NOR}\r" >&${__socat[1]};;
		3)
			echo -e "\r${BOLD}${YEL}Mounted ${__add_dev} as ${__add_crypt} ${BOLD}${RED}TRIM ${__add_trim} ${BOLD}${YEL}Using ${__add_pp} Passphrase${NOR}\r" >&${__socat[1]};;
		*)
			echo -e "\r${BOLD}${RED}TIMEOUT or ERROR! (${__res})${NOR}\r" >&${__socat[1]}
			trap_term_control 1;;
		esac
	fi

	if [[ ${__crypttab} -eq 1 ]]; then
		# Crypt should be added to tab, ask for confirmation if necessary (error or request by user).
		if [[ ${__res} -ne 0 || ${__confirm} -eq 1 ]]; then
			echo -ne "\r${RED}${BOLD}${__add_crypt} Continue Adding ${__add_dev} as ${__add_crypt} TRIM ${__add_trim} Using ${__add_pp} Passphrase to Crypttab? (Y/n)${NOR}\r" >&${__socat[1]}
			IFS= read -t${conf[USER_TIMEOUT]} -rsn1 -u ${__socat[0]} __res
			echo -e "${BOLD}${__res}${NOR}\r" >&${__socat[1]}
		fi
		if [[ "${__res,,}" == "y" || "${__res}" == $'\r' || -z "${__res}" ]]; then
			# Add the crypt to the crypttab and send reload signal to daemon.
			echo -e "${__add_crypt}\t${__add_dev##*/}\t${__add_pp}\t${__add_trim}" >>${conf[CRYPTTAB]}
			echo -e "\r${BOLD}${GRN}Added ${__add_dev} as ${__add_crypt} Passphrase ${__add_pp} TRIM ${__add_trim} to Crypttab.${NOR}\r" >&${__socat[1]}
			kill -SIGHUP ${pid_daemon}
		fi
	fi
	
	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}
	do_log debug2 "${__myname} finished after $(do_timer ${__time_start})s"
}

do_control_init()
{
	trap 'trap_term_control' SIGINT SIGTERM

	# Initialize the control worker and connect to the requestor socket.
	__crypt_arr=($(do_xcrypt_fromtab "${__myname}" "${msg[5]}")) __myname="daemon-$1 (${BASHPID}:${_pid_ctrl}):" __time_start=$(do_timer)
	
	# Check if socket exists first.
	if [[ ! -S ${_sock_ctrl} ]]; then
		do_log error "${__myname} ${_sock_ctrl} is not a socket, pocket rocket or a locket"
		trap_term_control 1
	fi
	# Start logwriter with dedicated logfile when LOGLEVEL=2 or = 4. When level = 4 redirect out stdout and stderr to the logwriter.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && __pid_logwriter="1>&${fd_logwriter} 2>&1"
		exec {fd_logwriter}> >(logwriter control-$1-${BASHPID}.log ${__pid_logwriter})
		__pid_logwriter=$!
	fi

	# Open the client socket.
	do_log debug "${__myname} connecting to ${_sock_ctrl}"
	coproc __socat { socat - UNIX-CONNECT:${_sock_ctrl}; }
	[[ ${conf[LOGLEVEL]} -ge 3 ]] && echo -e "\r${__myname} Connected for $2.\r" >&${__socat[1]}

	# Check the command line, it should contain crypt, device and passphrase and two options (confirm / crypttab) for add or del.
	if [[ "${_cmd}" == "put" ]]; then
		__confirm=${msg[$((${#msg[@]}-1))]}
	elif [[ "${_cmd}" == "smart" ]]; then
		__smartall=${msg[$((${#msg[@]}-2))]}
		__smarttest=${msg[$((${#msg[@]}-1))]}
	elif [[ "${_cmd}" =~ ^(add|del)$ ]]; then
		__confirm=${msg[$((${#msg[@]}-2))]}
		__crypttab=${msg[$((${#msg[@]}-1))]} 
	fi
}

do_control_get_passphrase()
{
	# Ask to get passphrase from network, if not cached, or query the user for the passphrase.
	local __key="$(keyctl request user "$1")" __pp=$1 __res="" __fd_getpp __pid_getpp __net_status="$(NOTIFY_SOCKET= networkctl status | grep "Online state")"
	if [[ -n "${__key}" ]]; then
		# Passphrase is still cached, use it and notify the daemon about the crypt.
		echo -e "\r${BOLD}${GREEN}Found Cached ${__pp} Passphrase${NOR}\r" >&${__socat[1]}
		__key=1
	else
		echo -e "\r${BOLD}${RED}Passphrase ${__pp} not Cached.${NOR}\r" >&${__socat[1]}
	fi

	# If confirm option is speciefied ask to retreive passphrase from boot servers.
	if [[ ${__key} -ne 1 && ${__confirm} -eq 1 && ( ${conf[NET_ONLINE]} -eq 0 || "${__net_status##*: }" =~ online|partial ) ]]; then
		echo -ne "\r${BOLD}${__pp} Passphrase Not Cached, Get Passphrase from Boot Servers (Y/n)?${NOR}" >&${__socat[1]}
		IFS= read -t${conf[USER_TIMEOUT]} -rsn1 -u ${__socat[0]} ___res
		echo -e "${BOLD}${___res}${NOR}\r" >&${__socat[1]}
	fi

	# Get passphrase from bootservers, we can use the passphrase ssh worker for this.
	if [[ ${__key} -ne 1 && ( ${conf[NET_ONLINE]} -eq 0 || "${__net_status##*: }" =~ online|partial ) && ( "${___res,,}" == "y" || "${___res}" == $'\r' || -z "${___res}" ) ]]; then
		echo -e "\r${BOLD}Getting Passphrase from Boot Servers: ${NOR}${YEL}${bootconf[BOOTSERVERS]}${NOR}\r" >&${__socat[1]}
		[[ ${conf[LOGLEVEL]} -le 2 ]] && exec {__fd_getpp}< <(get_passphrase ${__pp} ${__socat[1]} {__fd_up}>&1- 1>/dev/null 2>&1)
		[[ ${conf[LOGLEVEL]} -gt 2 ]] && exec {__fd_getpp}< <(get_passphrase ${__pp} ${__socat[1]} {__fd_up}>&1- 1>&${fd_logwriter} 2>&1)
		__pid_getpp=$!
		if read -t${conf[USER_TIMEOUT]} -ru${__fd_getpp} __passphrase; then
			__key=1
		else
			echo -e "\r\n${RED}${BOLD}Failed to Get ${__pp} Passphrase for ${__add_crypt} from Boot Servers${NOR}\r" >&${__socat[1]}
			exec {__fd_getpp}>&-
			[[ "$(cat /proc/${__pid_getpp}/comm 2>/dev/null)" == "${MYNAME}" ]] && kill -SIGTERM ${__pid_getpp}
		fi
	fi

	# Query the user for the passphrase.
	if [[ ${__key} -ne 1 ]]; then
		echo -ne "\r${BOLD}Enter ${__pp} passphrase: ${NOR}" >&${__socat[1]}
		until do_control_ask_passphrase; do
			case $? in
			1)
				echo -ne "\r${BOLD}Incorrect ${__pp} Passphrase, Retry: ${NOR}" >&${__socat[1]};;
			2)
				echo -ne "\r${BOLD}Creating Keyfile, Confirm ${__pp} Passphrase: ${NOR}" >&${__socat[1]}
				__passphrase=""
				do_control_ask_passphrase rmkey && break
				echo -ne "\r${BOLD}Passphrases do not Match. Enter ${__pp} Passphrase: ${NOR}" >&${__socat[1]};;
			3)
				echo -e "${BOLD}${RED}TIMEOUT${NOR}\r" >&${__socat[1]}
				return 1;;
		esac
		__passphrase=""
		done
	fi
	put_key "${__pp}" "${__passphrase}" & __pid_putkey=$1
	do_cache_pp "${__pp}" "${__passphrase}" "${__myname}"

	# We will have a passphrase by now.
	return 0
}

do_control_ask_passphrase()
{
	local REPLY="" DEL="$(printf "\x7F")"
	until [[ "${REPLY}" == $'\r' ]]; do
	   	read -t${conf[USER_TIMEOUT]} -rsn1 -u ${__socat[0]} REPLY
		[[ "$?" -gt 128 ]] && return 3
		[[ -z "${REPLY}" ]] && return 1
		if [[ "${REPLY}" == "${DEL}" ]]; then
			if [[ "${#__passphrase}" -ne 0 ]]; then
				echo -ne "\b \b" >&${__socat[1]}
				__passphrase="${__passphrase::-1}"
			fi
			continue
		fi
		if [[ ! "${REPLY}" == $'\r' ]]; then
			__passphrase+="${REPLY}"
			echo -n "*" >&${__socat[1]}
		fi
	done
	echo -e "\r" >&${__socat[1]}
	return $(do_check_passphrase "${__pp}" "${__passphrase}" "${___myname}" $1)$?
}

# [END OF DAEMON CONTROL FUNCTIONS]

# [BEGIN OF DAEMON & READER SHARED FUNCTIONS]

do_xcrypt_fromtab()
{
	# Extract the line for the device received in the udev command from the crypttab into __crypt_arr array.
	# Element 1 = cryptdisk name
	# Element 2 = cryptdisk block device
	# Element 3 = passphrase
	# Element 4 = TRIM
	local i crypt_arr myname=$1
	for ((i=2;i<=$#;i++)); do
		crypt_arr=($(grep -iE "(^|\s)${!i}\s" <<<"${crypttab}" 2>/dev/null)) 
		[[ "${#crypt_arr[@]}" -eq 3 ]] && crypt_arr[3]=0
		if [[ "${#crypt_arr[@]}" -eq 0 ]]; then
			do_log debug "${myname} device ${!i} not found in crypttab"
		elif [[ "${#crypt_arr[@]}" -ne 4 ]]; then
			do_log warning "${myname} incorrect crypttab entry ${crypt_arr[@]}"
			_status=2
		else
			do_log debug2 "${myname} device ${!i} found on crypttab"
			[[ "${crypt_arr[3]}" == "1" || "${crypt_arr[3],,}" == "y" || "${crypt_arr[3],,}" == "yes" ]] && crypt_arr[3]=1 || crypt_arr[3]=0
			echo "${crypt_arr[@]}"
			break
		fi
	done
}

do_eval_pp()
{
	# Evaluate the passphrase and prepend cryptdisks: or make system:master. 
  	if [[ ${1,,} =~ ^(1|master|system|system:master)$ ]]; then
   		echo "system:master"
	elif [[ ! ${1,,} =~ ^cryptdisks: ]]; then
		echo "cryptdisks:${1,,}"
	else 
		echo "${1,,}"
	fi
}

do_find_dev()
{
	local myname=$1 blockdevdir dev=$2
	for blockdevdir in ${conf[BLOCKDEVSDIRS]}; do if [[ -b ${blockdevdir}/${dev} ]]; then
		do_log debug "${myname} found ${blockdevdir}/${dev} for ${dev}"
		echo "${blockdevdir}/${dev}"
		return
	fi done
	do_log debug "${myname} ${dev} not found in ${conf[BLOCKDEVSDIRS]}"
}

do_check_passphrase()
{
	# Check the received passphrase against the stored key in firmware. Write key if it doesn't exist.
	if [ -s ${conf[FWDIR]}/UglyLinux$1.key-${conf[FWGUID]} ]; then
		if  $(cat ${conf[FWDIR]}/UglyLinux$1.key-${conf[FWGUID]} | tail -c +5 | openssl aes-256-cbc -d -salt -pbkdf2 -in - -out /dev/null -k "$2" 2>/dev/null); then
			do_log debug "$3 passphrase check ok"
			return 0
		else
			do_log debug "$3 passphrase check fail"
			if [[ "$4" == "rmkey" ]]; then 
				chattr -i ${conf[FWDIR]}/UglyLinux$1.key-${conf[FWGUID]} 
				rm -f ${conf[FWDIR]}/UglyLinux$1.key-${conf[FWGUID]}
			fi
			return 1
		fi
	else
		do_write_keyfile "$1" "$2" "$3" || return 3
		do_log debug "$3 passphrase not checked"
		return 2
	fi
}

do_write_keyfile()
{
	# Write a keyfile for key received to firmware.
	if ! head -c256 /dev/urandom |openssl aes-256-cbc -e -salt -pbkdf2 -in - -out ${conf[CRYPTDISKSDDIR]}/$1.key -k "$2"; then
		do_log error "$3 error creating ${conf[CRYPTDISKSDDIR]}/$1.key"
	elif ! efivar -n ${conf[FWGUID]}-UglyLinux$1.key -w -f ${conf[CRYPTDISKSDDIR]}/$1.key; then
		do_log error "$3 error writing ${conf[FWDIR]}/UglyLinux$1.key-${conf[FWGUID]}"
	else
		do_log debug "$3 wrote ${conf[FWDIR]}/UglyLinux$1.key-${conf[FWGUID]}"
	fi
	rm -f ${conf[CRYPTDISKSDDIR]}/$1.key
}

do_cache_pp()
{
	local ___key="$(keyctl request user "$1" 2>/dev/null)"
	
	# Cache if the passphrase is already cached.
	if [[ -z "${___key}" ]]; then
		___key="$(keyctl padd user "$1" @s <<<"$2" 2>/dev/null)"
	fi
	if [[ -z "${___key}" ]]; then
		do_log warning "$3 failed to cache $1 passphrase"
		return 1
	fi

	do_log debug "$3 cached $1 passphrase indefinitely"
}

trap_term_get_passphrase() {
	trap 'do_log warning "${___myname} unclean exit after $(do_timer ${___time_start})s"; exit 1' SIGINT SIGTERM

	do_log debug "${___myname} terminating after $(do_timer ${___time_start})"
	local ___srv
	if [[ ! -z "${!___pid_bootserver[@]}" ]]; then for ___srv in ${!___pid_bootserver[@]}; do
		if [[ "$(cat /proc/${___pid_bootserver[${___srv}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${___pid_bootserver[${___srv}]}
			wait ${___pid_bootserver[${___srv}]}
			do_log debug "${___myname} killed ssh (PID: ${___pid_bootserver[${___srv}]})"
		fi
	done fi
	if [[ ! -z ${___pid_querypp} && "$(cat /proc/${___pid_querypp}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${___pid_querypp}
		wait ${___pid_querypp}
		do_log debug2 "${___myname} killed query worker (PID: ${___pid_querypp})"
	fi

	exit 0
}

get_passphrase()
{
	# Get passphrase from bootservers or user. We expect to be called with 3 paramters.
	# 1. The pasphrase to get.
	# 2. fd to the user in case we are getting a passphrase for a control connection.
	# 3 a redirection for {__fd_up} to relay the passphrase back to the caller.
	trap 'trap_term_get_passphrase' SIGINT SIGTERM

	local ___myname="passphrase-get:$1 (${BASHPID}):" ___pp=$1 ___time_start=$(do_timer) ___fd_user=$2 ___passphrase ___fd_querypp ___pid_querypp ___res="" ___srv
	declare -A ___fd_bootserver ___pid_bootserver
	do_log debug "${___myname} started getting ${___pp} passphrase $1 - $2"

	while [[ -z "${___res}" ]]; do
		# Walk through the bootservers and start a worker per server, relay the passphrase to the main worker which will guard the timeout.
		if [[ ${conf[NET_ONLINE]} -ne 1 || "${__net_status##*: }" =~ online|partial ]]; then 
			for ___srv in ${bootconf[BOOTSERVERS]}; do if [[ -z "${___pid_bootserver[${___srv}]}" ]]; then
				do_log debug "${___myname} getting passphrase from ${___srv}"
				[[ ${conf[LOGLEVEL]} -le 2 ]] && exec {___fd_bootserver[${___srv}]}< <(ssh -i ${CONFDIR}/${bootconf[BOOTUSERKEY]} -o UserKnownHostsFile=${CONFDIR}/${bootconf[BOOTSERVERKEYS]} ${bootconf[BOOTUSER]}@${___srv} "GET "${___pp}"" {__fd_up}>&- 2>/dev/null)
				[[ ${conf[LOGLEVEL]} -gt 2 ]] && exec {___fd_bootserver[${___srv}]}< <(ssh -i ${CONFDIR}/${bootconf[BOOTUSERKEY]} -o UserKnownHostsFile=${CONFDIR}/${bootconf[BOOTSERVERKEYS]} ${bootconf[BOOTUSER]}@${___srv} "GET "${___pp}"" {__fd_up}>&- 2>&${fd_logwriter})
				___pid_bootserver[${___srv}]=$!
			fi done

			# Wait a short while and check if we have received a passphrase.
			sleep $((${conf[QUEUE_TIMEOUT]})) & wait $!
			for ___srv in ${!___fd_bootserver[@]}; do if read -t0 -u${___fd_bootserver[${___srv}]}; then
				[[ -z "${___fd_user}" ]] && unset ___pid_bootserver[${___srv}]
				if read -ru${___fd_bootserver[${___srv}]} ___passphrase && [[ $(do_check_passphrase "${___pp}" "${___passphrase}" "${___myname}")$? -ne 1 ]]; then
					___res="${___srv}"
					break 2
				fi
				[[ ! -z "${___fd_user}" ]] && echo -ne "${BOLD}${RED}${___srv} ${NOR}" >&${___fd_user}
				do_log debug "${___myname} failed to get passphrase from ${___srv}"
			fi done
		fi

		# We did not receive a passphrase from boot servers. Start the query worker to ask for a passphrase from the user.
		if [[ -z "${___fd_user}" && -z "${___pid_querypp}" ]]; then
		    [[ ${conf[LOGLEVEL]} -le 2 ]] && exec {___fd_querypp}< <(ppwrk_query_passphrase {__fd_up}>&- {___fd_getpp}>&1- 1>/dev/null 2>&1)
 			[[ ${conf[LOGLEVEL]} -gt 2 ]] && exec {___fd_querypp}< <(ppwrk_query_passphrase {__fd_up}>&- {___fd_getpp}>&1- 1>&${fd_logwriter} 2>&1)
			___pid_querypp=$!
			do_log debug "${___myname} started query passphrase worker (PID: ${___pid_querypp})"
		fi

		# Check if we received a pssphrase from the user.
		if [[ -z "${___fd_user}" && ! -z ${___fd_querypp} ]] && read -t0 -u${___fd_querypp} && read -ru${___fd_querypp} ___passphrase; then
			___res=user
		fi
	done

	# Received a valid passphrase.
	[[ ! -z "${___fd_user}" ]] && echo -e "\r${BOLD}${GREEN}${___srv} ${NOR}\r" >&${___fd_user}
	do_log debug "${___myname} received passphrase from ${___res}"
	echo "${___passphrase}" >&${__fd_up}
	trap_term_get_passphrase
}

trap_term_put_key()
{
	trap 'do_log warning "${___myname} unclean exit after $(do_timer ${___time_start})s"; exit 1' SIGINT SIGTERM

	if [[ ! -z "${!___pid_ssh[@]}" ]]; then
		for ___i in ${!___pid_ssh[@]}; do
			if [[ "$(cat /proc/${___pid_ssh[${___i}]}/comm 2>/dev/null)" == "ssh" ]]; then
				kill -SIGKILL ${___pid_ssh[${___i}]}
				do_log debug2 "${___myname} killed ssh (PID: ${___pid_ssh[${___i}]})"
				unset ___fd_ssh[${___i}] ___pid_ssh[${___i}]
			fi
		done
	fi
	do_log debug2 "${___myname} terminating after $(do_timer ${___time_start})s"
	if [[ ! -z "${___pid_logwriter}" && "$(cat /proc/${___pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${___pid_logwriter}
		wait ${___pid_logwriter}
		do_log debug "${___myname} killed logwiter (PID: ${___pid_logwriter})"
	fi

	exit 0
}

put_key()
{
	trap 'trap_term_put_key' SIGINT SIGTERM

	# Put the key to the the boot servers one by one and log status.
	local ___i ___res ___time_start=$(do_timer) ___myname="put:$1 (${BASHPID}):" ___to ___ts ___pid_logwriter ___net_status="$(NOTIFY_SOCKET= networkctl status | grep "Online state")"
	declare -A ___pid_ssh ___fd_ssh
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && exec {fd_logwriter}> >(logwriter put-$1-${BASHPID}.log) 1>&${fd_logwriter} 2>&1 || exec {fd_logwriter}> >(logwriter put-$1-${BASHPID}.log)
		___pid_logwriter=$!
	fi
	do_log debug "${___myname} putting $1 to boot servers"

	# When starting wait for network before trying to put keys to servers.
	if [[ ${starting} -ne 0 && ${conf[NET_ONLINE]} -eq 1 ]]; then
		___ts=$(do_timer) ___to=0
		until [[ ${___to} -ge ${conf[START_TIMEOUT]} || "${___net_status}" =~ online|partial ]]; do
			sleep ${conf[QUEUE_TIMEOUT]} & wait $!
			___net_status="$(NOTIFY_SOCKET= networkctl status | grep "Online state")"
			___to=$((${___to}+$(do_timer ${___ts} |cut -d. -f1)))
		done
	fi

	# For every boot server start an ssh process to put the key in the background.
	for ___i in ${bootconf[BOOTSERVERS]}; do
		do_log debug "${___myname} putting key to ${___i}"
		exec {___fd_ssh[${___i}]}< <(ssh -i ${CONFDIR}/${bootconf[BOOTUSERKEY]} -o UserKnownHostsFile=${CONFDIR}/${bootconf[BOOTSERVERKEYS]} ${bootconf[BOOTUSER]}@${___i} "PUT "$1" "$2"")
		___pid_ssh[${___i}]=$!
	done

	# Until timeout is reached check all the fd for the status of the put key commands.
	___ts=$(do_timer) ___to=0
	while [[ ! -z "${!___pid_ssh[@]}" && ${___to} -lt ${conf[PP_TIMEOUT]} ]]; do  
		for ___i in ${!___pid_ssh[@]}; do if read -t0 -u${___fd_ssh[${___i}]}; then
			# SSH put key finished read status.
			read -ru${___fd_ssh[${___i}]} ___res
			if [[ "${___res,,}" == "ok" ]]; then
				do_log debug "${___myname} put $1 key on ${___i} for ${bootconf[BOOTUSER]} succeeded"
			elif [[ "${___res,,}" == "same" ]]; then
				do_log info "${___myname} put $1 key on ${___i} for ${bootconf[BOOTUSER]} equal"
			else
				do_log warning "${___myname} put $1 key on ${___i} for ${bootconf[BOOTUSER]} failed"
			fi
			unset ___fd_ssh[${___i}] ___pid_ssh[${___i}]
		fi done
		sleep ${conf[QUEUE_TIMEOUT]} & wait $!
		___to=$((${___to}+$(do_timer ${___ts} |cut -d. -f1)))
	done
	# Check for connections that timed out.
	if [[ ! -z "${!___pid_ssh[@]}" ]]; then
		for ___i in ${!___pid_ssh[@]}; do
			do_log debug "${___myname} put $1 key on ${___i} for ${bootconf[BOOTUSER]} timeout"
			[[ "$(cat /proc/${____pid_ssh[${___i}]}/comm 2>/dev/null)" == "ssh" ]] && kill -SIGKILL ${___pid_ssh[${___i}]} && do_log debug2 "${___myname} killed ssh (PID: ${___pid_ssh[${___i}]})"
			unset ___fd_ssh[${___i}] ___pid_ssh[${___i}]
		done
	fi

	do_log debug2 "${___myname} finished after $(do_timer ${___time_start})s"
}

# [END OF DAEMON & READER SHARED FUNCTIONS]

# [BEGIN OF UDEV QUEUE READER FUNCTIONS

trap_term_reader()
{
	trap 'do_log warning "${_myname} unclean exit after $(do_timer ${_time_start})s"; exit 1' SIGINT SIGTERM

	# Reader received SIGTERM or SIGINT. See if we have any workers to kill and remove the queue.
	_time_active="$(do_timer ${_time_start})"
	do_log debug2 "${_myname} terminating after ${_time_active}s"

	# Kill all active passphrase workers.
	local _pp
	for _pp in ${!_pid_ppwrk[@]}; do
		if [[ ! -z "${_pid_ppwrk[${_pp}]}" && "$(cat /proc/${_pid_ppwrk[${_pp}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_ppwrk[${_pp}]}
			wait ${_pid_ppwrk[${_pp}]}
			do_log debug2 "${_myname} killed passphrase worker for ${_pp} (PID: ${_pid_ppwrk[${_pp}]})"
		fi
	done
	for _pp in ${!_pid_putkey[@]}; do
		if [[ ! -z "${_pid_putkey[${_pp}]}" && "$(cat /proc/${_pid_putkey[${_pp}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_putkey[${_pp}]}
			wait ${_pid_putkey[${_pp}]}
			do_log debug2 "${_myname} killed putkey worker for ${_pp} (PID: ${_pid_putkey[${_pp}]})"
		fi
	done
	for __pp in ${!_pid_shell[@]}; do
		if [[ "$(cat /proc/${_pid_shell[${__pp}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_shell[${__pp}]}
			wait ${_pid_shell[${__pp}]}
		fi
	done

	# If we are in startup we should not be terminated, exit with error. Otherwise exit with current status.
	if [[ "${_starting}" -ne 0 ]]; then
		do_log error "${_myname} terminated while in startup"
	fi
	if [[ "$(cat /proc/${_pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${_pid_logwriter}
		wait ${_pid_logwriter}
	fi

	exit 0
}

trap_hup_reader()
{
	# Received reload request from systemd. Reload the config when not handling command and no active workers.
	_time_active=$(do_timer ${_time_start})
	if [[ ${_starting} -eq 0 && ${_confok} -eq 0 ]]; then
		do_log warning "${_myname} received SIGHUP, reload config asap"
		if [[ -z "${_cmd}" ]]; then
			do_reader_cleanup
			if [[ -z "${!_waiting_mnt[@]}" ]]; then
				do_reader_notify_daemon "reload"
				trap_term_reader
			fi
		fi
		_confok=1
	elif [[ ${_starting} -ne 0 ]]; then
		do_log warning "${_myname} start timeout reached after ${_time_active}s, running cleanup"
		do_reader_cleanup
		_starting=0
		echo ping >${conf[FIFO]}
	fi
}

udev_reader()
{
	trap 'trap_term_reader' SIGINT SIGTERM
	trap 'trap_hup_reader' SIGHUP

	# The reader process will read commands from the queue. When command is read some atomical stuff needs to be done
	# At the very least we should check for any running password workers, start worker process and keep track of them all.
	# Just like the daemon process the reader will run a cleanup timer and do cleanup every conf[CLEANUP_TIMER].
	local _pid_reader=${BASHPID} _myname="reader (${BASHPID}):" _time_start=$(do_timer) _time_active=0.000 _read_to __myname _cmd=()
 	local _nr_cmds=0 _start_status=0 _cleanup=0.000 _pid_logwriter _key= _fd_fifo _pp _confok=0 _starting=${starting} _crypt_arr _crypt _dev _trim _time
	declare -A _pid_ppwrk _pid_putkey _pid_shell _waiting_mnt
	
	# Start logwriter with dedicated logfile when LOGLEVEL=2 or = 4. When level = 4 redirect out stdout and stderr to the logwriter.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && exec {fd_logwriter}> >(logwriter reader-${_pid_reader}.log {fd_daemon}>&-) 1>&${fd_logwriter} 2>&1 || exec {fd_logwriter}> >(logwriter reader-${_pid_reader}.log {fd_daemon}>&-)
		_pid_logwriter=$!
	fi
	do_log info "${_myname} initializing"

	exec {_fd_fifo}<>${conf[FIFO]}
	while true; do
		# If we are starting up, read time-out when initial queue is empty so we can notify parent.
		# If we are in normal op, keep cleanup timer (60secs).
		time_active=$(do_timer ${time_start})

		# Rceived SIGHUP. Do a config reload (restart the reader), when no active workers.
		if [[ ${_starting} -eq 0 && ${_confok} -eq 1 && -z "${!_waiting_mnt[@]}" ]]; then
			do_reader_notify_daemon "reload"
			trap_term_reader
		fi

		# Evaluate the queue read timeout, to see at which point in time we are.
		case ${_starting} in
			0|2)
				# Evaluate cleanup timer against daemon active time
				if [[ ${_confok} -eq 1 ]] || [[ ${time_active:0:-4} -gt $((${_cleanup:0:-4}+${conf[CLEANUP_TIMER]}-${conf[QUEUE_TIMEOUT]})) ]] || [[ ${_res} -eq 142 && ${_read_to##* } -gt $((conf[CLEANUP_TIMER]/2)) ]]; then
					do_reader_cleanup
				fi
				if [[ ${_confok} -eq 1 ]]; then
					# If we need to reloud config use a short timeout.		
					_read_to="-t${conf[QUEUE_TIMEOUT]}"
				else
					_read_to="-t$(((${conf[CLEANUP_TIMER]}+${conf[QUEUE_TIMEOUT]})-((${time_active:0:-4}+${conf[CLEANUP_TIMER]}/2)%${conf[CLEANUP_TIMER]})))"
				fi;;
			1)
				# Make sure the read timeout is never 0 as this will complicate things (read will not read if to = 0).
				_read_to="-t${conf[QUEUE_TIMEOUT]}";;
		esac
        
		# Start reading from the queue.
		IFS=' ' read ${_read_to} -ru${_fd_fifo} -a _cmd
		local _res=$?

		if [[ ${_res} -eq 142 ]]; then
			# Read timed out. Set the starting status if we are starting up, or run cleanup.
			# Cleanup will start after conf[START_TIMEOUT] to give all initial workers the chance to finish.
			if [[ ${_starting} -ne 0 && -z "${!_waiting_mnt[@]}" ]]; then
				_starting=0
				do_reader_cleanup
				do_reader_notify_daemon "started ${_starting} ${_start_status}"
			elif [[ ${_starting} -eq 1 ]]; then
				_starting=2
				do_reader_notify_daemon "started ${_starting} ${_start_status}"
			fi
			do_log debug2 "${_myname} running since $(do_timer date ${_time_start})"
			continue
		elif [[ ${_res} -gt 128 ]]; then
			# Should not happen, only if we received signal during read.
			do_log debug "${_myname} read result ${_res} may have been trapped"
			[[ ${_cleanup} -eq 0 ]] && do_reader_cleanup
		elif [[ ${_res} -ne 0 ]]; then
			do_log error "${__myname} read error, terminating after $(do_timer ${_time_start})s"
			do_reader_notify_daemon "reload"
			trap_term_reader
		fi

		if [[ -z "${_cmd[@]}" ]]; then
			do_log error "${_myname} reached EOF on queue, terminating"
			do_reader_notify_daemon "reload"
			trap_term_reader
		fi

		# Parse the command, the first element in the array is the command itself, the other elements the arguments to the command.
		# From UDEV we will receive add and remove commands with one paramter only, the disk.
		__myname="${_myname} ${_nr_cmds} -" __time_start=$(do_timer) _nr_cmds=$((_nr_cmds+1))
		do_log debug "${__myname} new command received \"${_cmd[@]}\""
		case ${_cmd[0],,} in
			add|change)
				_crypt_arr=($(do_xcrypt_fromtab "${__myname}" "${_cmd[@]:1}"))
				[[ ! -z "${_crypt_arr[@]}" ]] && do_reader_add_crypt;;
			remove)
				_crypt_arr=($(do_xcrypt_fromtab "${__myname}" "${_cmd[1]}"))
				[[ ! -z "${_crypt_arr[@]}" ]] && do_reader_notify_daemon "remove ${_crypt_arr[0]}";;
			passphrase)
				while IFS=' ' read -rd, _crypt _dev _trim _time; do
					do_log debug2 "${__myname} daemon can mount ${_dev} as ${_crypt} TRIM ${_trim} using ${__pp} passphrase, waited for $(do_timer ${_time})s"
					do_reader_notify_daemon "add ${_crypt} ${_dev} ${_cmd[1]} ${_trim}"
				done <<<"${_waiting_mnt[${_cmd[1]}]}"
				unset _waiting_mnt[${_cmd[1]}] _pid_ppwrk[${_cmd[1]}]
				if [[ ${_starting} -ne 0 && -z ${!_waiting_mnt[@]} ]]; then
					_starting=0
					do_reader_notify_daemon "started ${_starting} ${_start_status}"
					do_reader_cleanup
				fi;;
			control|notify)
				case ${_cmd[2]} in
					status|smart|erase|finished|add|del|put|rmkey)
						do_reader_notify_daemon "${_cmd[@]}";;
					shell) 
						reader_control_shell {_fd_fifo}>&- &
						_pid_shell[${_cmd[1]}]=$!;;
					*) 
					do_log debug "${__myname} received invalid control command \"${_cmd[@]:2}\"";;
				esac;;
			ping)
				do_log debug2 "${__myname} pong";;
			*)
				do_log debug "${__myname} received invalid command: \"${_cmd[@]}\"";;
		esac
		_time_active="$(do_timer ${__time_start})"
		do_log debug2 "${__myname} processing command \"${_cmd[@]}\" took ${__time_active}s total"

		do_log debug2 "${_myname} running since $(do_timer date ${_time_start})"
	done

	# We should never get here, exit with error if we do.
	do_log error "${_myname} terminated unexpectedly after $(do_timer ${_time_start})s"
	trap_term_reader
}

reader_control_shell()
{
	trap 'trap_term_control' SIGINT SIGTERM 

	# Open a debug shell, will run under root so be careful with this.
	local __myname __time_start __socat __pid_logwriter="" __pid_ctrl="${_cmd[1]}" __sock_ctrl="${conf[CRYPTDISKSDDIR]}/${MYNAME}-${_cmd[1]}.sock"
	__myname="reader-shell ${_nr_shell} (${BASHPID}:${__pid_ctrl}):" __time_start=$(do_timer)

	# Start logwriter with dedicated logfile when LOGLEVEL=2 or = 4. When level = 4 redirect out stdout and stderr to the logwriter.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && exec {fd_logwriter}> >(logwriter shell-${_pid_reader}.log {_fd_fifo}>&- {fd_daemon}>&-) 1>&${fd_logwriter} 2>&1 || exec {fd_logwriter}> >(logwriter shell-${_pid_reader}.log {_fd_fifo}>&- {fd_daemon}>&-)
		__pid_logwriter=$!
	fi
	
	if [[ ! conf[DEBUGSHELL] -eq 1 ]]; then
		do_log error "${__myname} debug shell not enabled"
		kill -SIGTERM ${__pid_ctrl}
		trap_term_control
	fi

	# Open a connection to the listening socket. Check if it exists first.
	TERM=xterm; coproc __socat { socat exec:"bash -i",pty,stderr,setsid,sigint,sane UNIX-CONNECT:${__sock_ctrl}; }
	do_log warning "${__myname} debug shell started"
	wait ${__socat_PID}
	do_log warning "${__myname} debug shell ended"
}

do_reader_add_crypt()
{
	# The add command received from UDEV will contain 1 argument, the block device that is added.
	# At least a mount worker for adding the cryptdisk A passphrase worker process is spawned if there is not already 
	# one running for the passphrase. We will keep a list of passhrase workers and mount workers using that passphrase.
	local _add_crypt="${_crypt_arr[0]}"  _add_dev="$(do_find_dev "${__myname}" "${_crypt_arr[1]}")" _add_pp="$(do_eval_pp "${_crypt_arr[2]}")" _add_trim="${_crypt_arr[3]}" _key="" _passphrase=""
	[[ ${_starting} -eq 1 ]] && _key="$(keyctl search @u user "${_add_pp}" 2>/dev/null)" && _passphrase="$(keyctl pipe "${_key}" 2>/dev/null)"
	
	# Set the variables for the crypt to be added, search for the backing device in conf[BLOCKDEVSDIRS].	
	do_log debug "${__myname} adding ${_crypt_arr[1]} as ${_add_crypt} TRIM ${_add_trim} using ${_add_pp} passphrase"
	if [[ -z "${_add_dev}" ]]; then
		do_log warning "${__myname} ${_crypt_arr[1]} not found in ${conf[BLOCKDEVSDIRS]}"
		[[ _start_status -eq 0 ]] && _start_status=2
		return
	elif [[ ! -z "${_key}" ]]; then
		do_log info "${__myname} found cached ${_add_pp} passphrase in user keyring"
		keyctl revoke "${_key}" 2>/dev/null
		keyctl unlink "${_key}" @u 2>/dev/null
		put_key "${_add_pp}" "${_passphrase}" {_fd_fifo}>&- & do_cache_pp "${_add_pp}" "${_passphrase}" "${__myname}"
		_pid_putkey[${_add_pp}]=$!
		do_reader_notify_daemon "add ${_add_crypt} ${_add_dev} ${_add_pp} ${_add_trim}"
		return 
	elif [[ ! -z "$(keyctl request user "${_add_pp}" 2>/dev/null)" ]]; then
		# Passphrase is still cached, uotify the daemon about the crypt.
		do_log info "${__myname} found cached ${_add_pp} passphrase" 
		do_reader_notify_daemon "add ${_add_crypt} ${_add_dev} ${_add_pp} ${_add_trim}"
		return 
	elif grep -e "${_add_crypt} ${_add_dev} ${__app_trim} " <<<${_waiting_mnt[${_add_pp}]}; then
		# Check if crypt is already waiting
        do_log debug "${__myname} ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} already on waiting list"
		return
	fi

	# No worker and no passphrase cached, start new worker.
	do_log debug "${__myname} adding ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} to waiting list for ${_add_pp} passphrase"
	_waiting_mnt[${_add_pp}]+="${_add_crypt} ${_add_dev} ${_add_trim} $(do_timer),"
	do_log debug2 "${__myname} waiting mnt for ${_add_pp}: ${_waiting_mnt[${_add_pp}]:0:-1}"
	if [[ -z "${_pid_ppwrk[${_add_pp}]}" ]]; then
		do_log debug "${__myname} no cached passphrase or active worker for ${_add_pp}, starting"
		udev_reader_ppwrk {_fd_fifo}>&- {fd_daemon}>&- &
		_pid_ppwrk[${_add_pp}]=$!
	fi

	do_log debug2 "${__myname} ${_cmd[0],,} ${_crypt_arr[@]} took $(do_timer ${__time_start})s"
}

do_reader_notify_daemon()
{
	[[ -z "${__myname}" ]] && local __myname="${_myname}"
	echo "reader ${_pid_reader} $@" >&${fd_daemon}
	do_log debug "${__myname} sent message \"$@\" to daemon (PID: ${pid_daemon})"
}

do_reader_cleanup()
{
	# Reader cleanup routine. Check all the active workers, se if they're still running, terminate after timeout.
	local __myname="reader cleanup (${BASHPID}):" __time_start=$(do_timer) __waiting_mnt="" _crypt _dev _pp __trim _time _to
	_cleanup=$(do_timer ${time_start})
	_time_active=$(do_timer ${_time_start})
	do_log debug "${_myname} cleanup starting at ${_time_active}"

	# Check logwriter status, restart if necessary.
	if [[ ! -z ${_pid_logwriter} ]]; then
		if [[ "$(cat /proc/${_pid_logwriter}/comm 2>/dev/null)" != "${MYNAME}" ]] || ! kill -0 ${_pid_logwriter} && kill -SIGKILL ${_pid_logwriter}; then
			[[ ${conf[LOGLEVEL]} -eq 4 ]] && exec {fd_logwriter}> >(logwriter reader-${_pid_reader}.log) {_fd_fifo}>&- 1>&${fd_logwriter} 2>&1 || exec {fd_logwriter}> >(logwriter reader-${_pid_reader}.log)
			do_log error "${_myname} logwriter (PID: ${_pid_logwriter}) terminated after ${_time_active}s, restarted"
			_pid_logwriter=$!
		fi
	fi

	# Cleanup shells.
	if [[ ! -z "${!_pid_shell[@]}" ]]; then
		for	_pp in ${!_pid_shell[@]}; do
			[[ "$(cat /proc/${_pid_shell[${_pp}]}/comm 2>/dev/null)" != "${MYNAME}" ]] && unset _pid_shell[${_pp}]
		done
	fi

	# Remove too long outstanding mounts and passphrase workers.
	if [[ ${_starting} -eq 0 ]]; then for _pp in ${!_waiting_mnt[@]}; do
		while IFS=" " read -rd, _crypt _dev __trim _time; do
			_to=$(do_timer ${_time})
			if [[ ${_to:0:-4} -ge $((conf[PP_TIMEOUT])) ]]; then
				do_log debug "${_myname} cleanup removed waiting mount for ${__add_pp}: ${_crypt} - ${_dev} - ${__trim}"
			else
				do_log debug2 "${_myname} cleanup readded waiting mount for ${__add_pp}: ${_crypt} - ${_dev} - ${__trim}"
				__waiting_mnt+="${_crypt} ${_dev} ${__trim} ${_time},"
			fi
		done <<<"${_waiting_mnt[${_pp}]}"
		if [[ ! -z "${__waiting_mnt}" ]]; then
			_waiting_mnt[${_pp}]="${__waiting_mnt}"
		else
			unset _waiting_mnt[${_pp}] _pid_pp[${_pp}]
		fi
	done fi
	
	# Notify daemon we are still active.
	do_reader_notify_daemon "active"

	[[ -z "${!_pid_ppwrk[@]}" ]] && _pp="no active workers" || _pp="active workers for ${!_pid_ppwrk[@]}"	
	do_log debug2 "${_myname} cleanup done in $(do_timer ${_time_start})s, ${_pp}"
}

# [END OF UDEV QUEUE READER FUNCTIONS]

# [BEGIN OF PASSPHRASE WORKER FUNCTIONS]

trap_term_ppwrk()
{
	trap 'do_log warning "${__myname unclean exit after $(do_timer ${__time_start})s"; exit 1' SIGINT SIGTERM

	# Kill the workers and exit.
	do_log debug2 "${__myname} terminating after $(do_timer ${__time_start})s"
	if [[ ! -z ${__pid_getpp} && "$(cat /proc/${__pid_getpp}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_getpp}
		wait ${__pid_getpp}
		do_log debug2 "${__myname} killed get worker (PID: ${__pid_getpp})"
	fi
	if [[ ! -z ${__pid_putkey} && "$(cat /proc/${__pid_putkey}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_putkey}
		wait ${__pid_putkey}
		do_log debug2 "${__myname} killed put key worker (PID: ${__pid_putkey})"
	fi
	if [[ ! -z "${__pid_logwriter}" && "$(cat /proc/${__pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_logwriter}
		wait ${__pid_logwriter}
		do_log debug2 "${__myname} killed log writer (PID: ${__pid_logwriter})"
	fi

	exit $1
}

udev_reader_ppwrk()
{
	trap 'trap_term_ppwrk' SIGINT SIGTERM

	# We need to get a passphrase. We will start a worker to get the passphrase from the boot servers
	# and a worker to ask for the passphrase using systemd-ask-password at the same time.
	# The workers will notify the daemon if they get a passphrase.
	local __pid_ppwrk=${BASHPID} __myname="passphrase:${_add_pp} (${BASHPID}):" __fd_up __time_start=$(do_timer) __pid_logwriter
	local __fd_getpp __pid_getpp __fd_querypp __pid_querypp __pid_putkey __passphrase="" __time_active=$(do_timer ${_time_start}) __to
	local __net_status="$(NOTIFY_SOCKET= networkctl status | grep "Online state")"

	# Start a logwriter when LOGLEVEL = 2 or 4, redirect our stdout and stderr to that logwiter whenn level = 4.
	if [[ ${FOREGROUND} -ne 1 && ${conf[LOGLEVEL]} -eq 2 ]]; then
		exec {fd_logwriter}> >(logwriter passphrase-${_add_pp}-${__pid_ppwrk}.log)
	elif [[ ${FOREGROUND} -ne 1 && ${conf[LOGLEVEL]} -eq 4 ]]; then
		exec {fd_logwriter}> >(logwriter passphrase-${_add_pp}-${__pid_ppwrk}.log) 1>&${fd_logwriter} 2>&1
	fi
	__pid_logwriter=$!
	do_log debug "${__myname} started"

	# When starting we will wait max PP_TIMEOUT for the network to come up, or fail.
	[[ ${conf[NET_ONLINE]} -eq 1 && ${_starting} -ne 0 ]] && until [[ "${__net_status##*: }" =~ online|partial ]]; do
		sleep ${conf[QUEUE_TIMEOUT]} & wait
		__net_status="$(NOTIFY_SOCKET= networkctl status | grep "Online state")"
		__time_active=$(do_timer ${__time_start})
		[[ ${__time_active%%.*} -ge ${conf[PP_TIMEOUT]} || "${__net_status##*: }" =~ offline ]] && break
	done

	# Start the worker to get the passphrase from the boot servers or from the user. fd 4 will point back to us.
	if [[ ${conf[LOGLEVEL]} -le 2 ]]; then
		exec {__fd_getpp}< <(get_passphrase ${_add_pp} {__fd_up}>&1- 1>/dev/null 2>&1)
	else
		exec {__fd_getpp}< <(get_passphrase ${_add_pp} {__fd_up}>&1- 1>&${fd_logwriter} 2>&1)
	fi
	__pid_getpp=$!
	do_log debug "${__myname} started get passphrase worker (PID: ${__pid_getpp})"

	# We should get a pssphrase or an empty response from the workers or timeout.
	[[ ${_starting} -ne 0 ]] && __to=${conf[START_TIMEOUT]} || __to=${conf[PP_TIMEOUT]}
	if ! read -t${__to} -u${__fd_getpp} __passphrase; then
		do_log warning "${__myname} timeout after $(do_timer ${__time_start})s"
		trap_term_ppwrk 1
	fi

	# Put key (back) to servers, cache and send to reader.
	put_key "${_add_pp}" "${__passphrase}" & __pid_putkey=$!
	do_cache_pp "${_add_pp}" "${__passphrase}" "${__myname}" || trap_term_ppwrk 1
	echo "passphrase ${_add_pp}" >${conf[FIFO]}

	do_log debug2 "${__myname} took $(do_timer ${__time_start})s"
	wait ${__pid_putkey}
	trap_term_ppwrk 0
}

trap_term_ppwrk_query_passphrase()
{
	trap 'do_log warning "${__myname} unclean finish after $(do_timer ${___time_start})s"; exit 1' SIGINT SIGTERM

	# Close the fd to the reader, we don't need it and should not keep it.
	if [[ ! -z "${___pid_askpp}" && "$(cat /proc/${___pid_askpp}/comm 2>/dev/null)" == "systemd-ask-pas" ]]; then
		kill -SIGKILL ${___pid_askpp}
		do_log debug2 "${___myname} killed ask worker (PID: ${___pid_askpp})"
	fi
	if [[ ! -z "${___pid_putkey}" && "$(cat /proc/${___pid_putkey}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${___pid_putkey}
		wait ${___pid_putkey}
		do_log debug2 "${___myname} killed putkey worker (PID: ${___pid_putkey})"
	fi

	do_log debug2 "${___myname} terminating after $(do_timer ${___time_start})s"
	exit 0
}

ppwrk_query_passphrase()
{
	trap 'trap_term_ppwrk_query_passphrase' SIGINT SIGTERM

	# Ask for a pssphrase input by user through systemd-ask-password
	local ___myname="passphrase_query:${_add_pp} (${BASHPID}):" ___time_start=$(do_timer) ___time_active ___pid_askpp ___fd_askpp ___pid_putkey
	do_log debug "${___myname} query for ${_add_pp} passphrase started"

	do_ppwrk_ask_passphrase "Enter ${_add_pp} Passphrase: "

	# Received a passphrase from the user check it against key stored in firmware.
	local ___ppchk=$(do_check_passphrase "${_add_pp}" "${__passphrase}" "${___myname}")$?
	if [[ ${___ppchk} -eq 3 ]]; then
		do_log error "${___myname} Unable to confirm passphrase due to key error, giving up"
		trap_term_ppwrk_query_passphrase

	elif [[ ${___ppchk} -eq 2 ]]; then
		# Key not present in firmware, ask for confirmation from the user.
		local ___passphrase="${__passphrase}"
		do_ppwrk_ask_passphrase "Created key file. Confirm ${_add_pp} Passphrase: "
		# If the passphrase does not match, enter a loop until it does and wirte the keyfile if ok.
		until [[ "${___passphrase}" == "${__passphrase}" ]]; do
			do_ppwrk_ask_passphrase "Passphrases do not Match. Enter ${_add_pp} Passphrase: "
			___passphrase="${__passphrase}"
			do_check_passphrase "${_add_pp}" "${__passphrase}" "${___myname}" rmkey
			do_ppwrk_ask_passphrase "Confirm ${_add_pp} Passphrase: "
			[[ "${___passphrase}" == "${__passphrase}" ]] && do_write_keyfile "${_add_pp}" "${__passphrase}" "${___myname}"
		done
		do_log debug "${___myname} received passphrase after $(do_timer ${___time_start})s"

	elif [[ ${___ppchk} -eq 1 ]]; then
		# Passphrase entered does not match stored key, keep asking until it does.
		until [[ ${___ppchk} -eq 0 ]]; do
			do_log debug2 "${___myname} query passphrase check failed"
			do_ppwrk_ask_passphrase "Incorrect Passphrase. Enter ${_add_pp} Passphrase: "
			___ppchk=$(do_check_passphrase "${_add_pp}" "${__passphrase}" "${___myname}")$?
		done
		do_log debug "${___myname} received passphrase after $(do_timer ${___time_start})s"

	elif [[ ${___ppchk} -eq 0 ]]; then
		# Passphrase received is ok.
		do_log debug "${___myname} received passphrase after $(do_timer ${___time_start})s"
	fi
 
 	# Notify the reader, so it knows passphrase worker has finished.
	echo "${__passphrase}" >&${___fd_getpp}
	
	do_log debug2 "${___myname} took $(do_timer ${___time_start})s total"
}

do_ppwrk_ask_passphrase()
{
	# Query for the passphrase in the background, record pid so we can kill if passphrase is received from server.
	___time_active=$(do_timer ${___time_start})

	if [[ ${conf[LOGLEVEL]} -le 2 ]]; then
		exec {___fd_askpp}< <(NOTIFY_SOCKET= systemd-ask-password --timeout=0 --id=${_add_pp} "$1" {___fd_getpp}>&- 2>/dev/null)
	else
		exec {___fd_askpp}< <(NOTIFY_SOCKET= systemd-ask-password --timeout=0 --id=${_add_pp} "$1" {___fd_getpp}>&- 2>&${fd_logwriter})
	fi
	___pid_askpp=$!
	IFS= read -ru${___fd_askpp} __passphrase
}

# [END OF PASSPHRASE WORKER FUNCTIONS]

# [START OF UDEV PROCESSING FUNCTIONS]

do_cryptdisksd_udev()
{
	[[ -z "${conf[FIFO]}" ]] && conf[FIFO]=/run/${MYNAME}/${MYNAME}.queue

	# Parse the udev command line and prepare the message to be put on the queue. Udev can only be run by root.
	if [[ ${UID} -ne 0 || -z "${ACTION}" ]]; then
		echo "${MYNAME} udev queue can only be started from udev"
		exit 1
	fi

	# Prepare the message, first check if there is a confdir specified on command line, or load from systemd if not so.
	local __msg="${ACTION}" __res=1 __command=udev __args=$#
	if [[ -z "${CONFDIR}" ]]; then
		local _t="$(grep -ie "^CONFDIR=\/" /etc/systemd/${MYNAME}.conf)"
		CONFDIR="${_t##*=}"
	fi
	shift
	
	# Enter a loop to check if any of the arguments specified is a command, error exit if so, add parameter to message if ok.
	while [[ ! -z "$1" ]]; do
		do_parse_opt $@; __res=$?
		if [[ ${__res} -eq 0 ]]; then
			__msg+=" $1"
			shift
		else
			logger -p daemon.error "${MYNAME} cannot name crypt or dev \"$1\""
			shift
		fi
	done

	# Put the message (if any) on the queue.
	if [[ "${__msg}" == "${ACTION}" ]]; then
		exit 1
	else
		echo "$@" >${conf[FIFO]} 
	fi

	exit 0
}

# [END OF UDEV PROCESSING FUNCTIONS]

# [START OF INTERACTIVE CONTROL FUNCTIONS]

do_echo_use()
{
	[[ -z "${conf[RUNDIR]}" ]] && { do_init_conf || echo -e "${RED}${MYNAME}, Error Loading Configuration from ${CONFDIR}${NOR}"; }
	echo -e "${GREY}${BOLD}${MYNAME} (Encrypted Block Device Manager)${NOR}\n"
	case $1 in
		status)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tDisplays Status of Encrypted Block Devices"
			echo -e "\t\t\t\tCommand Has no Options or Arguments\n"
			;;
		stop)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tStops the Encrypted Device Manager"
			echo -e "\t\t\t\tCommand Has no Options or Arguments\n"
			;;
		reload)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tReloads the Configuration of the Encrypted Device Manager"
			echo -e "\t\t\t\tCommand Has no Options or Arguments\n"
			;;
		add)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tAdd an Encrypted Block Device to the Manager\n"
			echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hct ] { crypt | device } || { -p passphrase crypt device }${NOR}\n\n"
			echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
			echo -e "\t${BOLD}-c${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
			echo -e "\t${BOLD}-p {passphrase}${NOR}\tUse {passphrase} for Crypt"
			echo -e "\t${BOLD}-t${NOR}\t\tEnable TRIM for Crypt\n\n"
			echo -e "The $1 Command Can Be Used it Two Ways.\nThe First ( ${BOLD}[ -c ] { crypt | device }${NOR} ) Will Add a Crypt or Device Which is Already on the Crypttab"
			echo -e "The Second ( ${BOLD}[ -c ] { -p passphrase crypt device }${NOR} ) Will Add a crypt (and Corresponding Backing Device) to the Crypttab\nThe Option '${BOLD}-p passphrase${NOR}' Must Be Specified in the Second Case\n"
			echo -e "The Options and Arguments Can Be Specified in any Order"
			echo -e "${BOLD}${UL}${MYNAME} $1 -p passphrase crypt device${NOR}\tand\t${BOLD}${UL}${MYNAME} $1 crypt -c\n${MYNAME} $1 crypt -c device -p passphrase${NOR}\tand\t${BOLD}${UL}${MYNAME} $1 device -p passphrase crypt -c${NOR}"
			echo -e "Are All Valid $1 Command Specifications\n"			
			echo -e "The ${MYNAME} Will Look for Block Devices in \"${BOLD}${conf[BLOCKDEVSDIRS]}${NOR}\"\n"
			;;
		del)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tRemove an Encrypted Block Device from the Manager\n"
			echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -htc ] { crypt | device }${NOR}\n\n"
			echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
			echo -e "\t${BOLD}-c${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
			echo -e "\t${BOLD}-t${NOR}\t\tRemove the crypt (and Corresponding Backing Device) from the Crypttab\n\n"
			echo -e "The Options and Arguments Can Be Specified in any Order\n"
			;;
		put)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tPut Key File to Boot Servers\n"
			echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hc ] passphrase${NOR}\n\n"
			echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
			echo -e "\t${BOLD}-c${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions\n"
			;;
		rmkey)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tRemove Key File from Firmware\n"
			echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hc ] passphrase${NOR}\n\n"
			echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
			echo -e "\t${BOLD}-c${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions\n"
			;;
		smart)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tShow S.M.A.R.T. Information for Backing Device\n"
			echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hax ] {crypt | device }${NOR}\n\n"
			echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
			echo -e "\t${BOLD}-a|-x${NOR}\t\tShow all S.M.A.R.T. information (Only Atrributes Otherwise)"
			echo -e "\t${BOLD}-t${NOR}\t\tRun S.M.A.R.T. Long Self Test on Device\n"
			;;
		erase)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tSecure Erase Device\n"
			echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h ] {crypt | device }${NOR}\n\n"
			echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
			;;
		*)
			echo -e " Usage:\n\t${BOLD}${MYNAME} { [ -hdf ] ${UL}COMMAND ...${NOR} }\n"
			echo -e "\tEncrypted Block Devices Manager, Command Line Requires at Least one Option or Command"
			echo -e "\tMultiple Commands May Be Specified in Order, Commands Can Have Multiple Options and Arguments"
			echo -e "\tAll Commands Options and Arguments Are cAsE iNSensItiVe, except for ${UL}Device Names${NOR}\n"
			echo -e "\tUse ${UL}${BOLD}${MYNAME} command -h${NOR} To Display Help for That Command${NOR}\n\n"
			echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
			echo -e "\t${BOLD}-d${NOR}\t\tSet Configuration Directory (${BOLD}${UL}Default: /etc/${MYNAME:0:-1}.d${NOR})"
			echo -e "\t${BOLD}-f${NOR}\t\tRun in Foreground (Debug) Mode. Can Only be Started by root."
			echo -e "\n\n Commands:\n\t${BOLD}status${NOR}\t\tDisplays Status of Encrypted Block Device Manager"
			echo -e "\t${BOLD}smart${NOR}\t\tDisplay S.M.A.R.T. Status of Encrypted Block Device" 
			echo -e "\t${BOLD}erase${NOR}\t\tSecure Erase Encrypted Block Device" 
			echo -e "\t${BOLD}stop${NOR}\t\tStop the Encrypted Device Manager" 
			echo -e "\t${BOLD}reload${NOR}\t\tReload the Configuration of the Encrypted Device Manager" 
			echo -e "\t${BOLD}add${NOR}\t\tAdd Encrypted Block Device to Manager" 
			echo -e "\t${BOLD}del${NOR}\t\tDelete Encrypted Block Device from Manager" 
			echo -e "\t${BOLD}put${NOR}\t\tPut Keyfile (Passphrase) to Boot Servers" 
			echo -e "\t${BOLD}rmkey${NOR}\t\tRemove Keyfile (Passphrase) from Firmware\n" 
			;;
	esac
	exit 127
}

do_parse_opt()
{
	# Parse command line options (-h -d -f). Function is run from main cli to parse as first options given.
	# Function can also run from the parse cmds function, it that case only -d option can be valid.
	local __opt; OPTIND=1; getopts :fFd:D:hHcCaAp:P:tT __opt
	__opt="${__opt,,}"; case ${__opt} in
		h|:) # if -h is specified as a command line option echo usage for the command running if run from parse cmds.
			do_echo_use "${__command}"
			;;
		a|x) # Option for smart -x
			[[ ${_cmd} -eq 0 || ! "${__command,,}" =~ ^(smart)$ ]] && do_echo_use "${__command}"
			__smartall=1
			return 1
			;;
		c) # Option to ask for confirmation for non critical actions.
			[[ ${_cmd} -eq 0 || ! "${__command,,}" =~ ^(add|del|put|rmkey)$ ]] && do_echo_use "${__command}"
			[[  ${__confirm} -eq 1 ]] && do_echo_use "${__command}"
			__confirm=1
			return 1
			;;
		p) # Option to specify a passphrase name for the new crypt to be added to the crypttab.
			[[ ${_cmd} -eq 0 || ! "${__command,,}" == "add" ]] && do_echo_use "${__command}"
			[[  ${__crypttab} -eq 1 ]] && do_echo_use "${__command}"
			__crypttab=1
			__add_pp="${OPTARG}"
			return $((OPTIND-1))
			;;
		t) # Option trim enable foor add, remove crypt from crypttap for del command. Or Run smart self test.
			[[ ${_cmd} -eq 0 || ! "${__command,,}" =~ ^(add|del|smart)$ ]] && do_echo_use "${__command}"
			if [[ "${__command}" == "add" ]]; then
				__add_trim=1
				return 1
			elif [[ "${__command}" == "del" ]]; then
				[[  ${__crypttab} -eq 1 ]] && do_echo_use "${__command}"
				__crypttab=1
				return 1
			elif [[ "${__command}" == "smart" ]]; then
				[[  ${__smarttest} -eq 1 ]] && do_echo_use "${__command}"
				__smarttest=1
				return 1
			fi
			;;
		d) # Set configuration directory. If no dir specified echo usage. Option is only valid for global, not for command.
			[[ ${_cmd} -eq 1 ]] && do_echo_use "${__command}"
			[[ ! -d ${OPTARG} ]] && echo "Configuration Directory ${OPTARG} Does not Exist"
			[[ ! -d ${OPTARG} || ${_conf} -ne 0 ]] && do_echo_use "${__command}"
			_conf=1
			CONFDIR=${OPTARG}
			# Shift the parameters and check if more arguments specified, continue with processing options if so.
			[[ $# -ge ${OPTIND} ]] && return $((OPTIND-1))
			shift $((OPTIND-1))
			;;
		f) # Set the flag that we should run in foreground mode. 
			[[ ${_cmd} -eq 1 || ${FOREGROUND} -eq 1 ]] && do_echo_use "${__command}"
			FOREGROUND=1
			# If there are more options continue parsing. -f can only be followed by -d.
			shift
			[[ ! -z "$1" ]] && return 1
			;;
		?) # If run from parse cmds function, we need to check if the option specified matches a known command.
		   # If that is the case we have reached the end of the current command and can start processing the next.
			if [[ ${_cmd} -eq 1 ]]; then
				if [[ ! -z "$1" ]]; then 
					if ! do_parse_cmd check $1; then
						___next_cmd=1
					else
						shift
					fi
				else
					# If there are no more arguments set to process next command, which will be none.
					___next_cmd=1
				fi
			fi
			;;
	esac

	# All options are evaluated or confdir specified, initialize the configuration.
	if [[ ( ${_cmd} -eq 0 && ( ${_conf} -eq 1 || -z "$1" ) ) || ( ${_cmd} -eq 1 && ${_conf} -eq 0 ) ]]; then
		if ! do_init_conf; then
			echo "Error loading configuration from ${CONFDIR}"; exit 1
		else
			_conf=1
		fi
	fi

	# If foreground mode was requested execute. Echo command usage if specified in wrong place.
	if [[ ${FOREGROUND} -eq 1 ]]; then
		# If -f is not first option specified, it must be last (after -d) and no more options can be present.
		[[ ${_nr} -gt 1 && ! -z "$1" ]] && do_echo_use "${__command}"
		# Start in debug/foreground mode.
		if [[ ${UID} -ne 0 && $# -le 1 ]]; then
			echo "cryptdisksd daemon foreground can only be started as root"; exit 1
		fi
		echo "loglevel=${conf[LOGLEVEL]}"
		do_systemd_start
		exit $?
	fi

	# Return 1 if next command is found, 0 otherwise.
	[[ ${___next_cmd} -eq 1 ]] && return 1
	return 0
}

do_parse_cmd()
{
	# Parse the commands specified on the command line, one by one. If called with check, then return 1 on match.
	# This is to let the parse opt function know a match for a new command has been found.
	local __command="${1,,}"
	if [[ "${__command}" == "check" ]]; then 
		shift; __command="${1,,}"
	       	local __check=1;
       	fi
	case ${__command} in
		udev) [[ ${__check} -eq 1 ]] && return 1; do_cmd_parseopt $@; do_cryptdisksd_udev $@; return $#	;;
		stop) [[ ${__check} -eq 1 ]] && return 1; do_cmd_parseopt $@; /bin/kill -SIGTERM $(cat ${conf[PIDFILE]}); return $#	;;
		reload)	[[ ${__check} -eq 1 ]] && return 1; do_cmd_parseopt $@; /bin/kill -SIGHUP $(cat ${conf[PIDFILE]}); return 1	;;
		status|shell|add|del|put|rmkey|smart|erase) [[ ${__check} -eq 1 ]] && return 1; do_cryptdisksd_cmd $@; return $? ;;
		*) [[ ${__check} -ne 1 ]] && do_echo_use "${__command}"; return 0 ;;
	esac
	return 0
}

do_cmd_parseopt()
{
	# If there are more arguments to process, check for command options or or for a new command to be processed.
	local ___next_cmd=0 ___res ___s=0
	shift; while [[ ${___next_cmd} -eq 0 ]]; do
		do_parse_opt $@; ___res=$? 
		if [[ ${___res} -eq 0 ]]; then
			__msg+="$1 "
			shift
			___s=$((___s+1))
		else
			shift ${___res}
			___s=$((___s+___res))
		fi
	done
	return ${___s}
}

trap_term_cryptdisksd_cmd()
{
	trap 'echo "${RED}${MYNAME} unclean finish${NOR}"; exit 1' SIGINT SIGTERM

	# Kill socat coproc if still active and remove the socket if still present. Restore stdin to the tty.
	if [[ ! -z "${__pid_socat}" && "$(cat /proc/${__pid_socat}/comm 2>/dev/null)" == "socat" ]]; then
		kill -SIGTERM ${__pid_socat}
		[[ ${conf[LOGLEVEL]} -gt 2 ]] && echo -e "\rKilled ${__pid_socat}"
	fi
	if [[ -e ${conf[CRYPTDISKSDDIR]}/${__sock} ]]; then
		rm -f ${conf[CRYPTDISKSDDIR]}/${__sock}
		echo -e "\rRemoved ${conf[CRYPTDISKSDDIR]}/${__sock}\r\n"
	fi
	exec 0<&${stdin}-; stty sane; echo -e "${NOR}\n"
	exit 1
}

do_cryptdisksd_cmd()
{
	trap 'trap_term_cryptdisksd_cmd' SIGINT SIGTERM

	# Request status from daemon. Detach stdin and assign it to socat coproc, which will attach it to daemon stdout.
	if [[ ! "$(NOTIFY_SOCKET= systemctl is-active ${MYNAME:0:-1}.service 2>&1)" =~ activating|active ]]; then
		echo "${MYNAME} not Running"
		exit 1
	fi
	
	# Parse the options to the command and store the nr. of paramters to shift in __s.
	local __crypttab=0 __confirm=0 __smartall=0 __smarttest=0 __add_pp="" __add_trim=0 __msg="$1 " __stty_opt=""
	do_cmd_parseopt $@; local __s=$?
	local __sock=${conf[CRYPTDISKSDDIR]}/${MYNAME}-${BASHPID}.sock __pid_socat

	case ${__command} in
		add)
			if [[ ${__crypttab} -eq 1 ]]; then
				[[ $(wc -w <<<"${__msg}") -ne 3 ]] && do_echo_use "${__command}"
			else
				[[ $(wc -w <<<"${__msg}") -ne 2 ]] && do_echo_use "${__command}"
			fi
			__msg+="${__add_pp} ${__add_trim} ${__confirm} ${__crypttab}"
			__stty_opt="raw -echo isig"
			;;
		del)
			[[ $(wc -w <<<"${__msg}") -ne 2 ]] && do_echo_use "${__command}"
			__msg+="${__confirm} ${__crypttab}"
			__stty_opt="raw -echo isig"
			;;
		status)
			[[ $(wc -w <<<"${__msg}") -ne 1 ]] && do_echo_use "${__command}"
			__stty_opt="raw -echo isig"
			;;
		smart)
			[[ $(wc -w <<<"${__msg}") -ne 2 ]] && do_echo_use "${__command}"
			__msg+="${__smartall} ${__smarttest}"
			__stty_opt="-echo isig"
			;;
		shell)
			[[ $(wc -w <<<"${__msg}") -ne 1 ]] && do_echo_use "${__command}"
			__stty_opt="raw -echo -isig"
			;;
		*)
			[[ $(wc -w <<<"${__msg}") -ne 2 ]] && do_echo_use "${__command}"
			__msg+="${__confirm}"
			__stty_opt="raw -echo isig"
			;;
	esac

	# Set tty options, redirect STDIN
	stty ${__stty_opt}
	local stdin
	exec {stdin}<&0-

	[[ ${conf[LOGLEVEL]} -gt 2 ]] && echo -e "Requesting \"$@\" from ${MYNAME}\r"

	# Start socat in background and attach stdin, listen on a socket in RUNDIR. 
	# The daemon will spawn a worker which will connect and start interactive session.
	socat -t1 - UNIX-LISTEN:${__sock},unlink-early,unlink-close,group=${conf[CRYPTDISKSD_GROUP]},mode=600 0<&${stdin}- &
	__pid_socat=$!

	# Notify the daemon to connect to the socket and wait until it's finished. Then restore stdin and exit.
	sleep .05
	echo "control ${BASHPID} ${__msg}" >${conf[FIFO]}
	wait ${__pid_socat}

	# Restore stdin, remove socket and exit.
	exec 0<&${stdin}-
	stty sane
	[[ -e ${__sock} ]] && rm -f ${__sock}

	[[ ${conf[LOGLEVEL]} -gt 3 ]] && echo "Done requesting \"$@\" from ${MYNAME}"
	return ${__s}
}

# [END OF INTERACTIVE CONTROL FUNCTIONS]

# [BEGIN OF EXECUTION FUNCTIONS]

do_systemd_start()
{
	# Check if we are started from systemd (PID 1).
	[[ ( ! "${UID}" -eq 0 || ! ${PPID} -eq 1 ) && ${FOREGROUND} -eq 0 ]] && do_echo_use
	local myname="daemon (${BASHPID}):" hostname="$(hostname)" pid_daemon=${BASHPID} starting=1 start_status=0 time_start=$(do_timer)
	local systemdconf="" crypttab="" pid_logwriter fd_logwriter fd_journal

	# Close stdin, fd3 to stdout (systemd journald) for reader and worker processes. Redirect stdout and stderr to /dev/null.
	# If we are running in foreground mode evrything goes to stdout of the user's terminal. And we wish him or her good luck with that.
	[[ ${FOREGROUND} -ne 1 ]] && exec 0>&- {fd_journal}>&1- 1>/dev/null 2>&1
	[[ ${FOREGROUND} -eq 1 ]] && exec {fd_logwriter}>&1 {fd_journal}>&${fd_logwriter}

	# Load config and start new key session and link the user key ring to the session key ring. On boot keys will be cached in user key ring. 
	keyctl new_session
	keyctl link @u @s
	if ! do_init_conf; then
		systemd-notify STOPPING=1 --pid=$$ --status="cryptdisksd: Cannot Initialize Config" 
		systemd-notify --ready --pid=$$
		exit 0
	fi

	# Start the logwriter.
	[[ ${FOREGROUND} -ne 1 ]] && do_daemon_start_logwriter
	do_log info "${myname} initializing"

	# Here we go, we are started from systemd. We will first process to queue entirely and notify systemd if we're done.
	# The daemon and queue reader are recursive processes. They will re-enter themselves after processing a command. 
	# The reader spawns worker processes to get passphrases and the daemon will mount the actual cryptdisks. 
	# A cleanup will be run every minute. There we will detect if configuration has changed and remove timed out workers and mounts.
	[[ ${conf[DEBUGSHELL]} -eq 1 ]] && set -a
	echo ${pid_daemon} >${conf[PIDFILE]}

	# Check if the queue exists first, exit with error if it isn't. It should be there, or something is wrong with socket.
	if [[ ! -p ${conf[FIFO]} ]]; then
		do_log error "${myname} queue not found" 
		systemd-notify STOPPING=1 --pid=$$ --status="cryptdisksd: Queue not Found, Restart cryptdisksd.socket" 
		systemd-notify --ready --pid=$$
		exit 0
	fi

	# Parse and load the configuration, exit if either fails.
	if ! do_daemon_check_conf; then 
		do_log error "${myname} failed to load config" 
		systemd-notify STOPPING=1 --pid=$$ --status="cryptdisksd: Failed to Load Configuration"
		systemd-notify --ready --pid=$$
		exit 0
	fi

	# Check if there is a crypttab, log message if there isn't since everything we do is based on it.
	if [[ ! -f ${conf[CRYPTTAB]} ]]; then
		echo -e "#Crypt\t\t\t#Device\t\t\t\t#Passphrase\t\t#TRIM" >${conf[CRYPTTAB]}
		do_log warning "${myname} crypttab not found" 
		systemd-notify --pid=$$ --status="cryptdisksd: Crypttab (${conf[CRYPTTAB]}) not Found"
		start_status=2
	fi

	systemd_daemon
}

do_cryptdisksd_cli()
{
	local _i=0 _nr=$# _cmd=0 _conf=0
	# Enter a loop to evaluate all command line options and commands specified.
	while true; do
		local _i=$((_i+1)) _res 
		# Parse options, the return code will be the nr of parameters to shift or 0 if all options parsed.
		# Continue with processing commands fase if all options parsed.
		if [[ ${_cmd} -eq 0 ]]; then 
			do_parse_opt $@
			_res=$?
			shift ${_res}
			[[ ${_res} -ne 0 ]] && continue
		fi
		# Command line options are parsed, evaluate and execute commands specified. Return code will be nr of arguments to shift.
		# If after shifting there are no more commands to process we can exit.
		_cmd=1; do_parse_cmd $@
		_res=$?
		shift ${_res}
		[[ -z "$1" ]] && return 0
	done
}

MYNAME="$(basename $0)" FOREGROUND=0 PATH=/bin:/sbin
[[ ! -z "${LC_NUMERIC}" ]] && unset LC_NUMERIC

# Check if we're started interactively (options must be specified) or from systemd (run without any options from PID 1).
if [[ $# -eq 0 ]]; then
	# No command line options specified. check if we're started from systemd, start daemon if so.
	do_systemd_start
	exit 1
else
	# Command line options present, run in interactive mode.
	do_cryptdisksd_cli $@
	# Exit if there are no more commands to execute.
	exit $?
fi

# [END OF EXECUTION FUNCTIONS]

# We should never get here, error exit if we do.
echo "${MYNAME} Reached End of the Line, Bye Bye"
exit 1
