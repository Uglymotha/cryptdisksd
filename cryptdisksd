#!/bin/bash

# Function Definitions. All functions for serialized commands shall have their nemae prefixed by do_ all others shall not.

do_init_conf()
{
	# Initialize System Variables. Default config in /etc/cryptdisks.d/cryptdisksd.conf. Systemd env CONF(DIR) will override.
	local var val _conf _keylife IFS=$'\n'
	declare -gA conf keyserverconf keylife
	[[ -z "${CONFDIR}" ]] && CONFDIR="/etc/${MYNAME:0:-1}.d"
	if [[ ! -d "${CONFDIR}" && "$1" != "keyserver" ]]; then
		do_log error "${myname} ${CONFDIR} not found"
		return 1
	fi
	[[ -z "${CONF}" ]] && CONF="${CONFDIR}/${MYNAME}.conf"
	if [[ -s ${CONF} ]]; then for var in $(cat ${CONF} |grep -ve "^\s*#"); do
		val=${var#*=} var=${var%%=*}
		conf[${var^^}]="${val}"
	done fi
	[[ -z "${conf[LOGLEVEL]}" ]] && conf[LOGLEVEL]=0
	[[ -z "${conf[DEBUGSHELL]}" ]] && conf[DEBUGSHELL]=0
	[[ -z "${conf[RUNDIR]}" ]] && conf[RUNDIR]="/run"
	[[ -z "${conf[LOGDIR]}" ]] && conf[LOGDIR]="/var/log/${MYNAME}"
	[[ -z "${conf[LOGFILE]}" ]] && conf[LOGFILE]="/var/log/${MYNAME}.log"
	[[ -z "${conf[CRYPTDISKSDDIR]}" ]] && conf[CRYPTDISKSDDIR]=${conf[RUNDIR]}/${MYNAME}
	[[ -z "${conf[PIDFILE]}" ]] && conf[PIDFILE]="${conf[CRYPTDISKSDDIR]}/${MYNAME}.pid"
	[[ -z "${conf[CRYPTDISKSD_GROUP]}" ]] && conf[CRYPTDISKSD_GROUP]="disk"
	[[ -z "${conf[CRYPTDISKSDDIR_MODE]}" ]] && conf[CRYPTDISKSDDIR_MODE]=700
	[[ -z "${conf[FIFO]}" ]] && conf[FIFO]="${conf[CRYPTDISKSDDIR]}/${MYNAME}.queue"
	[[ -z "${conf[FIFO_MODE]}" ]] && conf[FIFO_MODE]=600
	[[ -z "${conf[CRYPTTAB]}" ]] && conf[CRYPTTAB]="${CONFDIR}/crypttab"
	[[ -z "${conf[BLOCKDEVSDIRS]}" ]] && conf[BLOCKDEVSDIRS]="/dev/disk/by-id"
	[[ -z "${conf[START_TIMEOUT]}" ]] && conf[START_TIMEOUT]=5
	[[ -z "${conf[PP_TIMEOUT]}" ]] && conf[PP_TIMEOUT]=3
	[[ -z "${conf[QUEUE_TIMEOUT]}" ]] && conf[QUEUE_TIMEOUT]=2
	[[ -z "${conf[CLEANUP_TIMER]}" ]] && conf[CLEANUP_TIMER]=60
	[[ -z "${conf[FWDIR]}" ]] && conf[FWDIR]="/sys/firmware/efi/efivars"
	[[ -z "${conf[FWGUID]}" ]] && conf[FWGUID]="ca25478a-acb8-44ac-8c55-d5d45dfe25c5"
	[[ -z "${conf[FWBOOTCONF]}" ]] && conf[FWBOOTCONF]="${conf[FWDIR]}/UglyLinuxBootCFG-${conf[FWGUID]}"
	[[ -z "${conf[BOOTCONF]}" ]] && conf[BOOTCONF]="${CONFDIR}/boot.conf"
	[[ -z "${conf[NET_ONLINE]}" ]] && conf[NET_ONLINE]=1
	[[ -z "${conf[NET_RETRIES]}" ]] && conf[NET_RETRIES]=2
	[[ -z "${conf[USER_TIEMOUT]}" ]] && conf[USER_TIMEOUT]=10
	conf[START_TIMEOUT]=$((conf[START_TIMEOUT]*60))
	conf[PP_TIMEOUT]=$((conf[PP_TIMEOUT]*60))
	if [[ "$1" == "keyserver" ]]; then
		[[ ! -z "${KEYSERVERDIR}" ]] && CONFDIR="${HOME}/${KEYSERVERDIR}" || CONFDIR="${HOME}/${MYNAME}-keyserver"
		CONF="${CONFDIR}/${MYNAME}-keyserver.conf"
		if [[ -s ${CONF} ]]; then for var in $(cat ${CONF} |grep -ve "^\s*#"); do
			val=${var#*=} var=${var%%=*}
			keyserverconf[${var^^}]="${val}"
	   	done fi
		[[ ! -z "${keyserverconf[KEYSRV_FIFO]}" ]] && conf[KEYSRV_FIFO]="${CONFDIF}/${keyserverconf[FIFO]}" || conf[KEYSRV_FIFO]="${CONFDIR}/queue"
		[[ ! -z "${keyserverconf[LOGDIR]}" ]] && conf[LOGDIR]="${HOME}/${keyserverconf[LOGDIR]}" || conf[LOGDIR]="${CONFDIR}"
		[[ ! -z "${keyserverconf[LOGFILE]}" ]] && conf[LOGFILE]="${conf[LOGDIR]}/${keyserverconf[LOGFILE]}" || conf[LOGFILE]="${conf[LOGDIR]}/${MYNAME}-keyserver.log"
		[[ ! -z "${keyserverconf[LOGLEVEL]}" ]] && conf[LOGLEVEL]="${keyserverconf[LOGLEVEL]}"
		[[ ! -z "${keyserverconf[KEYSRVR_GROUP]}" ]] && conf[KEYSRV_GROUP]="${keyserverconf[KEYSRVR_GROUP]}" || conf[KEYSRV_GROUP]="sanboot"
		[[ ! -z "${keyserverconf[KEYDIR]}" ]] && conf[KEYDIR]="${HOME}/${keyserverconf[KEYDIR]}" || conf[KEYDIR]="${CONFDIR}/keys"
		[[ ! -z "${keyserverconf[KEYSRV_TIMEOUT]}" ]] && conf[KEYSRV_TIMEOUT]="${keyserverconf[KEYSRV_TIMEOUT]}" || conf[KEYSRV_TIMEOUT]=5
		[[ ! -z "${keyserverconf[PP_TIMEOUT]}" ]] && conf[PP_TIMEOUT]="${keyserverconf[PP_TIMEOUT]}"
		[[ ! -z "${keyserverconf[USER_TIEMOUT]}" ]] && conf[USER_TIMEOUT]=${keyserverconf[USER_TIEMOUT]}
		[[ ! -z "${keyserverconf[CLEANUP_TIMER]}" ]] && conf[CLEANUP_TIMER]="${keyserverconf[CLEANUP_TIMER]}"
	fi
	if [[ -n "${conf[KEYLIFE]}" || -n "${keyserverconf[KEYLIFE]}" ]]; then
		IFS=' '; for _conf  in conf[KEYLIFE] keyserverconf[KEYLIFE]; do 
			_keylife=""; for var in ${!_conf}; do
				if [[ "${var}" =~ ^[0-9]+$ && -n "${_keylife}" ]]; then
					do_log error "${myname} can only specify default keylife once"
					return 1
				elif [[ "${var}" =~ ^[0-9]+$ ]]; then
					_keylife=${var}
					continue
				else
					val=${var#*=} var=${var%%=*}
					if [[ -z "${val}" || ! ${val} =~ ^[0-9]+$ ]]; then
						do_log error "${myname} invalid keylife ${var}=${val}"
						return 1
					fi
					keylife[$(do_eval_pp ${var})]=$((val*60))
				fi
			done
			[[ "${_conf}" == "conf[KEYLIFE]" ]] && conf[KEYLIFE]=${_keylife} || keyserverconf[KEYLIFE]=${_keylife}
		done
		[[ -n "${keyserverconf[KEYLIFE]}" ]] && conf[KEYLIFE]=${keyserverconf[KEYLIFE]}
	fi
	conf[KEYLIFE]=$((conf[KEYLIFE]*60))

	# Initialize formatting parameters for console output.
	RED="\033[91m" GREY="\033[94m" YEL="\033[93m" GRN="\033[92m" BOLD="\033[1m" UL="\033[4m" NOR="\033[0m" RES="\0332J"
	PR="\033[s" PD="\033[u\033[16C\033[s" PE="\033[u\033[62C\033[s" PP="\033[u\033[6C\033[s" PT="\033[u\033[22C\033[s" PS="\033[u\033[21C"
	return 0
}

# [BEGIN OF LOGGING FUNCTIONS]

trap_term_logwriter()
{
	trap 'logger -p daemon.warning "${MYNAME}: ${_myname} unclean finish after $(do_timer ${_time_start})s"; exit 1;' SIGINT SIGTERM

	# When the log writer is killed, set the read timeout to 1s (no exit) to allow the writer to parse remaining log messages.
	logger -p daemon.info "${MYNAME}: ${_myname} terminating"
	[[ ${conf[LOGLEVEL]} -gt 0 ]] && echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${myname} terminating after $(do_timer ${_time_start})s" >>${conf[LOGFILE]}
	exit 0
}

logwriter()
{
	trap 'trap_term_logwriter' SIGINT SIGTERM

	# The log write will parse lines from stdin, sent by various workers. The lines are written to log and sent to syslog.
	local myname="logger (${BASHPID}):" _time_start=$(do_timer) lf line

	# Initialize the log file. Set the correct access rights.
	if [[ ! -z "$1" ]]; then
		conf[LOGFILE]=${conf[LOGDIR]}/$1
		touch ${conf[LOGFILE]}
		chmod 640 ${conf[LOGFILE]}
	fi
	[[ ${conf[LOGLEVEL]} -gt 0 ]] && echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${myname} initialized" >>${conf[LOGFILE]}

	# Prepend every line recieved with date and time and write to logfile.
	while read -r lf line; do
		local _date="$(date '+%d-%m %H:%M:%S.%3N')"
		if [[ "${lf}" == "debug" && ${conf[LOGLEVEL]} -ge 1 ]]; then
			echo "${_date} ${hostname} ${line}" >>${conf[LOGFILE]}
		elif [[ "${lf}" == "debug2" && ${conf[LOGLEVEL]} -ge 3 ]]; then
			echo "${_date} ${hostname} ${line}" >>${conf[LOGFILE]}
		elif [[ ${lf} == "info" || ${lf} == "warning" || ${lf} == "error" ]]; then
			logger -p daemon.${lf} "${MYNAME}: ${line}"
			[[ ${conf[LOGLEVEL]} -ge 1 ]] && echo "${_date} ${hostname} ${line}" >>${conf[LOGFILE]}
		elif [[ ${conf[LOGLEVEL]} -ge 3 ]]; then
			echo "${_date} ${hostname} ${lf} ${line}" >>${conf[LOGFILE]}
		fi
	done
	echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${myname} finished after $(do_timer ${_time_start})s ($?)" >>${conf[LOGFILE]}
}

do_log()
{
	# Send a message to the log writer, or to systemd if that fails.
	echo "$@" >&${fd_logwriter} || echo "$@" >&${fd_journal}
	return 0
}

do_timer()
{
	# Start a timer for debugging purposes. We will track to the ms.
	if [[ $# -eq 0 ]]; then
		# Started with no args, start a timer, echo the start time.
		echo ${EPOCHREALTIME:0:-3}
	elif [[ ${1,,} == "date" ]]; then
		# Output the exact date of the timestamp.
		echo "$(date --date @$2 +%Y-%m-%d.%H:%M:%S)"
	else
		# Started with start time as args, calculate and echo the time difference.
		echo "$(bc <<<"x=${EPOCHREALTIME:0:-3}-$1; if (x<1) print 0; x")"
	fi
}

# [END OF LOGGING FUNCTIONS]

# [BEGIN OF MAIN DAEMON FUNCTIONS]

trap_term_daemon()
{
	trap 'systemd-notify --pid=$$ --stopping --status="${MYNAME}: unclean finish after $(do_timer ${time_start})s"; exit 1;' SIGINT SIGTERM

	# Main process received SIGTERM or SIGINT, shutdown processes.
	do_log warning "${myname} terminating after $(do_timer ${time_start})s"
	do_daemon_check_conf
	for pid in ${!ctrl[@]}; do if [[ "$(cat /proc/$(echo ${pid} |cut -d ' ' -f 2)/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM $(echo ${pid} |cut -d ' ' -f 2)
		wait $(echo ${pid} |cut -d ' ' -f 2)
		do_log debug "${myname} killed control process (PID: $(echo ${pid} |cut -d ' ' -f 2))"
	fi done
	for crypt in ${!mount[@]}; do if [[ "$(cat /proc/${mount[${crypt}]%% *}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${mount[${crypt}]%% *}
		wait ${mount[${crypt}]%% *}
		do_log debug "${myname} killed mount process (PID: ${mount[${crypt}]%% *})"
	fi done
	for pid in ${!pid_getpp[@]}; do if [[ ! -z "${pid_getpp[${pid}]}" && "$(cat /proc/${pid_getpp[${pid}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_getpp[${pid}]}
		wait ${pid_getpp[${pid}]}
		do_log debug "${myname} killed passphrase worker for ${pid} (PID: ${pid_getpp[${pid}]})"
	fi done
	for pid in ${!pid_putkey[@]}; do if [[ ! -z "${pid_putkey[${pid}]}" && "$(cat /proc/${pid_putkey[${pid}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_putkey[${pid}]}
		wait ${pid_putkey[${pid}]}
		do_log debug "${myname} killed putkey worker for ${pid} (PID: ${pid_putkey[${pid}]})"
	fi done
	if [[ ! -z "${pid_logwriter}" && "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_logwriter}
		wait ${pid_logwriter}
	fi
	rm -f ${conf[PIDFILE]} ${conf[CRYPTDISKSDDIR]}/*.sock

	systemd-notify --pid=$$ --stopping --status="${MYNAME}: terminating after $(do_timer ${time_start})s"
	exit $1 
}

trap_hup_daemon()
{
	# Received reload request from systemd. Reload the config asap (no active commands/workers). confok, contains status.
	# 0 - Config is ok.
	# 1 - Config changed, or SIGHUP received
	do_log warning "${myname} received SIGHUP, reload config asap"
	confok=1
}

systemd_daemon()
{
	trap 'trap_term_daemon' SIGINT SIGTERM
	trap 'trap_hup_daemon' SIGHUP

	# The workers will be started with the following fds:
	# 1 (stdout) 2 (stderr) and {fd_logwriter} (for subshells) point to a log writer.
	# {fd_journal} systemd journal messages which can be viewed with systemctl status and journalctl -xe
	local time_active=0.000 cleanup=0.000 msg confok=0 fd_fifo key passphrase read_to res _time_start crypt_arr crypt pid_ctrl fd_ctrl pid_socat sock_ctrl cmd dev
	declare -gA active_mnt waiting_mnt cached_pp pid_getpp ctrl mount pid_putkey 

	# If we are booting up the master passphrase may be in the user keyring, revoke and cache in session keyring.
	key="$(keyctl search @u user "system:master" 2>/dev/null)"; passphrase="$(keyctl pipe "${key}" 2>/dev/null)"
	[[ ! -z "${key}" ]] && do_move_passphrase "system:master" "${key}" "${passphrase}"
	
	# The workers will send us messages about events, we need to keep track of time for (debug) logging and cleanup.
	# If we are starting up, read time-out is start timeout so cleanup etc will be done only after start
	# If we are in normal op, keep cleanup timer (60secs). The timeouts will be evaluated every command iteration.
	systemd-notify --pid=$$ --status="${MYNAME}: Starting Up, Timeout $((conf[START_TIMEOUT]+conf[QUEUE_TIMEOUT]*2))s"
	systemd-notify EXTEND_TIMEOUT_USEC=$(((conf[START_TIMEOUT]+conf[QUEUE_TIMEOUT]*2)*1000000))

	exec {fd_fifo}<>${conf[FIFO]}
	while true; do	
		# If we are starting up, read time-out when initial queue is empty so we can notify parent. If we are in normal operation, keep cleanup timer (60secs).
		do_log debug2 "${myname} running since $(do_timer date ${time_start})"
		time_active=$(do_timer ${time_start})
	
		# Evaluate cleanup and start status and set the new queue read timeout, we will run a cleanup every conf[CLEANUP_TIMER].
		# Make sure the read timeout is never 0 as this will complicate things (read will not read if to = 0).
		if [[ ${starting} -eq 2 && ( -z "${!waiting_mnt[@]}" || ${time_active::-4} -ge ${conf[START_TIMEOUT]} ) ]]; then
			[[ -n "${!waiting_mnt[@]}" ]] && start_status=3 && do_log warning "${myname} start timeout reached, notifying systemd"
			starting=0
			do_daemon_notify_systemd
		fi
		[[ ${time_active::-4} -gt $((${cleanup::-4}+${conf[CLEANUP_TIMER]}-${conf[QUEUE_TIMEOUT]})) ]] && do_daemon_cleanup
		[[ ${confok} -eq 1 ]] && do_daemon_reload_conf && confok=0
		[[ ${starting} -eq 0 ]] && read_to=$((conf[CLEANUP_TIMER]-(${time_active::-4}-${cleanup::-4})))
		[[ ${starting} -eq 1 ]] && read_to=${conf[QUEUE_TIMEOUT]}
		[[ ${starting} -eq 2 ]] && read_to=$((conf[START_TIMEOUT]-${time_active::-4}+conf[QUEUE_TIMEOUT]))
		read -t${read_to} -ru${fd_fifo} -a msg
		res=$?
		
		# Evaluate the exit status of the message queue read and act accordingly.
		time_active=$(do_timer ${time_start})
		if [[ ${res} -eq 142 ]]; then 
			do_log debug2 "${myname} waking up from slumber"
			[[ ${starting} -ne 0 && -z "${!waiting_mnt[@]}" ]] && starting=0 && do_daemon_notify_systemd
			[[ ${starting} -eq 1 && -n "${!waiting_mnt[@]}" ]] && starting=2
			continue
		elif [[ ${res} -gt 128 ]]; then
			# Should not happen, daemon process received unhandled signal from somewhere.
			do_log debug "${myname} read result ${res}, may have been trapped"
			do_daemon_cleanup 
			continue
		elif [[ ${res} -ne 0 ]]; then
			# FIFO has terminated unexpectedly or fd has somehow been closed.
			do_log error "${myname} read error ${res} \"${msg[@]}\""
			trap_term_daemon 0
		fi

		# Process the message.
		do_log debug "${myname} processing \"${msg[@]}\"" 
		_time_start=$(do_timer)

		[[ ${msg[0],,} =~ ^(mount|unmount|add|change|remove)$ ]] && crypt_arr=($(do_xcrypt_fromtab "${myname}" "${msg[1]}"))
		case ${msg[0],,} in
		mount|unmount)
			if [[ "${msg[0],,}" == "unmount" && ${msg[2]} -ne 1 ]]; then
				do_log info "${myname} removed ${msg[1]} from active mounts"
				unset active_mnt[${msg[1]}]
			elif [[ "${msg[0],,}" == "mount" && ( ${msg[2]} -eq 0 || ${msg[2]} -eq 3 ) ]]; then
				do_log info "${myname} added ${msg[1]} to active mounts"
				active_mnt[${msg[1]}]="${crypt_arr[1]} ${crypt_arr[2]} ${crypt_arr[3]} $(do_timer)"
			fi
			[[ ${msg[2]} -eq 1 || ${msg[2]} -eq 4 ]] && start_status=1
			[[ ${start_status} -eq 0 && ( ( "${msg[0],,}" == "unmount" && ${msg[2]} -eq 2 ) || ${msg[2]} -eq 3 ) ]] && start_status=2
			[[ ${msg[3]} -ne 0 ]] && echo ${msg[2]} >&${ctrl[${msg[3]}]%% *}
			unset mount[${msg[1]}]
			do_log debug "${myname} active mounts: ${!active_mnt[@]}";;
		control)
			pid_ctrl=${msg[1]%%,*} pid_socat=${msg[1]##*,} cmd="${msg[2],,}" sock_ctrl="${conf[CRYPTDISKSDDIR]}/${MYNAME}-${msg[1]%%,*}.sock" fd_ctrl=${ctrl[${msg[1]%%,*}]%% *}
			[[ "${msg[2],,}" =~ ^(smart|erase)$ ]] && cmd=smarterase; [[ "${msg[2],,}" =~ ^(putkey|rmkey)$ ]] && cmd=putrmkey 
			if [[ ${cmd} =~ ^(add|del|putrmkey|status|smarterase|shell)$ ]]; then
				exec {fd_ctrl}> >(daemon_control_${cmd})
				ctrl[${pid_ctrl}]="${fd_ctrl} $! $(do_timer)"
				do_log debug "${myname} started control connection (PID: $(echo ${ctrl[${pid_ctrl}]} |cut -d ' ' -f 2))"
			elif [[ "${cmd}" == "finished" ]]; then
				do_log debug "${myname} control connection (PID: ${pid_ctrl}:$(echo ${ctrl[${pid_ctrl}]} |cut -d ' ' -f 2)) finished"
				exec {fd_ctrl}>&-
				unset ctrl[${pid_ctrl}]
				[[ -e ${sock_ctrl} ]] && rm -f ${sock_ctrl}
			fi;;
		notify)
			cmd=${msg[2]} pid_ctrl=${msg[1]} fd_control=${ctrl[${msg[1]}]%% *}
			# Process a command received from a control sub-process and notify about the result.
			[[ ! -z ${mount[${msg[3]}]} ]] && do_log debug "${myname} ignoring ${cmd} for ${msg[3]}, active worker (PID: ${mount[${msg[3]}]%% *})" && continue
			daemon_${cmd}_crypt "${msg[3]}" "${pid_ctrl}" "${msg[4]}" "${msg[5]}" "${msg[6]}" & mount[${msg[3]}]="$! $(do_timer)";;
		remove)
			[[ ! -z "${crypt_arr[@]}" && -z ${mount[${crypt_arr[0]}]} ]] && daemon_unmount_crypt "${crypt_arr[0]}" "0" & mount[${crypt_arr[0]}]="$! $(do_timer)"
			[[ ! -z ${mount[${crypt_arr[0]}]} ]] && do_log debug "${myname} ignoring ${msg[1]} for ${crypt_arr[0]}, active worker (PID: ${mount[${crypt_arr[0]}]%% *})";;
		add|change)
			[[ -z "${crypt_arr[@]}" ]] && continue
			key="$(keyctl search @u user "${crypt_arr[2]}" 2>/dev/null)"; passphrase="$(keyctl pipe "${key}" 2>/dev/null)"; dev="$(do_find_dev "${myname}" "${crypt_arr[1]}")"
			# Set the variables for the crypt to be added, search for the backing device in conf[BLOCKDEVSDIRS].	
			do_log debug "${myname} adding ${crypt_arr[1]} as ${crypt_arr[0]} TRIM ${crypt_arr[3]} using ${crypt_arr[2]} passphrase"
			if [[ -z "${dev}" ]]; then
				do_log warning "${myname} ${crypt_arr[1]} not found in ${conf[BLOCKDEVSDIRS]}"
				[[ start_status -eq 0 ]] && start_status=2
			elif [[ -n "${key}" || -n "$(keyctl request user "${crypt_arr[2]}" @s 2>/dev/null)" ]]; then
				do_log info "${myname} found cached ${crypt_arr[2]} passphrase" 
				[[  -n "${key}" ]] && do_move_passphrase "${crypt_arr[2]}" "${key}" "${passphrase}"
				[[ ! -z ${mount[${crypt_arr[0]}]} ]] && do_log debug "${myname} ignoring ${msg[0]} for ${crypt_arr[0]}, active worker (PID: ${mount[${crypt_arr[0]}]%% *})" && continue
				daemon_mount_crypt "${crypt_arr[0]}" "0" "${dev}" "${crypt_arr[2]}" "${crypt_arr[3]}" & mount[${crypt_arr[0]}]="$! $(do_timer)"
			elif [[ -n "${waiting_mnt[${crypt_arr[0]}]}" ]]; then
				# Check if crypt is already waiting
				do_log debug "${myname} ${dev} as ${crypt_arr[0]} TRIM ${crypt_arr[3]} already on waiting list"
			else
				# No worker and no passphrase cached, start new worker. If the crypt is already active the user will not be asked for passphrase.
				dmsetup info "${crypt_arr[0]}" >/dev/null 2>&1 && user=0
				do_log debug "${myname} adding ${dev} as ${crypt_arr[0]} TRIM ${crypt_arr[3]} to waiting list for ${crypt_arr[2]} passphrase"
				waiting_mnt[${crypt_arr[0]}]="${crypt_arr[2]} ${dev} ${crypt_arr[3]} $(do_timer)"
				if [[ -z "${pid_getpp[${crypt_arr[2]}]}" ]]; then
					do_log debug "${myname} no active worker for ${crypt_arr[2]}, starting"
					get_passphrase "${user}" &
					pid_getpp[${crypt_arr[2]}]=$!
				fi
			fi;;
		passphrase)
			[[ ${msg[2]} -eq 0 ]] && do_log warning "${myname} passphrase ${msg[1]} failed" || do_log info "${myname} passphrase ${msg[1]} success"
			[[ ${msg[2]} -ne 2 ]] && for crypt in ${!waiting_mnt[@]}; do if [[ "${waiting_mnt[${crypt}]%% *}" == "${msg[1]}" ]]; then
				crypt_arr=($(do_xcrypt_fromtab "${myname}" "${crypt}")); crypt_arr[4]="$(do_timer ${waiting_mnt[${crypt}]##* })s"
				unset waiting_mnt[${crypt}]
				if [[ ${msg[2]} == 0 ]]; then
					do_log info "${myname} removed ${crypt_arr[1]} as ${crypt_arr[0]} TRIM ${crypt_arr[3]} using ${crypt_arr[2]} passphrase, waited for ${crypt_arr[4]}s"
				else
					do_log debug2 "${myname} can mount ${crypt_arr[1]} as ${crypt_arr[0]} TRIM ${crypt_arr[3]} using ${crypt_arr[2]} passphrase, waited for ${crypt_arr[4]}s"
					[[ ! -z ${mount[${crypt_arr[0]}]} ]] && do_log debug "${myname} ignoring ${msg[0]} for ${crypt_arr[0]}, active worker (PID: ${mount[${crypt_arr[0]}]%% *})" && continue
					daemon_mount_crypt "${crypt_arr[0]}" "0" "$(do_find_dev "${myname}" "${crypt_arr[1]}")" "${crypt_arr[2]}" "${crypt_arr[3]}" & mount[${crypt_arr[0]}]="$! $(do_timer)"
				fi
			fi done
			[[ ${msg[2]} -ne 2 && -n "${pid_getpp[${msg[1]}]}" && "$(cat /proc/${pid_getpp[${msg[1]}]}/comm 2>/dev/null)" == "${MYNAME}" ]] && kill -SIGTERM ${pid_getpp[${msg[1]}]}
			[[ ${msg[2]} -ne 2 ]] && unset pid_getpp[${msg[1]}]
			[[ ${msg[2]} -eq 1 ]] && cached_pp[${msg[1]}]=1 || unset cached_pp[${msg[1]}];;
		*)	
			do_log debug "${myname} received invalid message \"${msg[@]}\"";;
		esac

		do_log debug2 "${myname} processing \"${msg[@]}\" took $(do_timer ${_time_start})s total"
	done

	# We should never get here, exit with error if we do.
	do_log error "${myname} terminated unexpectedly after $(do_timer {time_start})s"
	systemd-notify --pid=$$ --stopping --status="${MYNAME}: Daemon Terminated Unexpectedly After $(do_timer {time_start})s (PID: ${BASHPID}))"
	trap_term_daemon 1
}

do_move_passphrase()
{
	do_log info "${myname} found cached $1 passphrase in user keyring"
	keyctl revoke "$2" 2>/dev/null
	keyctl unlink "$2" @u 2>/dev/null
	key_clnt "PUT" "$1" "$3" & pid_putkey[$1]=$!
	do_cache_pp "${myname}" "$1" "-1" "$3"
}

do_daemon_start_logwriter()
{
	# LOGLEVEL 0, log only to syslog (daemon facility). 
	# LOGLEVEL 1, log to syslog and debug to dedicated logfile.
	# LOGLEVEL 2 is loglevel 1 with components having dedicated log file.
	# LOGLEVEL 3, extra debug logging, stdout and stderr of processes also sent to log.
	# LOGLEVEL 4, sames as level 3 with components having dedicated log file.
	[[ -n "${fd_logwriter}" ]] && exec {fd_logwriter}>&-
	case ${conf[LOGLEVEL]} in
		0|1)  exec {fd_logwriter}> >(logwriter);;
		2)    exec {fd_logwriter}> >(logwriter daemon-${pid_daemon}.log);;
		3)    exec {fd_logwriter}> >(logwriter) 1>&${fd_logwriter} 2>&1;;
		4)    exec {fd_logwriter}> >(logwriter daemon-${pid_daemon}.log) 1>&${fd_logwriter} 2>&1;;
	esac
	pid_logwriter=$!
}

do_daemon_notify_systemd()
{
	# Daemon notify about startup status.
	systemd-notify --ready --pid=$$
	case ${start_status} in 
	0)
		do_log info "${myname} startup completed succesfully in ${time_active}s"
		systemd-notify --pid=$$ --status="${MYNAME}: Startup completed succesfully in ${time_active}s (PID: ${BASHPID})";;
	1)
		do_log warning "${myname} startup completed with errors in ${time_active}s"
		systemd-notify --pid=$$ --status="${MYNAME}: Startup completed with errors in ${time_active}s (PID: ${BASHPID})";;
	2)
		do_log warning "${myname} startup completed with warnings in ${time_active}s"
		systemd-notify --pid=$$ --status="${MYNAME}: Startup completed with warnings in ${time_active}s (PID: ${BASHPID})";;
	3)
		do_log warning "${myname} startup timed out after ${time_active}s"
		systemd-notify --pid=$$ --status="${MYNAME}: Startup timed out after ${time_active}s (PID: ${BASHPID})"
	esac
}

do_daemon_check_conf()
{
	# Parse the configuration from firmware and compare it to the config stored in the confdir.
	# If there are any differences, the configuration in confidir will take precedence and overwrite the firmware.
	local diff _diff fwsrvvar fwsrvkey fwusrvar fwusrkey srvkey usrkey
	do_log debug "${myname} checking config"

	if [[ -s ${conf[FWBOOTCONF]} && ! -s ${conf[BOOTCONF]} ]]; then
		# Config in firware, not in confdir, copy fw to confdir.
		[[ ${confok} -eq 0 ]] && confok=1
		do_log debug "${myname} copying ${conf[FWBOOTCONF]} config to ${CONFDIR}"
		cat ${conf[FWBOOTCONF]} | tail -c +5 >${conf[BOOTCONF]} || return 1
	elif [[ -s ${conf[FWBOOTCONF]} && -s ${conf[BOOTCONF]} ]]; then
		# Compare the firmware config to confdir.
		diff="$(cat ${conf[FWBOOTCONF]} | tail -c +5)" _diff="$(cat ${conf[BOOTCONF]})"
		if ! diff -q <(echo "${diff}") <(echo "${_diff}") >/dev/null; then
			# Configs are different, overwrite confdir on startup firmware config otherwise.
			[[ ${confok} -eq 0 ]] && confok=1
			if [[ ${starting} -eq 0 ]]; then
				do_log warning "${myname} ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} differ, replacing ${conf[FWBOOTCONF]}"
				[[ -e ${conf[FWBOOTCONF]} ]] && chattr -i ${conf[FWBOOTCONF]}
				printf "\x07\x00\x00\x00\x00" >${conf[FWBOOTCONF]} || do_log error "${myname} error creating ${conf[FWBOOTCONF]}"
				efivar -n ${conf[FWGUID]}-UglyLinuxBootCFG -w -f ${conf[BOOTCONF]} 2>&1 || do_log error "${myname} error copying ${conf[BOOTCONF]} to ${conf[FWBOOTCONF]}"
				chattr +i ${conf[FWBOOTCONF]}
			else
				do_log warning "${myname} ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} differ, replacing ${conf[BOOTCONF]}"
				cat ${conf[FWBOOTCONF]} | tail -c +5 >${conf[BOOTCONF]}
			fi
		else
			do_log debug2 "${myname} ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} equal"
		fi
	elif [[ ! -s ${conf[FWBOOTCONF]} && -s ${conf[BOOTCONF]} ]]; then
		# No fwconfig store confdir.
		[[ ${confok} -eq 0 ]] && confok=1
		do_log debug "${myname} no firmware config, copying from ${conf[BOOTCONF]}"
		[[ -e ${conf[FWBOOTCONF]} ]] && chattr -i ${conf[FWBOOTCONF]}
		printf "\x07\x00\x00\x00\x00" >${conf[FWBOOTCONF]} || do_log error "${myname} error creating ${conf[FWBOOTCONF]}"
		efivar -n ${conf[FWGUID]}-UglyLinuxBootCFG -w -f ${conf[BOOTCONF]} || do_log error "${myname} error copying ${conf[BOOTCONF]} to ${conf[FWBOOTCONF]}"
		chattr +i ${conf[FWBOOTCONF]}
	else
		# No bootconf at all.
		do_log warning "${myname} no boot config found"
		bootconf[BOOTSERVERS]=""
	fi

	# If we are starting up, now is the time to load the config.	
	[[ ${starting} -eq 1 ]] && do_daemon_reload_conf	

	# Check if the service config or crypttab has changed on disk.
	if [[ ${starting} -eq 0 && ${confok} -eq 0 ]]; then
		if [[ ! -f ${conf[CRYPTTAB]} ]]; then
			do_log warning "${myname} ${conf[CRYPTTAB]} disappeared, reloading asap"
			confok=1
		fi
		if [[ ! -f ${CONF} ]]; then
		 	do_log error "${myname} ${CONF} disappeared, terminating"
			return 1
		fi
		diff="$(cat ${CONF} |grep -ve "^\s*#")"
		if ! diff -q <(echo "${diff}") <(echo "${systemdconf}") >/dev/null; then
			do_log error "${myname} ${CONF} changed, terminating"
			return 1
		fi
		diff="$(cat ${conf[CRYPTTAB]} |grep -ve "^\s*#" |tr "\t" " " |tr -s " ")"
		if ! diff -q <(echo "${diff}") <(echo "${crypttab}") >/dev/null; then
			do_log debug "${myname} crypttab changed, reloading asap"
			confok=1
		fi
	fi

	# Check the bootserver and user keys if present.
	[[ -z ${bootconf[BOOTSERVERS]} ]] && return
	fwsrvvar="${conf[FWGUID]}-UglyLinux${bootconf[BOOTSERVERKEYS]}" fwsrvkey="${conf[FWDIR]}/UglyLinux${bootconf[BOOTSERVERKEYS]}-${conf[FWGUID]}"
	fwusrvar="${conf[FWGUID]}-UglyLinux${bootconf[BOOTUSERKEY]}"    fwusrkey="${conf[FWDIR]}/UglyLinux${bootconf[BOOTUSERKEY]}-${conf[FWGUID]}"
	srvkey="${CONFDIR}/${bootconf[BOOTSERVERKEYS]}"                 usrkey="${CONFDIR}/${bootconf[BOOTUSERKEY]}"
	if [[ -s ${fwsrvkey} && -s ${srvkey} ]]; then
		# compare the keys, overwrite if necessary
		diff="$(cat ${fwsrvkey} | tail -c +5)" _diff="$(cat ${srvkey})"
		if ! diff -q <(echo "${diff}") <(echo "${_diff}") >/dev/null; then
			# Configs are different, overwrite firmware config
			do_log warning "${myname} ${fwsrvkey} and ${srvkey} differ, replacing ${fwsrvkey}"
			[[ -e ${fwsrvkey} ]] && chattr -i ${fwsrvkey}
			printf "\x07\x00\x00\x00\x00" >${fwsrvkey} || do_log error "${myname} error creating ${fwsrvkey}"
			efivar -n ${fwsrvvar} -w -f ${srvkey} || do_log error "${myname} error copying ${srvkey} to ${fwsrvkey}"
			chattr +i ${fwsrvkey}
		else
			do_log debug2 "${myname} ${fwsrvkey} and ${srvkey} equal"
		fi
	elif [[ -s ${fwsrvkey} && ! -s ${srvkey} ]]; then
		# Keys in fw not in confdir, copy
		do_log debug "${myname} copying ${fwsrvkey} to ${srvkey}"
		cat ${fwsrvkey} | tail -c +5 > ${srvkey} || return 1
	elif [[ ! -s ${fwsrvkey} && -s ${srvkey} ]]; then
		# No fwbootkeys, copy from confdir.
		do_log debug "${myname} no firmware bootserver keys, copying from ${srvkey}"
		[[ -e ${fwsrvkey} ]] && chattr -i ${fwsrvkey}
		printf "\x07\x00\x00\x00\x00" >${fwsrvkey} || do_log error "${myname} error creating ${fwsrvkey}"
		efivar -n ${fwsrvvar} -w -f ${srvkey} || do_log error "${myname} error copying ${srvkey} to ${fwsrvkey}"
		chattr +i ${fwsrvkey}
	else
		# No bootserverkeys at all
		do_log error "${myname} no bootserver keys found"
		bootconf[BOOTSERVERS]=""
	fi

	# No need to check user key, if server key not present.
	[[ -z ${bootconf[BOOTSERVERS]} ]] && return
	if [[ -s ${fwusrkey} && ! -s ${usrkey} ]]; then
		# Key in fw not in confdir, copy
		do_log debug "${myname} copying ${fwusrkey} to ${usrkey}"
		chattr -i ${fwusrkey}; chmod 400 ${fwusrkey}; chattr +i ${fwusrkey}
		cat ${fwusrkey} | tail -c +5 > ${usrkey} || return 1
		chmod 400 ${usrkey}
	elif [[ -s ${fwusrkey} && -s ${usrkey} ]]; then
		# compare the keys, overwrite if necessary
		diff="$(cat ${fwusrkey} | tail -c +5)" _diff="$(cat ${usrkey})"
		if ! diff -q <(echo "${diff}") <(echo "${_diff}") >/dev/null; then
			# Configs are different, overwrite firmware config
			do_log warning "${myname} ${fwusrkey} and ${usrkey} differ, replacing ${fwusrkey}"
			[[ -e ${fwusrkey} ]] && chattr -i ${fwusrkey}
			printf "\x07\x00\x00\x00\x00" >${fwusrkey} || do_log error "${myname} error creating ${fwusrkey}"
			efivar -n ${fwusrvar} -w -f ${usrkey} || do_log error "${myname} error copying ${usrkey} to ${fwusrkey}"
			chattr -i ${fwusrkey}; chmod 400 ${fwusrkey}; chattr +i ${fwusrkey}
		else
			do_log debug2 "${myname} ${fwusrkey} and ${usrkey} equal"
			chattr -i ${fwusrkey}; chmod 400 ${fwusrkey}; chattr +i ${fwusrkey}
			chmod 400 ${usrkey}
		fi
	elif [[ ! -s ${fwusrkey} && -s ${usrkey} ]]; then
		# No fwbootuserkey, copy from confdir
		do_log debug "${myname} no firmware bootuser key, copying from ${usrkey}"
		[[ -e ${fwusrkey} ]] && chattr -i ${fwusrkey}
		printf "\x07\x00\x00\x00\x00" >${fwusrkey} || do_log error "${myname} error creating ${fwusrkey}"
		efivar -n ${fwusrvar} -w -f ${usrkey} || do_log error "${myname} error copying ${usrkey} to ${fwusrkey}"
		chattr -i ${fwusrkey}; chmod 400 ${fwusrkey}; chattr +i ${fwusrkey}
	else
		# No bootuserkeys at all
		bootconf[BOOTSERVERS]=""
	fi
	return 0
}

do_daemon_reload_conf()
{
	do_log debug "${myname} loading configuration"
	local var val IFS=$'\n'
	unset bootconf crypttab systemdconf
	declare -gA bootconf

	# Load the crypttab and systemd conf into memory.
	[[ -s ${conf[CRYPTTAB]} ]] && crypttab="$(cat ${conf[CRYPTTAB]} |grep -ve "^\s*#"| tr "\t" " " |tr -s " ")" 
	[[ -s ${CONF} ]] && systemdconf="$(cat ${CONF} |grep -ve "^\s*#")"

	# Source the boot config if necessary.
	if [[ -s ${conf[BOOTCONF]} ]]; then for var in $(cat ${conf[BOOTCONF]} |grep -ve "^\s*#"); do
		val=${var#*=} var=${var%%=*}
		bootconf[${var^^}]="${val}"
	done fi
	return 0
}

do_daemon_cleanup()
{
	local myname="daemon cleanup (${BASHPID}):" _time_start=$(do_timer) tab_crypt="" pp crypt_arr crypt _crypt dev trim time pid mnt_crypt
	cleanup=$(do_timer ${time_start})
	do_log debug "${myname} cleanup starting at ${time_active}"

	# Ping systemd.
	systemd-notify WATCHDOG=1 WATCHDOG_USEC=$(((2*conf[CLEANUP_TIMER])*1000000))

	# Check if the log writer is still active, restart it if necessary.
	[[ ${FOREGROUND} -eq 0 ]] && if [[ "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" != "${MYNAME}" ]] || ! kill -0 ${pid_logwriter}; then
		[[ "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]] && kill -SIGTERM ${pid_logwriter}
		pid=pid_logwriter
		do_daemon_start_logwriter
		systemd-notify "${MYNAME}: logwriter (PID: ${pid}) terminated after $(do_timer ${time_start})s"
		do_log error "${myname} logwriter (PID: ${pid}) terminated after $(do_timer ${time_start})s"
	fi

	# Kill too long running control conections.
	for pid_ctrl in ${!ctrl[@]}; do
		time=$(do_timer ${ctrl[${pid_ctrl}]##* }) fd_ctrl=${ctrl[${pid_ctrl}]%% *} pid="$(echo "${ctrl[${pid_ctrl}]}" |cut -d' ' -f2)"
		if [[ ${time:0:-4} -ge $((2*conf[PP_TIMEOUT])) ]]; then 
			do_log debug "${myname} cleanup removed control worker (PID: ${pid})"
			if [[ "$(cat /proc/${pid}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
				kill -SIGTERM ${pid}
				do_log debug2 "${myname} killed ${pid}"
			fi
			exec {fd_ctrl}>&-
			unset ctrl[${pid_ctrl}]
		fi
	done
	[[ -z "${!ctrl[@]}" ]] && rm -f ${conf[CRYPTDISKSDDIR]}/*.sock

	# Check the config.
	if ! do_daemon_check_conf; then
		do_log error "${myname} failed to check config, terminating"
		systemd-notify --pid=$$ --stopping --status="${MYNAME}: Failed to Load Configuration"
		trap_term_daemon 0
	fi

	# Remove too long outstanding mounts and passphrase workers.
	for crypt in ${!waiting_mnt[@]}; do
		time="$(do_timer ${waiting_mnt[${crypt}]##* })"
		if [[ ${time::-4} -ge $([[ ${starting} -eq 0 ]] && echo ${conf[PP_TIMEOUT]} || echo $((conf[START_TIMEOUT]+conf[PP_TIMEOUT]))) ]]; then
			do_log debug "${myname} cleanup removed waiting mount for ${crypt}: ${waiting_mnt[${crypt}]}"
			if [[ -n "${pid_getpp[${waiting_mnt[${crypt}]%% *}]}" && "$(cat /proc/${pid_getpp[${waiting_mnt[${crypt}]%% *}]}/comm) 2>/dev/null" == "$MYNAME}" ]]; then
				kill -SIGTERM ${pid_getpp[${waiting_mnt[${crypt}]%% *}]}
				unset pid_getpp[${waiting_mnt[${crypt}]%% *}]
				do_log debug "${myname} killed passhprase worker (PID: ${crypt}: ${waiting_mnt[${crypt}]})"
			fi
			unset waiting_mnt[${crypt}]
		else
			do_log debug2 "${myname} cleanup readded waiting mount for ${crypt}: ${waiting_mnt[${crypt}]}"
		fi
	done
	for crypt in ${!mount[@]}; do if [[ $(do_timer ${mount[${crypt}]##* } | cut -d'.' -f1) -ge ${conf[PP_TIMEOUT]} ]]; then
		do_log debug "${myname} cleanup removed mount for ${crypt} (PID: ${mount[${crypt}]%% *})"
		[[ "$(cat /proc/${mount[${crypt}]%% *}/comm 2>/dev/null)" == "${MYNAME}" ]] && kill -SIGTERM ${mount[${crypt}]%% *}
		unset mount[${crypt}]
	fi done
	
	# Check the active crypts and add to active list if not already present.
	mnt_crypt="$(dmsetup ls --target crypt |cut -f1 |grep -vi "No devices found" 2>/dev/null)"
	for crypt in ${mnt_crypt}; do if [[ -z "${active_mnt[${crypt}]}" ]]; then
		crypt_arr=($(do_xcrypt_fromtab "${myname}" "${crypt}"))
		[[ "$(lsblk -rD /dev/mapper/${crypt} |head -n2 |tail -n1 |cut -d" " -f3 2>/dev/null)" == "0B" ]] && trim=0 || trim=1
		if [[ ! -z "${crypt_arr[@]}" ]]; then
			dev="${crypt_arr[1]}" pp="$(do_eval_pp "${crypt_arr[2]}")"
			active_mnt[${crypt}]="${dev} ${pp} ${trim} $(do_timer)"
		else
			dev=/dev/"$(dmsetup deps ${crypt} -o blkdevname |cut -d: -f2 |tr -d " ()" |cut -d: -f2 2>/dev/null)"
			active_mnt[${crypt}]="${dev} - ${trim} $(do_timer)"
		fi
		do_log debug "${myname} found ${dev} as ${crypt} TRIM ${trim} passphrase ${pp} adding to active list"
		unset waiting_mnt[${crypt}] 
	fi done

	# Check for removed crypts and remove the from active list.
	for crypt in ${!active_mnt[@]}; do
		for _crypt in ${mnt_crypt}; do
			[[ "${crypt}" == "${_crypt}" ]] && continue 2
		done
		crypt_arr=(${active_mnt[${crypt}]})
		do_log warning "${myname} ${crypt_arr[0]} as ${crypt} TRIM ${crypt_arr[2]} passphrase ${crypt_arr[1]} mounted since $(do_timer date ${crypt_arr[3]}) dissapeared"
		unset active_mnt[${crypt}]
	done

	# If we have reloaded look up any managed crypts removed from crypttab and make them unmanaged.
	if [[ ! -z "${tab_crypt}" ]]; then for crypt in ${!active_mnt[@]}; do
		crypt_arr=(${active_mnt[${crypt}]})
		[[ "${crypt_arr[1]}" == "-" ]] && continue
		for _crypt in ${tab_crypt}; do
			[[ "${crypt}" == "${_crypt}" ]] && continue 2
		done
		do_log warning "${myname} ${crypt_arr[0]} as ${crypt} TRIM ${crypt_arr[2]} passphrase ${crypt_arr[1]} mounted since $(do_timer date ${crypt_arr[3]}) removed from crypttab"
		active_mnt[${crypt}]="${crypt_arr[0]} - ${crypt_arr[2]} ${crypt_arr[3]}"
	done fi

	# Check Cached Passphrases
	for _pp in ${!cached_pp[@]}; do if ! keyctl request user "${_pp}" @s >/dev/null 2>&1; then
		do_log info "${myname} ${_pp} passphrase no longer cached"
		unset cached_pp[${_pp}]
	fi done

	do_log debug2 "${myname} cleanup took $(do_timer ${_time_start})s, cached passphrases: ${!cached_pp[@]} - active mounts: ${!active_mnt[@]} - waiting mounts: ${!waiting_mnt[@]}"
}

trap_term_mount()
{
	[[ -n "${_pid_cmd}" && "$(cat /proc/${_pid_cmd}/comm 2>/dev/null)" == "${_cmd}" ]] && kill -SIGTERM ${_pid_cmd}
	exit
}

daemon_mount_crypt()
{
	trap 'trap_term_mount' SIGINT SIGTERM
	local _add_crypt="$1" _pid_ctrl=$2 _add_dev="$3" _add_pp="$(do_eval_pp "$4")" _add_trim="$5" _add_time=$(do_timer) _cmd _pid_cmd
	local _crypt_arr _key="$(keyctl request user "$4" @s 2>/dev/null)" _passphrase="" _res=0 _fd_cmd
	do_log debug "${myname} mounting ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} with ${_add_pp} passphrase"

	# The passphrase should be cached by now, error exit if not.
	if [[ -z "${_key}" ]]; then
		do_log error "${myname} passphrase ${_add_pp} not cached!" 
		echo "passphrase ${_add_pp} 0" >${conf[FIFO]} 
		echo "mount ${_add_crypt} 4 ${pid_ctrl}" >${conf[FIFO]} 
		exit 4
	fi
	_passphrase="$(keyctl pipe "${_key}" 2>/dev/null)"

	# First check if the crypt is already mounted. If so, check if it's on the active list and add if not.	
	if dmsetup info "${_add_crypt}" >/dev/null 2>&1 & _cmd=dmsetup _pid_cmd=$!; wait ${_pid_cmd}; then
		exec {_fd_cmd}< <(lsblk -rD /dev/mapper/${_add_crypt} |head -n2 |tail -n1 |cut -d" " -f3)
		_cmd=lsblk _pid_cmd=$!; ! read -t${conf[QUEUE_TIMEOUT]} -ru${_fd_cmd} _fd_cmd && echo "mount ${_add_crypt} 1 ${pid_ctrl}" >${conf[FIFO]} && exit 1
		[[ "${_fd_cmd}" == "0B" ]] && _add_trim=0 || _add_trim=1
		if [[ -n "${active_mnt[${_add_crypt}]}" ]]; then
			_crypt_arr=(${active_mnt[${_add_crypt}]})
			do_log info "${myname} ${_crypt_arr[0]} already active as ${_add_crypt} TRIM ${_crypt_arr[2]} passphrase ${_crypt_arr[1]} since $(do_timer date ${_crypt_arr[3]})"
			_res=2
		fi
	else
		exec {_fd_cmd}< <(lsblk -rD ${_add_dev} |head -n2 |tail -n1 |cut -d" " -f3)
		_cmd=lsblk _pid_cmd=$!; ! read -t${conf[QUEUE_TIMEOUT]} -ru${_fd_cmd} _fd_cmd && echo "mount ${_add_crypt} 1 ${pid_ctrl}" >${conf[FIFO]} && exit 1
		if [[ "${_fd_cmd}" == "0B" ]]; then
			_add_trim=0 _res=3
			do_log info "${myname} requested TRIM for ${_add_crypt} but device ${_add_dev} does not support it"
		fi
		if cryptsetup open --type plain $([[ ${_add_trim} -eq 1 ]] && echo "--allow-discards") "${_add_dev}" "${_add_crypt}" <<<"${_passphrase}" & _cmd=cryptsetup _pid_cmd=$!; wait ${_pid_cmd}; then
			# Mounted, add to active list.
			do_log info "${myname} mounted ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} passphrase ${_add_pp}"
			do_log debug2 "${myname} mounting ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} passphrase took $(do_timer ${_add_time})s"
		else
			do_log error "${myname} error mounting ${add_dev} as ${add_crypt} TRIM ${add_trim} after $(do_timer ${add_time})s"
			_res=1
		fi
	fi

	echo "mount ${_add_crypt} ${_res} ${_pid_ctrl}" >${conf[FIFO]} 
	exit ${_res}
}

daemon_unmount_crypt()
{
	trap 'trap_term_mount' SIGINT SIGTERM
	local _time_start=$(do_timer) _del_crypt="$1" _pid_ctrl=$2 _cmd _pid_cmd _crypt_arr=() _res=0

	if dmsetup info "${_del_crypt}" >/dev/null 2>&1 & _cmd=dmsetup _pid_cmd=$!; wait ${_pid_cmd}; then
		_crypt_arr=(${active_mnt[${_del_crypt}]})
		if kpartx -d /dev/mapper/${_del_crypt} & _cmd=kpartx _pid_cmd=$!; wait ${_pid_cmd}; then
			if cryptsetup remove "${_del_crypt}" & _cmd=cryptsetup _pid_cmd=$!; wait ${_pid_cmd}; then
				do_log info "${myname} removed ${_crypt_arr[0]} as ${_del_crypt} TRIM ${_crypt_arr[2]} passphrase ${_crypt_arr[1]} mounted since $(do_timer date ${_crypt_arr[3]})"
				do_log debug2 "${myname} removing ${_del_crypt} took $(do_timer ${_time_start})s \"${!active_mnt[@]}\" \"${active_mnt[@]}\""
			else
				[[ ${start_status} -eq 0 ]] && start_status=2
				_res=1
			fi
		else
			_res=1
		fi
		[[ ${_res} -eq 1 ]] && do_log warning "${myname} failed to remove ${_crypt_arr[0]} as ${_del_crypt} TRIM ${_crypt_arr[2]} passphrase ${_crypt_arr[1]} mounted since $(do_timer date ${_crypt_arr[3]})"
	else
		do_log debug "${myname} crypt ${_del_crypt} not present, skipping"
		[[ ${start_status} -eq 0 ]] && start_status=2
		_res=2
	fi

	echo "unmount ${_del_crypt} ${_res} ${_pid_ctrl}" >${conf[FIFO]}
	exit ${_res}
}

trap_term_get_passphrase()
{
	trap 'do_log warning "${_myname} unclean exit after $(do_timer ${_time_start})s"; exit 1;' SIGINT SIGTERM

	# Kill the workers and exit.
	do_log debug2 "${_myname} terminating after $(do_timer ${_time_start})s"
	if [[ ! -z ${__pid_keyclnt} && "$(cat /proc/${__pid_keyclnt}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_keyclnt}
		wait ${__pid_keyclnt}
		do_log debug2 "${_myname} killed key client worker (PID: ${__pid_keyclnt})"
	fi
	if [[ ! -z ${__pid_querypp} && "$(cat /proc/${__pid_querypp}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_querypp}
		wait ${__pid_querypp}
		do_log debug2 "${_myname} killed query worker (PID: ${__pid_querypp})"
	fi
	if [[ ! -z ${_pid_getpp} && "$(cat /proc/${_pid_getpp}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${_pid_getpp}
		wait ${_pid_getpp}
		do_log debug2 "${_myname} killed get worker (PID: ${_pid_getpp})"
	fi
	if [[ ! -z "${_pid_logwriter}" && "$(cat /proc/${_pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${_pid_logwriter}
		wait ${_pid_logwriter}
		do_log debug2 "${_myname} killed log writer (PID: ${_pid_logwriter})"
	fi
	if [[ ! -z ${_pid_putkey} && "$(cat /proc/${_pid_putkey}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		[[ $1 -ne 0 ]] && kill -SIGTERM ${_pid_putkey}
		wait ${_pid_putkey}
		do_log debug2 "${_myname} killed put key worker (PID: ${_pid_putkey})"
	fi
	if [[ ! -z ${_pid_sleep} && "$(cat /proc/${_pid_sleep}/comm 2>/dev/null)" == "sleep" ]]; then
		[[ $1 -ne 0 ]] && kill -SIGTERM ${_pid_sleep}
		do_log debug2 "${_myname} killed sleep (PID: ${_pid_sleep})"
	fi

	exit $1
}

get_passphrase()
{
	trap 'trap_term_get_passphrase' SIGINT SIGTERM

	# We need to get a passphrase. We will start a worker to get the passphrase from the boot servers
	# and a worker to ask for the passphrase using systemd-ask-password after a few seconds.
	# We call ourselves first to provide the two workors with a common {__fd_up} to relay the passphrase.
	# If first parameter is 0 wel will not bother the user for a passphrase.
	local _pid_getpp=${BASHPID} _myname="passphrase:${crypt_arr[2]} (${BASHPID}):" _time_start=$(do_timer) _time_active __pid_keyclnt __pid_querypp

	if [[ $# -eq 2 ]]; then
		# Start key client, wait for a little bit if appropriate, start the query worker and wait.
		_pid_getpp= _pid_logwriter= _pid_putkey= _pid_sleep=
		if [[ ${conf[NET_ONLINE]} -eq 0 || "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ (online|partial)$ ]]; then 
			key_clnt "GET" "${crypt_arr[2]}" & __pid_keyclnt=$!
			do_log debug "${_myname} started key client (PID: ${__pid_keyclnt})"
			sleep $((2*conf[QUEUE_TIMEOUT])) & _pid_sleep=$!; wait ${_pid_sleep}
		fi
		if [[ $2 -eq 1 ]]; then
			query_passphrase ${crypt_arr[2]} & __pid_querypp=$!
			do_log debug "${_myname} started query user (PID: ${__pid_querypp})"
		fi
		wait ${__pid_keyclnt} ${__pid_querypp}
		trap_term_get_passphrase 0
	fi
		
	# Start a logwriter when LOGLEVEL = 2 or 4, redirect our stdout and stderr to that logwiter whenn level = 4.
	local __fd_up _fd_getpp _pid_getpp _pid_logwriter _pid_putkey _passphrase="" _to
	[[ ${FOREGROUND} -eq 0 && ${conf[LOGLEVEL]} -eq 2 ]] && exec {fd_logwriter}> >(logwriter passphrase-${crypt_arr[2]}-${_pid_getpp}.log)
	[[ ${FOREGROUND} -eq 0 && ${conf[LOGLEVEL]} -eq 4 ]] && exec {fd_logwriter}> >(logwriter passphrase-${crypt_arr[2]}-${_pid_getpp}.log) 1>&${fd_logwriter} 2>&1
	_pid_logwriter=$!
	do_log debug "${_myname} started"

	# When starting we will wait max PP_TIMEOUT for the network to come up, or fail.
	[[ ${conf[NET_ONLINE]} -eq 1 && ${starting} -ne 0 ]] && until [[ "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ (online|partial)$ ]]; do
		sleep ${conf[QUEUE_TIMEOUT]} & _pid_sleep=$!; wait ${_pid_sleep}
		_time_active=$(do_timer ${_time_start})
		[[ ${_time_active%%.*} -ge ${conf[PP_TIMEOUT]} || "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ offline$ ]] && break
	done

	# Start the worker to get the passphrase from the boot servers or from the user. fd 4 will point back to us.
	exec {_fd_getpp}< <(get_passphrase "$1" 1 {__fd_up}>&1-)
	_pid_getpp=$!
	do_log debug "${_myname} started get passphrase worker (PID: ${_pid_getpp})"

	# We should get a pssphrase or an empty response from the workers or timeout.
	[[ ${starting} -ne 0 ]] && _to=$((conf[START_TIMEOUT]+conf[PP_TIMEOUT])) || _to=${conf[PP_TIMEOUT]}
	if ! IFS= read -t${_to} -u${_fd_getpp} _passphrase; then
		do_log warning "${_myname} $([[ $? -eq 142 ]] && echo timeout || echo failed) after $(do_timer ${_time_start})s"
		echo "passphrase ${crypt_arr[2]} 0" >${conf[FIFO]}
		trap_term_get_passphrase 1
	fi

	# Put key (back) to servers, cache and send to daemon.
	key_clnt "PUT" "${crypt_arr[2]}" "${_passphrase}" & _pid_putkey=$!
	do_cache_pp "${_myname}" "${crypt_arr[2]}" "-1" "${_passphrase}" || trap_term_get_passphrase 1
	echo "passphrase ${crypt_arr[2]} 1" >${conf[FIFO]}

	do_log debug2 "${_myname} took $(do_timer ${_time_start})s"
	trap_term_get_passphrase 0
}

# [END OF MAIN DAEMON FUNCTIONS]

# [BEGIN OF DAEMON CONTROL FUNCTIONS]
trap_term_control()
{
	trap 'do_log warning "${_myname} unclean exit after ${_time_start})s"; exit 1;' SIGINT SIGTERM

	[[ "$(cat /proc/${pid_socat}/comm)" == "socat" ]] && kill -SIGTERM ${pid_socat}
	[[ $1 -eq 0 ]] && do_log debug2 "${_myname} finished after $(do_timer ${_time_start})s"
	if [[ $1 -ne 0 ]]; then
		do_log debug2 "${_myname} terminating after $(do_timer ${_time_start})s"
		if [[ ! -z "${_socat_PID}" && "$(cat /proc/${_socat_PID}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_socat_PID}
			wait ${_socat_PID}
			do_log debug2 "${_myname} killed socat coproc (PID: ${_socat_PID})"
		fi
		if [[ ! -z "${_pid_putkey}" && "$(cat /proc/${_pid_putkey}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_putkey}
			wait ${_pid_putkey}
			do_log debug2 "${_myname} killed putkey worker (PID: ${_pid_putkey})"
		fi
		if [[ ! -z "${_pid_getpp}" ]]; then
			kill -SIGTERM ${_pid_getpp}
			wait ${_pid_getpp}
			do_log debug2 "${_myname} killed getpp worker (PID: ${_pid_getpp})"
		fi
		if [[ ! -z "${_pid_logwriter}" &&"$(cat /proc/${_pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			exec {fd_logwriter}>&-
			#kill -SIGTERM ${_pid_logwriter}
			wait ${_pid_logwriter}
		fi
	fi
	echo "control ${pid_ctrl} finished" >${conf[FIFO]}

	exit $1
}

daemon_control_status()
{
	# Connect to control socket and blurt status in some form of a pretty fashion.
	do_control_init "status" "Status Report"
	local _key _passphrase="" _waiting_mnt=${msg[5]} _tab_crypt __crypt_arr=() _crypt __crypt _pp _trim _time _status

	# Output the status to the coproc, which will transfer it to stdout of the requestor. First al active mounts.
	echo -e "\r${GREY}${BOLD}${PR}CRYPT${PD}DEVICE${PE}TRIM${PP}PASSPHRASE${PT}ACTIVE SINCE${PS}STATUS${NOR}\r" >&${_socat[1]}
	[[ -n "${bootconf[STORAGEPREFIX]}" ]] && __storageprefix="${bootconf[STORAGEPREFIX]}" || __storageprefix="storage"
	for _crypt in ${!active_mnt[@]}; do
		_status="" __crypt_arr=(${active_mnt[${_crypt}]}); _pp=${__crypt_arr[1]}
		[[ "${__crypt_arr[2]}" == "1" ]] && _trim="On" || _trim="Off"
		[[ "${__crypt_arr[1]}" == "-" && "${_crypt}" =~ ^${__storageprefix}[0-9]{1,2}$ && -n "${bootconf[STORAGEPP]}" ]] && _pp="$(do_eval_pp "${bootconf[STORAGEPP]}")" 
		[[ "${__crypt_arr[1]}" == "-" && "${_crypt}" =~ ^${__storageprefix}[0-9]{1,2}$ && -z "${bootconf[STORAGEPP]}" ]] && _pp="system:master" 
		[[ "${__crypt_arr[1]}" == "-" ]] && _status="${YEL}Online (U)" || _status="${GRN}Online (M)"
		echo -e "${PR}${_crypt}${PD}${__crypt_arr[0]##*/}${PE}${_trim}${PP}${_pp}${PT}$(do_timer date ${__crypt_arr[3]})${PS}${_status}${NOR}\r" >&${_socat[1]}
	done

	# Output all unmounted and waiting crypts.
	_tab_crypt="$(tr "\t" " " <<<"${crypttab}" |cut -d" " -f1)"
	for _crypt in ${_tab_crypt}; do
		for __crypt in ${!active_mnt[@]}; do
			[[ "${_crypt}" == "${__crypt}" ]] && continue 2
		done
		for __crypt in ${!waiting_mnt[@]}; do if [[ "${_crypt}" == "${__crypt}" ]]; then
			_status="${YEL}Waiting" _time=$(do_timer date ${waiting_mnt[${_crypt}]##* })
			break
		fi done
		[[ ! "${_status}" == "${YEL}Waiting" ]] && _status="${RED}Offline" _time="-"
		__crypt_arr=($(do_xcrypt_fromtab "${_myname}" "${_crypt}"))
		[[ "${__crypt_arr[3]}" == "1" ]] && _trim="On" || _trim="Off"
		echo -e "${PR}${_crypt}${PD}${__crypt_arr[1]}${PE}${_trim}${PP}$(do_eval_pp ${__crypt_arr[2]})${PT}${_time}${PS}${_status}${NOR}\r" >&${_socat[1]}
	done
	echo >&${_socat[1]}

	# Output cached passphrases.
	[[ ${conf[LOGLEVEL]} -ge 1 ]] && echo -e "${PR}${GREY}${BOLD}Cached Passphrases:${PS}${NOR}${!cached_pp[@]}\r\n" >&${_socat[1]}
	if [[ ${conf[LOGLEVEL]} -ge 3 ]]; then
		# Output passphrases.
		echo -e "${PR}${GREY}${BOLD}PASSPHRASE${PS}VALUE${NOR}\r" >&${_socat[1]}
		for _pp in ${!cached_pp[@]}; do
			_key="$(keyctl request user "${_pp}" @s 2>/dev/null)"; _passphrase="$(keyctl pipe "${_key}" 2>/dev/null)"
			echo -ne "${PR}${_pp}:${PS}" >&${_socat[1]}
			if [[ -z "${_key}" ]]; then
				echo -e "${RED}${BOLD}FAIL${NOR}\r" >&${_socat[1]}
				echo "passphrase ${_pp} 2" >${conf[FIFO]}
			else
				echo -e "\"${_passphrase}\"${NOR}\r" >&${_socat[1]}
			fi
		done
		echo >&${_socat[1]}
	fi
	echo -e "${UL}${myname} Running Since $(do_timer date ${time_start}) ($(do_timer ${time_start})s)${NOR}\r" >&${_socat[1]}

	trap_term_control 0
}

daemon_control_smarterase()
{
	# Secure Erase Device.
	[[ "${cmd}" == "smart" ]] && do_control_init "smart" "S.M.A.R.T." || do_control_init "erase" "Secure Erase"
	local _crypt="${_crypt_arr[0]}" _dev="$(do_find_dev "${_myname}" "${_crypt_arr[1]}")" _res=""

	if [[ -z "${_crypt_arr[@]}" ]]; then
		echo -e "\r${RED}${BOLD}${msg[5]} not Found on Crypttab.${NOR}\r" >&${_socat[1]}
		do_log debug "${_myname} ${msg[5]} not found on crypttab"
		trap_term_control 1
	elif [[ -z "${_dev}" ]]; then
		echo -e "\r${RED}${BOLD}Device ${_dev} not Found in ${conf[BLOCKDEVSDIRS]}.${NOR}\r" >&${_socat[1]}
		do_log debug "${_myname} ${_dev} not Found in ${conf[BLOCKDEVSDIRS]}"
		trap_term_control 1
	fi

	[[ ${_smartall} -eq 1 ]] && smartctl -x ${_dev} >&${_socat[1]} 2>&1 || smartctl -A ${_dev} >&${_socat[1]} 2>&1
	if [[ ${_smarttest} -eq 1 || "${cmd}" == "erase" ]] && dmsetup info "${_crypt}" >/dev/null 2>&1; then
		echo -e "\r${RED}${BOLD}${_crypt} Still Active.${NOR}\r" >&${_socat[1]}
		do_log debug "${_myname} ${_crypt} still active"
		trap_term_control 1
	fi

	if [[ "${cmd}" == "smart" && ${_smarttest} -eq 1 ]]; then
		smartctl -t long ${_dev} >&${_socat[1]} 2>&1
		do_log debug "${_myname} smart test started on ${_crypt}"
		echo -e "\r${GRN}${BOLD}Started SMART test on ${_dev}.${NOR}\r" >&${_socat[1]}
	elif [[ "${cmd}" == "erase" ]]; then
		do_control_confirm "This Will Wipe all Data on ${_dev}, Are You Sure? (y/N)" "n"
		if [[ "${_res}" == "y" ]]; then
			echo -e "${RED}${BOLD}Secure Erasing ${_dev} ${YEL}password: $(hostname)${NOR}\r" >&${_socat[1]}
			hdparm -I ${_dev} |grep "ENHANCED SECURITY ERASE UNIT" >/dev/null 2>&1 && _res="--security-erase-enhanced" || _res="--security-erase"
			hdparm --security-set-pass "$(hostname)" ${_dev}
			hdparm ${_res} "$(hostname)" ${_dev} &
			do_log debug "${_myname} secure erasing ${_crypt}"
		fi
	fi

	trap_term_control 0
}

daemon_control_putrmkey()
{
	# Remove the key file for the passphrase.
	[[ "${cmd}" == "rmkey" ]] && do_control_init "rmkey" "Removing Key File" || do_control_init "putkey" "Putting Key File"
	local _pp="$(do_eval_pp "${msg[5]}")" _res=0; local _keyfile="${conf[FWDIR]}/UglyLinux${_pp}.key-${conf[FWGUID]}" _key="$(keyctl request user "${_pp}" @s 2>/dev/null)" _passphrase _t _s
	if [[ ${_fw} -eq 0 && ${_cache} -eq -2 && "${_srv}" == "0" && ${_add} -eq -3 && ${_confirm} -eq 0 ]]; then
		[[ -n "${keylife[${_pp}]}" ]] && _cache="${keylife[${_pp}]}" || _cache=${conf[KEYLIFE]}
		_fw=1 _srv=${bootconf[BOOTSERVERS]} _add=-1 _confirm=1
	elif [[ ${_fw} -eq 0 && ${_cache} -eq -2 && "${_srv}" == "0" && ${_add} -eq -3 && ${_confirm} -eq 1 ]]; then
		[[ -n "${keylife[${_pp}]}" ]] && _cache="${keylife[${_pp}]}" || _cache=${conf[KEYLIFE]}
		_fw=1 _srv=${bootconf[BOOTSERVERS]} _add=-1 _confirm=0
	fi
	[[ "${_srv}" == "1" ]] && _srv=${bootconf[BOOTSERVERS]}
	[[ "${cmd}" == "rmkey" ]] && _s="Removing" _t="from" || _s="Putting" _t="to"
	do_log debug "${_myname} ${_s,,} ${_pp} ${_t,,} $([[ ${_cache} -ne -2 ]] && echo "cache ")$([[ ${_fw} -eq 1 ]] && echo "firmware ")$([[ "${_srv}" != "0" ]] && echo "${_srv}")"
	echo -e "\r${BOLD}${_s} ${_pp} ${_t}: $([[ ${_cache} -ne -2 ]] && echo "cache ")$([[ ${_fw} -eq 1 ]] && echo "firmware ")$([[ "${_srv}" != "0" ]] && echo "${_srv}")${NOR}\r" >&${_socat[1]}

	# Add or remove key to/from firmware
	[[ "${cmd}" == "putkey" ]] && ! do_control_get_passphrase "${_pp}" && trap_term_control 1
	if [[ "${cmd}" == "rmkey" && ${_fw} -eq 1 && ! -e ${_keyfile} ]]; then
		echo -e "\r${BOLD}${RED}${_keyfile} Does not Exist.${NOR}\r" >&${_socat[1]}
		do_log debug "${_myname} ${_keyfile} does not exist"
	elif  [[ ${_fw} -eq 1 ]]; then
		[[ ${_confirm} -eq 1 ]] && do_control_confirm "Continue ${_s} ${_pp} ${_t} Firmware? (Y/n)" "y" || _res="y"
		if [[ ${_res} == "y" ]]; then
			if [[ "${cmd}" == "rmkey" ]] && chattr -i ${_keyfile} && rm -f ${_keyfile}; then
				echo -e "\r${BOLD}${GRN}Removed ${_keyfile} Succesfully.${NOR}\r" >&${_socat[1]}
				do_log debug "${_myname} removed ${_keyfile}"
			elif [[ "${cmd}" == "putkey" ]] && do_write_keyfile "${_myname}" "${_pp}" "${_passphrase}"; then
				echo -e "\r${BOLD}${GRN}Wrote ${_keyfile} Succesfully.${NOR}\r" >&${_socat[1]}
				do_log debug "${_myname} wrote ${_keyfile}"
			else
				echo -e "\r${BOLD}${RED}Failed to $([[ "${cmd}" == "putkey" ]] && echo Write || echo Remove) ${_keyfile}.${NOR}\r" >&${_socat[1]}
				[[ "${cmd}" == "rmkey" ]] && do_log debug "${_myname} failed to remove ${_keyfile}"
			fi
		fi
	fi

	# Add or remove key to/from keyring.
	if [[ "${cmd}" == "rmkey" && ${_cache} -ne -2 && -z "${_key}" ]]; then
		do_log debug "${_myname} ${_pp} not cached"
		echo -e "\r${BOLD}${RED}${_pp} not Cached.${NOR}\r" >&${_socat[1]}
	elif [[ ${_cache} -ne -2 ]]; then
		[[ ${_confirm} -eq 1 ]] && do_control_confirm "Continue ${_s} ${_pp} ${_t} Cache? (Y/n)" "y" || _res="y"
		if [[ ${_res} == "y" ]]; then
			if [[ "${cmd}" == "rmkey" ]] && keyctl revoke "${_key}" >dev/null 2>&1 && keyctl unlink "${_key}" @s >/dev/null 2>&1; then
				echo "passphrase ${_pp} 2" >${conf[FIFO]}
				echo -e "\r${BOLD}${GRN}Removed ${_pp} from Cache.${NOR}\r" >&${_socat[1]}
				do_log debug "${_myname} removed ${_pp} from cache"
			elif [[ "${cmd}" == "putkey" ]] && do_cache_pp "${_myname}" "${_pp}" "${_cache}" "${_passphrase}"; then
				echo "passphrase ${_pp} 1" >${conf[FIFO]}
				echo -e "\r${BOLD}${GRN}Cached ${_pp} Passphrase.${NOR}\r" >&${_socat[1]}
			else
				echo -e "\r${BOLD}${RED}Failed to $([[ "${cmd}" == "rmkey" ]] && echo Remove || echo Cache) ${_pp} Passphrase$([[ "${cmd}" == "rmkey" ]] && echo " from Cache").${NOR}\r" >&${_socat[1]}
				[[ "${cmd}" == "rmkey" ]] && do_log debug "${_myname} failed to remove ${_pp} from cache"
			fi
		fi
	fi

	# Add or remove key to/from servers (cache).
	if [[ "${_srv}" != "0" ]]; then
		exec {__fd_user}>&${_socat[1]}
		[[ ${_confirm} -eq 1 ]] && do_control_confirm "Continue ${_s} ${_pp} ${_t} Boot Servers: ${NOR}${GREY}${_srv}${RED}${BOLD}? (Y/n)" "y" || _res="y"
		if [[ "${_res}" == "y" ]]; then
			echo -e "\r${BOLD}${GRN}${_s} ${_pp} Key ${_t} Boot Servers: ${GREY}${_srv}.${NOR}\r" >&${_socat[1]}
			do_log debug "${_myname} ${_s,,} ${_pp} key ${_t,,} boot servers: ${_srv}"
			[[ "${cmd}" == "putkey" ]] && key_clnt "PUT" "${_pp}" "${_passphrase}" ${_srv} & __pid_putkey=$!; wait ${__pid_putkey}
			[[ "${cmd}" == "rmkey" ]] && key_clnt "DEL" "${_pp}" ${_srv} & __pid_putkey=$!; wait ${__pid_putkey}
			echo -e "\r" >&${_socat[1]}
		fi
		[[ ${_add} -ne -3 && ${_confirm} -eq 1 ]] && do_control_confirm "Continue Adding ${_pp} ${_t} Boot Servers Cache: ${NOR}${GREY}${_srv}${RED}${BOLD}? (Y/n)" "y" || _res="y"
		if [[ "${_res}" == "y" && ${_add} -ne -3 ]]; then
			[[ ${_add} -eq -2 && -n "${keylife[${_pp}]}" ]] && _add=${keylife[${_pp}]}
			[[ ${_add} -eq -2 ]] && _add=${conf[KEYLIFE]}
			[[ "${cmd}" == "putkey" ]] && _s="Adding" _t="to" || _s="Deleting" _t="from"
			echo -e "\r${BOLD}${GRN}${_s} ${_pp} Key ${_t} Boot Servers Cache: ${GREY}${_srv}.${NOR}\r" >&${_socat[1]}
			do_log debug "${_myname} ${_s,,} ${_pp} key ${_t,,} boot servers cache: ${_srv}"
			[[ "${cmd}" == "putkey" ]] && key_clnt "ADD" "${_pp}" "${_add}" "${_passphrase}" ${_srv} & __pid_putkey=$!; wait ${__pid_putkey}
			[[ "${cmd}" == "rmkey" ]] && key_clnt "REM" "${_pp}" ${_srv} & __pid_putkey=$!; wait ${__pid_putkey}
			echo -e "\r" >&${_socat[1]}
		fi
	fi

	trap_term_control 0
}

daemon_control_del()
{
	do_control_init "del" "Removing Crypt"
	local _del_crypt="${_crypt_arr[0]}" _del_dev="${_crypt_arr[1]}" _del_pp="${_crypt_arr[2]}" _del_trim="${_crypt_arr[3]}" _del_time="$(do_timer)" _res=""

	# Check if specified crypt is on tab, user decides to exit or continue if it's not.
	if [[ -z "${_crypt_arr[@]}" ]]; then
		_del_crypt=${msg[5]} _del_dev="?" _del_pp="?" _del_trim="?"
		do_log debug "${_myname} ${msg[5]} not found in Crypttab.${NOR}"
		echo -ne "\r${RED}${BOLD}${_del_crypt} not on Crypttab, Continue Removing (y/N)? ${NOR}" >&${_socat[1]}
		read -t${conf[USER_TIMEOUT]} -rsn1 -u ${_socat[0]} _res
		[[ "${_res,,}" == $'\r' || -z "${_res,,}" ]] && _res=n
		echo -e "${BOLD}${_res}${NOR}\r" >&${_socat[1]}
		[[ "${_res,,}" != "y" ]] && trap_term_control 0
		_crypttab=0 _del_dev="-" _del_pp="-"
	fi
	echo "notify ${pid_ctrl} unmount ${_del_crypt}" >${conf[FIFO]}
	read -t${conf[USER_TIMEOUT]} -r _res
	case ${_res} in
	0)
		do_log debug "${_myname} removed ${_del_dev##*/} as ${_del_crypt} using ${_del_pp} passphrase trim ${_del_trim}"
		echo -e "\r${BOLD}${GRN}Removed ${_del_dev##*/} as ${_del_crypt} Using ${_del_pp} TRIM ${_del_trim} Passphrase, Active Since $(do_timer date ${_del_time})${NOR}\r" >&${_socat[1]};;
	2)
		do_log debug "${_myname} ${_del_crypt} not active"
		echo -e "\r${BOLD}${YEL}${_del_crypt} not active${NOR}\r" >&${_socat[1]};;
	*)
		do_log debug "${_myname} failed to remove ${_del_dev##*/} as ${_del_crypt} using ${_del_pp} passphrase trim ${_del_trim}"
		echo -e "\r${BOLD}${RED}Failed to Remove ${_del_dev##*/} as ${_del_crypt} Using ${_del_pp} Passphrase TRIM ${_del_trim}${NOR}\r" >&${_socat[1]};;
	esac

	# Remove from crypttab.
	[[ ${_crypttab} -eq 1 && ( ${_res} -ne 0 || ${_confirm} -eq 1 ) ]] && do_control_confirm "Continue Removing ${_del_crypt} from Crypttab? (Y/n)" "y" || _res="y"
	if [[ ${_crypttab} -eq 1 && "${_res}" == "y" ]]; then
		sed -i "/^${_del_crypt}\\s/D" ${conf[CRYPTTAB]}
		kill -SIGHUP ${pid_daemon}
		do_log debug "${_myname} removed ${_del_dev##*/} as ${_del_crypt} using ${_del_pp} passphrase trim ${_del_trim} from crypttab"
		echo -e "\r${BOLD}${GRN}Removed ${_del_dev} as ${_del_crypt} TRIM ${_del_trim} from Crypttab${NOR}\r" >&${_socat[1]}
		kill -SIGHUP {pid_daemon}
	fi

	trap_term_control 0
}

daemon_control_add()
{
	do_control_init "add" "Adding Crypt"
	local _add_crypt="${_crypt_arr[0]}" _add_dev="${msg[5]}" _add_dev2="${msg[6]}" _add_pp="$(do_eval_pp "${msg[7]}")" _add_trim="${msg[8]}" _res="" __crypt_arr _passphrase=""
	
	if [[ ${_crypttab} -eq 0 && -z "${_crypt_arr[0]}" ]]; then
		# Recevied add with just a crypt, if it's not on the tab exit.
		echo -e "\r${BOLD}${RED}${msg[5]} not Found on Crypttab${NOR}\r" >&${_socat[1]}
		do_log debug "${_myname} ${msg[5]} not found on crypttab"
		trap_term_control 1
	elif [[ ${_crypttab} -eq 0 ]]; then
		_add_dev="$(do_find_dev "${_myname}" "${_crypt_arr[1]}")" _add_pp="$(do_eval_pp "${_crypt_arr[2]}")" _add_trim="${_crypt_arr[3]}"
	elif [[ ${_crypttab} -eq 1 ]]; then
		# Crypt should be added to tab, check if specified crypt and dev are already on tab.
		__crypt_arr=($(do_xcrypt_fromtab "${_myname}" "${_add_dev2}"))
		if [[ -z "${_crypt_arr[@]}" && -z "${__crypt_arr[@]}" ]]; then
			# Crypt and dev not on tab, find device.
			_add_dev="$(do_find_dev "${_myname}" "${_add_dev}")" _add_dev2="$(do_find_dev "${_myname}" "${_add_dev2}")"
			if [[ -z "${_add_dev}" && -z "${_add_dev2}}" ]]; then
				do_log debug "${_myname} neither ${_add_crypt} nor ${_add_dev} is a valid block device in ${conf[BLOCKDEVDIRS]}"
				echo -e "\r${BOLD}${RED}Neither ${_add_crypt} nor ${_add_dev} is a Valid Block Device in ${conf[BLOCKDEVDIRS]}.${NOR}\r" >&${_socat[1]}
				trap_term_control 1
			elif [[ ! -z "${_add_dev}" && ! -z "${_add_dev2}" ]]; then
				do_log debug "${_myname} both ${_add_crypt} and ${_add_dev} are valid block devices in ${conf[BLOCKDEVDIRS]}"
				echo -e  "\r${BOLD}${RED}Both ${_add_crypt} and ${_add_dev} are Valid Block Devices in ${conf[BLOCKDEVDIRS]}'.${NOR}\r" >&${_socat[1]}
				trap_term_control 1
			fi
			[[ ! -z "${_add_dev}" ]] && _add_crypt="${msg[6]}" || _add_crypt="${msg[5]}" _add_dev="${_add_dev2}"
		else
			# Crypt and/or dev already on tab.
			if [[ ! -z "${_crypt_arr[@]}" && ! -z "${__crypt_arr[@]}" ]]; then
				do_log debug "${_myname} both ${_add_crypt} and ${_add_dev} already on crypttab"
				echo -e "\r${BOLD}${RED}Both ${_add_crypt} and ${_add_dev} Already on Crypttab.${NOR}\r" >&${_socat[1]}
			elif [[ ! -z "${_crypt_arr[@]}" ]]; then
				do_log debug "${_myname} ${_add_dev} already on crypttab"
				echo -e "\r${BOLD}${RED}${_add_dev} Already on Crypttab.${NOR}\r" >&${_socat[1]}
			else
				do_log debug "${_myname} ${_add_dev2} already on crypttab"
				echo -e "\r${BOLD}${RED}${_add_dev2} Aready on Crypttab.${NOR}\r" >&${_socat[1]}
			fi
			trap_term_control 1
		fi
	fi
	if [[ ${_add_crypt}${_add_dev}${_add_pp} =~ ( |,|\||\$) || ( ${_crypttab} -eq 0 && -z "${_add_dev}" ) ]]; then
		do_log debug "${_myname} incorrect crypt or dev"
		[[ ${_crypttab} -eq 0 && -z "${_add_dev}" ]] && echo -e "\r${BOLD}${RED}${_crypt_arr[1]} not Found in \"${conf[BLOCKDEVDIRS]}\"${NOR}\r" >&${_socat[1]}
		[[ ! -z "${_add_dev}" ]] && echo -e "\r${BOLD}${RED}Illegal Characters \" $,|\" in Crypt or Dev.${NOR}\r" >&${_socat[1]}
		trap_term_control 1
	elif ! do_control_get_passphrase "${_add_pp}"; then
		# if we do not get a passphrase we cannot mount, continue to add on tab after confirmation.
		echo -e "\r${BOLD}${RED}No Passphrase Received, Cannot Mount ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase.${NOR}\r" >&${_socat[1]}
		_confirm=1
	elif [[ $(do_cache_pp "${_myname}" "${_add_pp}" "-1" "${_passphrase}")$? -eq 1 ]]; then
		echo -e "\r${BOLD}${RED}Failed to Cache ${_add_pp} Passphrase.${NOR}\r" >&${_socat[1]}
		trap_term_control 1
	else
		echo "notify ${pid_ctrl} mount ${_add_crypt} ${_add_dev} ${_add_pp} ${_add_trim}" >${conf[FIFO]}
		echo "passphrase ${_add_pp} 1" >${conf[FIFO]}
		read -t${conf[USER_TIMEOUT]} -r _res
		case ${_res} in
		0)
			do_log debug "${_myname} mounted ${_add_dev} as ${_add_crypt} trim ${_add_trim} using ${_add_pp} passphrase"
			echo -e "\r${BOLD}${GRN}Mounted ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase${NOR}\r" >&${_socat[1]};;
		1)
			do_log debug "${_myname} failed to mount ${_add_dev} as ${_add_crypt} trim ${_add_trim} using ${_add_pp} passphrase"
			echo -e "\r${BOLD}${RED}Failed to Mount ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase${NOR}\r" >&${_socat[1]};;
		2)
			do_log debug "${_myname} ${_add_dev} as ${_add_crypt} trim ${_add_trim} using ${_add_pp} passphrase already active"
			echo -e "\r${BOLD}${YEL}${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase Already Active${NOR}\r" >&${_socat[1]};;
		3)
			do_log debug "${_myname} mounted ${_add_dev} as ${_add_crypt} trim ${_add_trim} using ${_add_pp} passphrase"
			echo -e "\r${BOLD}${YEL}Mounted ${_add_dev} as ${_add_crypt} ${BOLD}${RED}TRIM ${_add_trim} ${BOLD}${YEL}Using ${_add_pp} Passphrase${NOR}\r" >&${_socat[1]};;
		*)
			do_log debug "${_myname} failed to mount ${_add_dev} as ${_add_crypt} trim ${_add_trim} using ${_add_pp} passphrase"
			echo -e "\r${BOLD}${RED}TIMEOUT or ERROR! (${_res})${NOR}\r" >&${_socat[1]}
			trap_term_control 1;;
		esac
	fi

	if [[ ${_crypttab} -eq 1 ]]; then
		# Crypt should be added to tab, ask for confirmation if necessary (error or request by user).
		[[ ${_res} -ne 0 || ${_confirm} -eq 1 ]] && do_control_confirm "Continue Adding ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} Using ${_add_pp} Passphrase to Crypttab? (Y/n)" || _res="y"
		if [[ "${_res}" == "y" ]]; then
			# Add the crypt to the crypttab and send reload signal to daemon.
			echo -e "${_add_crypt}\t${_add_dev##*/}\t${_add_pp}\t${_add_trim}" >>${conf[CRYPTTAB]}
			do_log debug "${_myname} added ${_add_dev} as ${_add_crypt} passphrase ${_add_pp} trim ${_add_trim} to crypttab"
			echo -e "\r${BOLD}${GRN}Added ${_add_dev} as ${_add_crypt} Passphrase ${_add_pp} TRIM ${_add_trim} to Crypttab.${NOR}\r" >&${_socat[1]}
			kill -SIGHUP ${pid_daemon}
		fi
	fi
	[[ ${_confirm} -eq 1 ]] && do_control_confirm "Put ${_add_pp} Passphrase to Bootservers? (Y/n)" y || _res="y"
	if [[ "${_res}" == "y" ]]; then
		echo -e "\r${BOLD}${GRN}Putting ${_add_pp} Key to Boot Servers: ${GREY}${bootconf[BOOTSERVERS]}.${NOR}\r" >&${_socat[1]}
		exec {__fd_user}>&${_socat[1]}
		key_clnt "PUT" "${_add_pp}" "${_passphrase}" & _pid_putkey=$!; wait ${_pid_putkey}
		echo -e "\r" >&${_socat[1]}
	fi

	trap_term_control 0
}

daemon_control_shell()
{
	trap 'trap_term_control' SIGINT SIGTERM 
	local _myname="daemon-shell (${BASHPID}:${pid_ctrl},${_pid_socat}):" _time_start=$(do_timer) _socat_PID _pid_logwriter

	# Start logwriter with dedicated logfile when LOGLEVEL=2 or = 4. When level = 4 redirect out stdout and stderr to the logwriter.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]]	&& exec {fd_logwriter}> >(logwriter shell-$$.log {fd_fifo}>&-) 1>&${fd_logwriter} 2>&1 \
										|| exec {fd_logwriter}> >(logwriter shell-$$.log {fd_fifo}>&-)
		_pid_logwriter=$!
	fi
	
	if [[ ! conf[DEBUGSHELL] -eq 1 ]]; then
		do_log error "${_myname} debug shell not enabled"
		kill -SIGTERM ${pid_ctrl}
		trap_term_control 1
	fi
	
	# Open a connection to the listening socket. Check if it exists first.
	export LC_ALL=en_US.UTF-8
	TERM=xterm socat exec:"/bin/bash --login",pty,ctty,raw,stderr,sigint,setsid,sane UNIX-CONNECT:${sock_ctrl} & _socat_PID=$!
	do_log warning "${_myname} debug shell started"
	wait ${_socat_PID}
	do_log warning "${_myname} debug shell ended"
	trap_term_control 0
}

do_control_init()
{
	trap 'trap_term_control' SIGINT SIGTERM
	_myname="daemon-$1 (${BASHPID}:${pid_ctrl}):" _crypt_arr= _pid_logwriter= _pid_putkey= _confirm=0 _crypttab=0 _trim=0 _smartall=0 _smarttest=0 _cache= _fw=0 _srv= add= _socat=

	# Start logwriter with dedicated logfile when LOGLEVEL=2 or = 4. When level = 4 redirect out stdout and stderr to the logwriter.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && _pid_logwriter="1>&${fd_logwriter} 2>&1"
		exec {fd_logwriter}> >(logwriter control-$1-${BASHPID}.log ${_pid_logwriter})
		_pid_logwriter=$!
	fi
	[[ "${cmd,,}" =~ ^(add|del|smart|erase)$ ]] && _crypt_arr=($(do_xcrypt_fromtab "${_myname}" "${msg[3]}"))
	
	# Check if socket exists first.
	if [[ ! -S ${sock_ctrl} ]]; then
		do_log error "${_myname} ${sock_ctrl} is not a socket, pocket rocket or a locket"
		trap_term_control 1
	fi

	# Open the client socket.
	do_log debug "${_myname} connecting to ${sock_ctrl}"
	coproc _socat ( socat - UNIX-CONNECT:${sock_ctrl} )
	[[ ${conf[LOGLEVEL]} -ge 3 ]] && echo -e "\r${_myname} Connected for $2.\r" >&${_socat[1]}

	# Check the command line, it should contain crypt, device and passphrase and two options (confirm / crypttab) for add or del.
	if [[ "${cmd}" == "smart" ]]; then
		_smartall=${msg[$((${#msg[@]}-2))]} _smarttest=${msg[$((${#msg[@]}-1))]}
	elif [[ "${cmd}" =~ ^(putkey|rmkey)$ ]]; then
		_confirm=${msg[$((${#msg[@]}-5))]} _add=${msg[$((${#msg[@]}-4))]} _cache=${msg[$((${#msg[@]}-3))]} _fw=${msg[$((${#msg[@]}-2))]} _srv=$(IFS=','; echo ${msg[$((${#msg[@]}-1))]})
	elif [[ "${cmd}" =~ ^(add|del)$ ]]; then
		_trim=${msg[$((${#msg[@]}-3))]} _confirm=${msg[$((${#msg[@]}-2))]} _crypttab=${msg[$((${#msg[@]}-1))]} 
	fi
	do_log debug "${_myname} control connection initialized (PID: ${_socat_PID} SOCK:${sock_ctrl})"
}

do_control_confirm()
{
	echo -ne "\r${RED}${BOLD}$1 ${NOR}" >&${_socat[1]}
	read -t${conf[USER_TIMEOUT]} -rsn1 -u ${_socat[0]} _res 
	[[ $? -ne 0 && $? -ne 142 ]] && trap_term_control 1
	[[ "${_res,,}" != "y" && "${_res,,}" != "n" ]] && _res=${2,,} || _res=${_res,,}
	echo -e "${BOLD}${_res}${NOR}\r" >&${_socat[1]}
}

do_control_get_passphrase()
{
	# Ask to get passphrase from network, if not cached, or query the user for the passphrase.
	local _key="$(keyctl request user "$1" @s 2>/dev/null)" _pp=$1 _res _fd_getpp _pid_getpp __fd_up __fd_user
	if [[ -n "${_key}" ]]; then
		# Passphrase is still cached, use it and notify the daemon about the crypt.
		_passphrase="$(keyctl pipe "${_key}" 2>/dev/null)"
		do_log "${_myname} found cached ${_pp} passphrase"
		echo -e "\r${BOLD}${GRN}Found Cached ${_pp} Passphrase${NOR}\r" >&${_socat[1]}
	else
		do_log "${_myname} ${_pp} passphrase not cached"
		echo -e "\r${BOLD}${RED}Passphrase ${_pp} not Cached.${NOR}\r" >&${_socat[1]}
		[[ -n "${cached_pp[${_pp}]}" ]] && echo "passphrase ${_pp} 2" >${conf[FIFO]}
	fi

	# If confirm option is specified ask to retreive passphrase from boot servers.
	if [[ -z "${_key}" && ( ${conf[NET_ONLINE]} -eq 0 || "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ (online|partial)$ ) ]]; then
		[[ ${_confirm} -eq 1 ]] && do_control_confirm "${_pp} Passphrase Not Cached, Get Passphrase from Boot Servers? (Y/n)" "y" || _res="y"
		if [[ "${_res}" == "y" ]]; then
			do_log debug "${_myname} getting ${_pp} passphrase from boot servers: ${bootconf[BOOTSERVERS]}"
			echo -e "\r${BOLD}Getting ${_pp} Passphrase from Boot Servers: ${NOR}${GREY}${bootconf[BOOTSERVERS]}${NOR}\r" >&${_socat[1]}
			exec {_fd_getpp}< <(key_clnt "GET" "${_pp}" {__fd_up}>&1- {__fd_user}>&${_socat[1]}-)
			_pid_getpp=$!
			IFS= read -t$((conf[PP_TIMEOUT]/conf[NET_RETRIES]+1)) -ru${_fd_getpp} _passphrase && _key=1 || echo -e "\r\n${RED}${BOLD}Failed to Get ${_pp} Passphrase from Boot Servers${NOR}\r" >&${_socat[1]}
			exec {_fd_getpp}>&-
			[[ "$(cat /proc/${_pid_getpp}/comm 2>/dev/null)" == "${MYNAME}" ]] && kill -SIGTERM ${_pid_getpp}
		fi
	fi

	# Query the user for the passphrase.
	if [[ -z "${_key}" ]]; then
		exec {_fd_getpp}< <(query_passphrase "${_pp}" {__fd_up}>&1- {__fd_user[0]}<&${_socat[0]}- {__fd_user[1]}>&${_socat[1]}-)
		_pid_getpp=$!
		if IFS= read -t${conf[PP_TIMEOUT]} -ru${_fd_getpp} _passphrase; then
			_key=1
		else
			do_log debug "${_myname} failed to get ${_pp} passphrase from user"
			echo -e "\r\n${RED}${BOLD}Failed to Get ${_pp} Passphrase from Your Yourself and You${NOR}\r" >&${_socat[1]}
		fi
		exec {_fd_getpp}>&-
		[[ "$(cat /proc/${_pid_getpp}/comm 2>/dev/null)" == "${MYNAME}" ]] && kill -SIGTERM ${_pid_getpp}
	fi

	# Got passphrase, put and cache it.
	if [[ -n "${_key}" ]]; then
		do_log debug "${_myname} got ${_pp} passphrase"
		[[ -z "${_passphrase}" ]] && echo -e "\r${BOLD}${YEL}Your ${_pp} Passphrase Has no Character, Just Like You.${NOR}\r" >&${_socat[1]}
		return 0
	else
		do_log debug "${_myname} ${_pp} passphrase error or timeout"
		return 1
	fi
}

# [END OF DAEMON CONTROL FUNCTIONS]

# [BEGIN SHARED FUNCTIONS]

do_xcrypt_fromtab()
{
	# Extract the line for the device received in the udev command from the crypttab into crypt_arr array.
	# Element 1 = cryptdisk name
	# Element 2 = cryptdisk block device
	# Element 3 = passphrase
	# Element 4 = TRIM
	local myname=$1 crypt_arr i
	for ((i=2;i<=$#;i++)); do
		crypt_arr=($(grep -iE "(^|\s)${!i}\s" <<<"${crypttab}" 2>/dev/null)) 
		[[ "${#crypt_arr[@]}" -eq 3 ]] && crypt_arr[3]=0
		if [[ "${#crypt_arr[@]}" -eq 0 ]]; then
			do_log debug "${myname} device ${!i} not found on crypttab"
		elif [[ "${#crypt_arr[@]}" -ne 4 || ${crypt_arr[0]}${crypt_arr[1]}${crypt_arr[2]} =~ (,| |\|\$) ]]; then
			do_log warning "${myname} incorrect crypttab entry ${crypt_arr[@]}"
			_status=2
		else
			do_log debug2 "${myname} device ${!i} found on crypttab"
			[[ "${crypt_arr[3]}" == "1" || "${crypt_arr[3],,}" == "y" || "${crypt_arr[3],,}" == "yes" ]] && crypt_arr[3]=1 || crypt_arr[3]=0
			echo "${crypt_arr[@]}"
			break
		fi
	done
}

do_eval_pp()
{
	# Evaluate the passphrase and prepend cryptdisks: or make system:master. 
	if [[ ${1,,} =~ ^(1|master|system|system:master)$ ]]; then
		echo "system:master"
	elif [[ ! ${1,,} =~ ^cryptdisks: ]]; then
		echo "cryptdisks:${1,,}"
	else 
		echo "${1,,}"
	fi
}

do_find_dev()
{
	local myname=$1 blockdevdir dev=$2
	for blockdevdir in ${conf[BLOCKDEVSDIRS]}; do if [[ -b ${blockdevdir}/${dev} ]]; then
		do_log debug "${myname} found ${blockdevdir}/${dev} for ${dev}"
		echo "${blockdevdir}/${dev}"
		return
	fi done
	do_log debug "${myname} ${dev} not found in ${conf[BLOCKDEVSDIRS]}"
}

do_check_passphrase()
{
	# Check the received passphrase against the stored key in firmware. Write key if it doesn't exist.
	local myname="$1" pp="$2" passphrase="$3" rmkey="$4"
	if [ -s ${conf[FWDIR]}/UglyLinux${pp}.key-${conf[FWGUID]} ]; then
		if  $(cat ${conf[FWDIR]}/UglyLinux${pp}.key-${conf[FWGUID]} | tail -c +5 | openssl aes-256-cbc -d -salt -pbkdf2 -in - -out /dev/null -k "${passphrase}" 2>/dev/null); then
			do_log debug "${myname} passphrase check ok"
			return 0
		else
			do_log debug "${myname} passphrase check fail"
			if [[ "${rmkey}" == "rmkey" ]]; then 
				chattr -i ${conf[FWDIR]}/UglyLinux${pp}.key-${conf[FWGUID]} 
				rm -f ${conf[FWDIR]}/UglyLinux${pp}.key-${conf[FWGUID]}
			fi
			return 1
		fi
	else
		do_write_keyfile "${myname}" "${pp}" "${passphrase}" || return 3
		do_log debug "${myname} passphrase not checked"
		return 2
	fi
}

do_write_keyfile()
{
	# Write a keyfile for key received to firmware.
	local myname=$1 pp="$2" passphrase="$3" srv="$4" keydir="$([[ -n "$4" ]] && echo ${conf[KEYDIR]} || echo ${conf[CRYPTDISKSDDIR]})" res
	if ! head -c256 /dev/urandom |openssl aes-256-cbc -e -salt -pbkdf2 -in - -out ${keydir}/${pp}.key -k "${passphrase}"; then
		res=1
		do_log error "${myname} error creating ${keydir}/${pp}.key"
	elif [[ -z "${srv}" ]] && ! efivar -n ${conf[FWGUID]}-UglyLinux${pp}.key -w -f ${conf[CRYPTDISKSDDIR]}/${pp}.key; then
		res=2
		do_log error "${myname} error writing ${conf[FWDIR]}/UglyLinux${pp}.key-${conf[FWGUID]}"
	else
		res=0
		do_log debug "${myname} wrote $([[ -z "${srv}" ]] && echo ${conf[FWDIR]}/UglyLinux${pp}.key-${conf[FWGUID]} || echo ${keydir}/${pp}.key)"
	fi
	[[ -z "${srv}" ]] && rm -f ${conf[CRYPTDISKSDDIR]}/${pp}.key
	return ${res}
}

do_cache_pp()
{
	local myname=$1 pp=$2 key="$(keyctl request user "$2" @s 2>/dev/null)" timeout="$3" passphrase="$4"
	[[ ${timeout} -eq -1 && -n "${keylife[$2]}" ]] && timeout=${keylife[$2]}
	[[ ${timeout} -eq -1 ]] && timeout=${conf[KEYLIFE]}
	
	# Cache if the passphrase is already cached.
	if [[ -z "${key}" ]]; then
		key="$(keyctl padd user "${pp}" @s <<<"${passphrase}" 2>/dev/null)"
		[[ ${timeout} -ne 0 ]] && keyctl timeout "${key}" "${timeout}"
	else
		do_log info "${myname} ${pp} passphrase already cached"
		return 2
	fi
	if [[ -z "${key}" ]]; then
		do_log warning "${myname} failed to cache ${pp} passphrase"
		return 1
	fi

	do_log debug "${myname} cached ${pp} passphrase $([[ ${timeout} -eq 0 ]] && echo indefinitely || echo "for $((timeout/60)) minutes")"
	return 0
}

# Query the user for a passphrase. We get called with 1 parameter, the passphrase to query.
# Also a fd redirection for {__fd_up} to relay the passphrase and {__fd_user[]} when interactively querying for cli.
trap_term_query_passphrase()
{
	trap 'do_log warning "${myname} unclean finish after $(do_timer ${_time_start})s"; exit 1;' SIGINT SIGTERM

	if [[ ! -z "${pid_askpp}" && "$(cat /proc/${pid_askpp}/comm 2>/dev/null)" == "systemd-ask-pas" ]]; then
		kill -SIGKILL ${pid_askpp}
		do_log debug2 "${myname} killed ask worker (PID: ${pid_askpp})"
	fi

	do_log debug2 "${myname} terminating after $(do_timer ${_time_start})s"

	exit 0
}

query_passphrase()
{
	trap 'trap_term_query_passphrase' SIGINT SIGTERM

	# Ask for a pssphrase input by user through systemd-ask-password
	local myname="query:$1 (${BASHPID}):" _time_start=$(do_timer) pp=$1 pid_askpp fd_askpp passphrase _passphrase ppchk
	do_log debug "${myname} query for ${pp} passphrase started"

	do_ask_passphrase "Enter ${pp} Passphrase: " || trap_term_query_passphrase

	# Received a passphrase from the user check it against key stored in firmware.
	local ppchk=$(do_check_passphrase "${myname}" "${pp}" "${passphrase}")$?
	case ${ppchk} in
	3)
		do_log error "${myname} Unable to confirm passphrase due to key error, giving up"
		trap_term_query_passphrase;;
	2)
		# Key not present in firmware, ask for confirmation from the user.
		_passphrase="${passphrase}"
		do_ask_passphrase "Created key file. Confirm ${pp} Passphrase: " || trap_term_query_passphrase
		# If the passphrase does not match, enter a loop until it does and wirte the keyfile if ok.
		until [[ "${_passphrase}" == "${passphrase}" ]]; do
			do_ask_passphrase "Passphrases do not Match. Enter ${pp} Passphrase: " || trap_term_query_passphrase
			_passphrase="${passphrase}"
			do_check_passphrase "${myname}" "${pp}" "${passphrase}" rmkey
			do_ask_passphrase "Confirm ${pp} Passphrase: " || trap_term_query_passphrase
			[[ "${_passphrase}" == "${passphrase}" ]] && do_write_keyfile "${myname}" "${pp}" "${passphrase}"
		done
		do_log debug "${myname} received passphrase after $(do_timer ${_time_start})s";;
	1)
		# Passphrase entered does not match stored key, keep asking until it does.
		until [[ ${ppchk} -eq 0 ]]; do
			do_log debug2 "${myname} query passphrase check failed"
			do_ask_passphrase "Incorrect Passphrase. Enter ${pp} Passphrase: " || trap_term_query_passphrase
			ppchk=$(do_check_passphrase "${myname}" "${pp}" "${passphrase}")$?
		done
		do_log debug "${myname} received passphrase after $(do_timer ${_time_start})s";;
	0)
		# Passphrase received is ok.
		do_log debug "${myname} received passphrase after $(do_timer ${_time_start})s";;
	esac

	# Notify the daemon, so it knows passphrase worker has finished.
	echo "${passphrase}" >&${__fd_up}
	
	do_log debug2 "${myname} took $(do_timer ${_time_start})s total"
}

do_ask_passphrase()
{
	local CHAR DEL="$(printf "\x7F")" ca=() c=0
	if [[ -z "${__fd_user[@]}" ]]; then
		# Query for the passphrase in the background, record pid so we can kill if passphrase is received from server.
		exec {fd_askpp}< <(NOTIFY_SOCKET= systemd-ask-password --timeout=0 --id=${pp} "$1" {__fd_up}>&-)
		pid_askpp=$!
		IFS= read -ru${fd_askpp} passphrase || exit 1
	else
		passphrase="" CHAR=""
		echo -ne "\r${BOLD}$1${NOR}" >&${__fd_user[1]}
		until [[ "${CHAR}" == $'\r' || "${CHAR}" == $'\n' ]]; do
		   	read -t${conf[USER_TIMEOUT]} -rsN1 -u${__fd_user[0]} CHAR || return 1
			if [[ "${CHAR}" == "${DEL}" && "${#passphrase}" -ge 1 ]]; then
				for (( c=0; c<${ca[${#passphrase}]}; c++ )); do echo -ne "\b \b" >&${__fd_user[1]}; done
				passphrase="${passphrase::-1}"
			elif [[ "${CHAR}" != $'\r' && "${CHAR}" != $'\n' && "${CHAR}" != "${DEL}" ]]; then
				passphrase+="${CHAR}"
				for (( c=0; c<$((RANDOM%4)); c++ )); do echo -n "*" >&${__fd_user[1]}; done
				ca[${#passphrase}]=${c}
			fi
		done
		echo -e "\r" >&${__fd_user[1]}
	fi
}

# [END OF SHARED FUNCTIONS]

# [BEGIN OF KEY SERVER & CLIENT FUNCTIONS]

# A simple keyserver for caching passphrases so that booting systems can get passphrases here.
# The server runs under a user account correspnding to the host they are for.
# All confi etc. is in that users home directory. Key life can be set as default and per passphrase in the config.
trap_term_systemd_keysrv()
{
	trap 'do_log warning "${myname} unclean exit after $(do_timer ${time_start})s"; exit 1;' SIGINT SIGTERM

	do_log warning "${myname} terminating after $(do_timer ${time_start})s"
	if [[ ! -z "${pid_logwriter}" && "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_logwriter}
		wait ${pid_logwriter}
		do_log debug2 "${myname} killed log writer (PID: ${pid_logwriter})"
	fi
	rm -f ${CONFDIR}/*.res

	exit 0
}

do_systemd_keysrv()
{
	trap 'trap_term_systemd_keysrv' SIGINT SIGTERM SIGHUP
	local fd_fifo pid msg cmd pp passphrase key timeout _conf="$(cat ${CONF})" res=0 r IFS=' '
	declare -A cached_pp
	systemd-notify --ready --status="${myname}: Started on $(do_timer date ${time_start})"
	
	do_log debug "${myname} started on $(do_timer date ${time_start})"
	exec {fd_fifo}<>${conf[KEYSRV_FIFO]}
	while true; do 
		do_log debug "${myname} running since $(do_timer date ${time_start})"
		systemd-notify WATCHDOG=1 WATCHDOG_USEC=$(((2*conf[CLEANUP_TIMER])*1000000))
		[[ "$(cat ${CONF})" != "${_conf}" ]] && break

		# Read new message from queue, when add or put also read the passphrase. Clean up expired passphrases before handling command.
		read -t${conf[CLEANUP_TIMER]} -ru${fd_fifo} -a msg
		r=$? res=0
		for pp in ${!cached_pp[@]}; do if ! keyctl request user "${pp}" @s >/dev/null 2>&1; then
			do_log info "${myname} ${pp} passphrase has expired"
			unset cached_pp[${pp}]
		fi done
		pid="${msg[0]}" cmd="${msg[1],,}" pp="$(do_eval_pp ${msg[2]})" timeout="${msg[3]}"
		[[ ${cmd} =~ ^(put|add)$ ]] && ! IFS= read -t${conf[KEYSRV_TIMEOUT]} -ru${fd_fifo} passphrase && do_log error "${myname} did not receive ${pp} passphrase from client" && continue
		case ${r} in
			142) continue;;
			0)   do_log debug "${myname} new command \"${msg[@]}\"";;
			*)   break
		esac

		# Check input and process command.
		if [[ ! ${pid} =~ ^[0-9]+$ || ! ${cmd} =~ ^(add|rem|get|put|del|status)$ || $((${#msg[@]}-3)) -gt 2 || ! -p ${cmd}.${pid}.res ]]; then
			do_log error "${myname} invalid command"
			continue
		fi
		case ${cmd} in
		add)
			do_log debug "${myname} adding ${pp} key"
			if [[ ! -f ${conf[KEYDIR]}/${pp}.key ]] || ! openssl aes-256-cbc -d -salt -pbkdf2 -in ${conf[KEYDIR]}/${pp}.key -out /dev/null -k "${passphrase}" >/dev/null 2>&1; then
				[[ ! -f ${conf[KEYDIR]}/${pp}.key ]] && do_log warning "${myname} no key file for ${pp}" || do_log warning "${myname} key file for ${pp} differs from received passphrase"
				res=$(do_write_keyfile "${myname}" "${pp}" "${passphrase}" "1")$?
			fi
			[[ ${res} -eq 0 ]] && res=$(do_cache_pp "${myname}" "${pp}" "${timeout}" "${passphrase}")$?
			key="$(keyctl request user ${pp} @s 2>/dev/null)"
			if [[ ${res} -eq 0 ]]; then
				cached_pp[${pp}]="$(do_timer),${timeout}"
				do_keysrv_send "OK"
			elif [[ ${res} -eq 1 ]]; then
				do_keysrv_send "NOK"
			elif [[ ${res} -eq 2 && "$(keyctl pipe "${key}" 2>/dev/null)" == "${passphrase}" ]]; then
				do_keysrv_send "SAME"
			elif [[ ${res} -eq 2 ]]; then
				do_log warning "${myname} ${pp} passphrase differs from cached passphrase, revoking"
				keyctl revoke "${key}" >/dev/null 2>&1
				keyctl unlimk "${key}" @s >/dev/null 2>&1
				if [[ $(do_cache_pp "${myname}" "${pp}" "${timeout}" "${passphrase}")$? -eq 0 ]]; then
					cached_pp[${pp}]="$(do_timer),${timeout}"
					do_keysrv_send "OK"
				else
					unset cached_pp[${pp}]
					do_keysrv_send "NOK"
				fi
			fi;;
		rem)
			do_log debug "${myname} removing ${pp} key"
			key="$(keyctl request user "${pp}" @s 2>/dev/null)"
			if [[ -z "${key}" ]]; then
				do_log warning "${myname} REM of ${pp} passphrase not cached"
				do_keysrv_send "SAME"
			#elif ! keyctl revoke "${_key}" >/dev/null 2>&1 || ! keyctl unlink "${_key}" @s >/dev/null 2>&1; then
			elif ! keyctl revoke "${key}" || ! keyctl unlink "${key}" @s; then
				do_log warning "${myname} REM of ${pp} passphrase from cache failed"
				do_keysrv_send "NOK"
			else
				do_log info "${myname} REM of ${pp} passphrase from cache succeeded"
				unset cached_pp[${pp}]
				do_keysrv_send "OK"
			fi;;
		get)
			do_log debug "${myname} getting ${pp} key"
			key="$(keyctl request user ${pp} @s 2>/dev/null)"
			[[ ! -z "${key}" ]] && passphrase="$(keyctl pipe ${key} 2>/dev/null)"
			if [[ -z "${key}" ]] || ! openssl aes-256-cbc -d -salt -pbkdf2 -in ${conf[KEYDIR]}/${pp}.key -out /dev/null -k "${passphrase}"; then
				if [[ -z "${key}" ]]; then
					do_log info "${myname} did not find ${pp} passphrase for ${host}"
				else
					#The requstor has probably updated the key since it was loaded, revoke it.
					do_log warning "${myname} ${pp} passphrase for ${host} does not match stored key file, revoking."
					keyctl revoke ${key}
					keyctl unlink ${key} @s
				fi
				do_keysrv_send "NOK"
			else
				do_log info "${myname} found ${pp} passphrase for ${host}"
				do_keysrv_send "OK"
				do_keysrv_send "${passphrase}"
			fi;;
		put)
			do_log debug "${myname} putting ${pp} key"
			if openssl aes-256-cbc -d -salt -pbkdf2 -in ${conf[KEYDIR]}/${pp}.key -out /dev/null -k "${passphrase}" >/dev/null 2>&1; then
				do_log info "${myname} recevied $? passphrase ${pp} equal to stored passphrase"
				do_keysrv_send "SAME"
			elif ! do_write_keyfile "${myname}" "${pp}" "${passphrase}" "1"; then
				do_log warning "${myname} PUT of passphrase ${pp} failed."
				do_keysrv_send "NOK"
			else
				do_log info "${myname} PUT of papssphrase ${pp} succeeded."
				do_keysrv_send "OK"
			fi;;
		del)
			do_log debug "${myname} deleting ${pp} key"
			if [[ ! -e ${conf[KEYDIR]}/${pp}.key ]]; then
				do_log warning "${myname} Key of Passphrase ${pp} does not exist"
				do_keysrv_send "SAME"
			elif rm ${conf[KEYDIR]}/${pp}.key; then
				do_log info "${myname} DEL of passphrase ${pp} succeeded"
				do_keysrv_send "OK"
			else
				do_log warning "${myname} DEL of passphrase ${pp} failed"
				do_keysrv_send "NOK"
			fi;;
		status)
			do_keysrv_send "${BOLD}${myname} Running Since $(do_timer date ${time_start})${NOR}"
			do_keysrv_send "${BOLD}Cached Passphrases: ${!cached_pp[@]}${NOR}"
			[[ ${conf[LOGLEVEL]} -ge 1 ]] && for pp in ${!cached_pp[@]}; do
				timeout=${cached_pp[${pp}]#*,}
				[[ ${timeout} -eq -1 && -n "${keylife[${pp}]}" ]] && timeout=${keylife[${pp}]}
				[[ ${timeout} -eq -1 ]] && timeout=${conf[KEYLIFE]}
				do_keysrv_send "${BOLD}${pp}: ${RED}\"$([[ ${conf[LOGLEVEL]} -ge 3 ]] && keyctl pipe "$(keyctl request user "${pp}" @s)")\"${NOR}${BOLD}, timeout: $((timeout-$(do_timer ${cached_pp[${pp}]%%,*} |cut -d'.' -f1)))s${NOR}"
			done
			do_keysrv_send ".";;
		esac
		rm -f ${cmd}.${pid}.res
	done

	systemd-notify --stopping --status="${myname}: Read Error ($?), terminating after $(do_timer ${time_start})s"
	trap_term_keysrv
}

do_keysrv_send()
{
	echo "$@" >${cmd}.${pid}.res
}

# Key client executes commands on keyservers and relays the result back to caller, which may be user on cli.
# We expect to be called with two or three parameters, depending on the command. And optionally a list of servers.
# 1. The command (GET / PUT / DEL)
# 2. The passphrase name
# 3. In case of PUT, the passphrase
# In case of GET we also need a redirection for {__fd_up} and for cli a {__fd_user} to relay the passphrase / status.
trap_term_key_clnt()
{
	trap 'do_log warning "${myname} unclean exit after $(do_timer ${_time_start})s"; exit 1;' SIGINT SIGTERM

	# Reader received SIGTERM or SIGINT. See if we have any workers to kill and remove the queue.
	do_log debug2 "${myname} terminating after $(do_timer ${_time_start})s"

	for ts in ${pid_cmd}; do if [[ "$(cat /proc/${ts}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${ts}
		do_log debug2 "${myname} killed ${cmd} (PID: ${ts})"
		wait ${ts}
	fi done
	if [[ -n "${_ssh_PID}" && "$(cat /proc/${_ssh_PID}/comm 2>/dev/null)" == "ssh" ]]; then
		kill -SIGTERM ${_ssh_PID}
		do_log debug2 "${myname} killed ssh (PID: ${_ssh_PID})"
		wait ${_ssh_PID}
	fi
	if [[ -n "${pid_sleep}" && "$(cat /proc/${pid_sleep}/comm 2>/dev/null)" == "sleep" ]]; then
		kill -SIGTERM ${pid_sleep}
		do_log debug2 "${myname} killed sleep (PID: ${pid_sleep})"
	fi
	if [[ "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_logwriter}
		wait ${pid_logwriter}
	fi

	exit 0
}

key_clnt()
{
	trap 'trap_term_key_clnt' SIGINT SIGTERM

	local myname="${1,,}:$2 (${BASHPID}):" _time_start=$(do_timer) cmd="${1,,}" pp="$(do_eval_pp "$2")" timeout kto to ts pid_logwriter pid_cmd pid_sleep passphrase="" srv res ret _ssh
	[[ "${cmd}" == "add" ]] && kto="$3" passphrase="$4" srv="$5" to="to"
	[[ "${cmd}" == "put" ]] && passphrase="$3" srv="$4" to="to"
	[[ ! ${cmd} =~ ^(put|add)$ ]] && srv="$3" to="from"
	[[ ${starting} -eq 0 ]] && timeout=${conf[PP_TIMEOUT]} || timeout=${conf[START_TIMEOUT]}
	[[ "${cmd}" == "get" ]] && timeout=$((timeout/(conf[NET_RETRIES]+1)))

	# If we are called with exactly one server, execute the command on that server.
	if [[ ( "${cmd}" == "add" && $# -eq 5 ) || ( "${cmd}" == "put" && $# -eq 4 ) || ( ! "${cmd}" =~ ^(put|add)$ && $# -eq 3 ) ]]; then
		pid_cmd= pid_logwriter=
		do_log debug "${myname} ${cmd} ${pp} key ${to} ${srv}"
		coproc _ssh ( ssh -i ${CONFDIR}/${bootconf[BOOTUSERKEY]} -o UserKnownHostsFile=${CONFDIR}/${bootconf[BOOTSERVERKEYS]} ${bootconf[BOOTUSER]}@${srv} "${cmd^^}" "${pp}" "${kto}" )
		[[ ${cmd} =~ ^(put|add)$ ]] && echo "${passphrase}" >&${_ssh[1]} 
		_pid_ssh=$!
		if ! IFS= read -t${timeout} -ru${_ssh[0]} res || [[ ( "${cmd}" != "get" && ! "${res,,}" =~ ^(ok|same)$ ) || ( "${cmd}" == "get" && $(do_check_passphrase "${myname}" "${pp}" "${res}")$? -eq 1 ) ]]; then
			[[ $? -eq 142 ]] && ts="timeout" || ts="failed"
			[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${RED}${srv}${NOR} " >&${__fd_user}
			do_log warning "${myname} ${cmd} ${pp} key ${to} ${srv} for ${bootconf[BOOTUSER]} ${ts}"
		elif [[ "${cmd,,}" != "get" && "${res,,}" == "same" ]]; then
			[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${YEL}${srv}${NOR} " >&${__fd_user}
			do_log info "${myname} ${cmd} ${pp} key ${to} ${srv} for ${bootconf[BOOTUSER]} equal"
		elif [[ ( "${cmd,,}" != "get" && "${res,,}" == "ok" ) || "${cmd,,}" == "get" ]]; then
			[[ ! -z "${__fd_user}" ]] && echo -ne "${BOLD}${GRN}${srv}${NOR} " >&${__fd_user}
			do_log debug "${myname} ${cmd} ${pp} key ${to} ${srv} for ${bootconf[BOOTUSER]} succeeded"
			[[ "${cmd}" == "get" ]] && echo "${res}" >&${__fd_up}
		fi
		exit
	fi

	# When starting wait for network before trying to connect to servers.
	if [[ ${FOREGROUND} -eq 0 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && exec {fd_logwriter}> >(logwriter ${cmd}-${pp}-${BASHPID}.log) 1>&${fd_logwriter} 2>&1 || exec {fd_logwriter}> >(logwriter ${cmd}-${pp}-${BASHPID}.log)
		pid_logwriter=$!
	fi
	if [[ ${starting} -ne 0 && ${conf[NET_ONLINE]} -eq 1 ]]; then
		ts=$(do_timer) ret=0
		until [[ ${ret} -ge ${conf[START_TIMEOUT]} || "$(NOTIFY_SOCKET= networkctl status | grep "Online state")" =~ (online|partial)$ ]]; do
			sleep ${conf[QUEUE_TIMEOUT]} & pid_sleep=$!; wait ${pid_sleep}
			ret=$((ret+$(do_timer ${ts} |cut -d. -f1)))
		done
	fi

	# For every boot server on command line start a command sub shell. If no list of servers was specified use all.
	# We will not retry PUT or DEL as this should just work if the other side is set up. Also no retry for getting the passphrase for cli user.
	[[ ${cmd} == "add" ]] && srv="${@:5}" 
	[[ ${cmd} == "put" ]] && srv="${@:4}"
	[[ ! ${cmd} =~ ^(put|add)$ ]] && srv="${@:3}"
	[[ -z "${srv}" ]] && srv="${bootconf[BOOTSERVERS]}"
	do_log debug "${myname} ${cmd} ${pp} key ${to} boot servers: ${srv}"
	ret=0
	while [[ -n "${srv}" && ${ret} -le ${conf[NET_RETRIES]} ]]; do
		to=$(do_timer)
		for ts in ${srv}; do
			[[ "${cmd}" == "add" ]] && key_clnt "${cmd}" "${pp}" "${kto}" "${passphrase}" "${ts}" & pid_cmd+="$! "
			[[ "${cmd}" == "put" ]] && key_clnt "${cmd}" "${pp}" "${passphrase}" "${ts}" & pid_cmd+="$! "
			[[ ! ${cmd} =~ ^(put|add)$ ]] && key_clnt "${cmd}" "${pp}" "${ts}" & pid_cmd+="$! "
		done
		wait ${pid_cmd}
		[[ "${cmd}" != "get" || -n "${__fd_user}" ]] && unset srv || ret=$((ret+1))
		[[ "${cmd}" == "get" && -z "${__fd_user}" && ${ret} -le ${conf[NET_RETRIES]} ]] && sleep $((timeout-$(do_timer ${to} |cut -d'.' -f1))) & pid_sleep=$!; wait ${pid_sleep}
	done

	do_log debug2 "${myname} finished after $(do_timer ${_time_start})s"
}

do_sanboot()
{
	local myname="${MYNAME}-boot" passphrase fd_fifo res r
	if ! do_init_conf keyserver || ! mkfifo ${CONFDIR}/${cmd}.$$.res || ! chgrp ${conf[KEYSRV_GROUP]} ${CONFDIR}/${cmd}.$$.res || ! chmod 620 ${CONFDIR}/${cmd}.$$.res; then
		logger -p user.error "${myname}: initialization failed"
		return 1
	elif [[ ${cmd} =~ ^(put|add)$ ]] && ! IFS= read -t${conf[KEYSRV_TIMEOUT]} -ru${in} passphrase; then
		logger -p user.error "${myname}: did not receive ${pp} passphrase from ssh client"
		return 1
	fi
	exec {fd_fifo}<>${CONFDIR}/${cmd}.$$.res
	echo "$$ ${cmd}" "${pp}" "${timeout}" >${conf[KEYSRV_FIFO]}
	[[ ${cmd} =~ ^(put|add)$ ]] && echo "${passphrase}" >${conf[KEYSRV_FIFO]}
	if ! read -t${conf[KEYSRV_TIMEOUT]} -ru${fd_fifo} res; then
		logger -p user.error "${myname}: no response received from keyserver"
		r=1
	elif [[ "${cmd}" == "get" && "${res,,}" == "nok" ]] || [[ "${cmd}" == "get" ]] && ! IFS= read -t${conf[KEYSRV_TIMEOUT]} -ru${fd_fifo} passphrase; then
		[[ $? -ne 0 ]]            && logger -p user.error "${myname}: no ${pp} passphrase received from keyserver"
		[[ "${res,,}" == "nok" ]] && logger -p user.error "${myname}: ${pp} passphrase not cached by keyserver"
		kill -SIGTERM ${PPID}
		r=1
	elif [[ "${cmd}" == "get" ]]; then
		logger -p user.info "${myname}: received ${pp} passphrase from keyserver"
		echo "${passphrase}" >&${out}
	elif [[ "${cmd}" == "put" || "${cmd}" == "del" ]]; then
		[[ "${res,,}" == "same" ]] && r=2 && logger -p user.info "${myname}: put ${pp} passphrase on keyserver equal to stored passhrase"
		[[ "${res,,}" == "nok" ]]  && r=1 && logger -p user.warning "${myname}: failed to put ${pp} passphrase to keyserver"
		[[ "${res,,}" == "ok" ]]   && r=0 && logger -p user.info "${myname}: put ${pp} passphrase to keyserver succeeded"
	elif [[ "${cmd}" == "del" ]]; then
		[[ "${res,,}" == "same" ]] && r=2 && logger -p user.info "${myname}: ${pp} passphrase not stored on keyserver"
		[[ "${res,,}" == "nok" ]]  && r=1 && logger -p user.warning "${myname}: failed to remove ${pp} passphrase from keyserver"
		[[ "${res,,}" == "ok" ]]   && r=0 && logger -p user.info "${myname}: removing ${pp} passphrase from keyserver succeeded"
	elif [[ "${cmd}" == "add" ]]; then
		[[ "${res,,}" == "same" ]] && r=2 && logger -p user.info "${myname}: ${pp} passphrase already cached on keyserver"
		[[ "${res,,}" == "nok" ]]  && r=1 && logger -p user.warning "${myname}: failed to cache ${pp} passphrase on keyserver"
		[[ "${res,,}" == "ok" ]]   && r=0 && logger -p user.info "${myname}: adding ${pp} passphrase to keyserver cache succeeded"
	elif [[ "${cmd}" == "rem" ]]; then
		[[ "${res,,}" == "same" ]] && r=2 && logger -p user.info "${myname}: ${pp} passphrase not cached on keyserver"
		[[ "${res,,}" == "nok" ]]  && r=1 && logger -p user.warning "${myname}: failed to remove ${pp} passphrase from keyserver cache"
		[[ "${res,,}" == "ok" ]]   && r=0 && logger -p user.info "${myname}: removing ${pp} passphrase from keyserver cache succeeded"
	fi

	[[ "${cmd}" != "get" ]] && echo "${res}" >&${out}
	return ${r}
}

do_bootsan()
{
	# Set HOME to host(user) homedir and initialize config.
	local HOME=$(getent passwd "$2" |cut -d':' -f6 2>/dev/null) host=$2 passphrase _passphrase pp key f fd_fifo res
	if [[ -z "${HOME}" ]] || ! do_init_conf keyserver; then
		echo -e "${RED}${BOLD}Unable to Initialize$([[ -z "${HOME}" ]] && echo ", ${host} is not a Valid Host" || echo " Config").${NOR}"
		return 1
	fi
	[[ -f host.conf ]] && . host.conf

	# Ask the passphrase for every key present. And send add command to keyserver.
	exec {__fd_user[0]}<&0 {__fd_user[1]}>&1
	for f in ${conf[KEYDIR]}/*.key; do
	    key=${f##*/} && pp=${key%.*} passphrase="" _passphrase=0
		if [[ "${key}" != "*" ]]; then
			do_keysrv_cmd "add" "${host}" "${pp}" "${timeout}" "${f}"
		else
			[[ "${key}" == "*" ]] && echo -e "${BOLD}${YEL}No Stored Passphrases for ${host}.${NOR}"
			return 1
		fi
	done

	# Wake-up System.
	[[ -n "${MAC}" && -n "${INTERFACE}" ]] && sudo /usr/sbin/etherwake -i "${INTERFACE}" -b "${MAC}"
}

# [END OF KEY SERVER & CLIENT FUNCTIONS]

# [START OF UDEV PROCESSING FUNCTIONS]

do_cryptdisksd_udev()
{
	local msg="${ACTION} " command=udev dir

	# Parse the udev command line and prepare the message to be put on the queue. Udev can only be run by root.
	dir="$(grep -ie "^CONFDIR=\/" /etc/systemd/${MYNAME}.conf)"
	CONFDIR="${dir##*=}"
	if [[ ${UID} -ne 0 || -z "${ACTION}" ]] || ! do_init_conf; then
		logger -p daemon.error "${MYNAME} udev failed to queue \"$@\""
		exit 1
	fi

	# Enter a loop to check if any of the arguments specified is a command, error exit if so, add parameter to message if ok.
	shift
	while [[ ! -z "$1" ]]; do
		do_parse_opt $@
		[[ $? -eq 0 ]] && msg+="$1 " || logger -p daemon.error "${MYNAME} cannot name crypt or dev \"$1\""
		shift
	done

	# Put the message (if any) on the queue.
	[[ "${msg}" == "${ACTION} " ]] && exit 1 || echo "${msg}" >${conf[FIFO]} 
}

# [END OF UDEV PROCESSING FUNCTIONS]

# [START OF INTERACTIVE CONTROL FUNCTIONS]

do_echo_use()
{
	[[ -z "${conf[RUNDIR]}" ]] && { do_init_conf keyserver || echo -e "${RED}${MYNAME}, Error Loading Configuration from ${CONFDIR}${NOR}"; }
	echo -e "${GREY}${BOLD}${MYNAME} (Encrypted Block Device Manager)${NOR}\n"
	case $1 in
	status)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tDisplays Status of Encrypted Block Devices"
		echo -e "\t\t\t\tCommand Has no Options or Arguments\n";;
	stop)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tStops the Encrypted Device Manager"
		echo -e "\t\t\t\tCommand Has no Options or Arguments\n";;
	reload)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tReloads the Configuration of the Encrypted Device Manager"
		echo -e "\t\t\t\tCommand Has no Options or Arguments\n";;
	add)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tAdd an Encrypted Block Device to the Manager\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hct ] { crypt | device } || { -p passphrase crypt device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-i${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
		echo -e "\t${BOLD}-p {passphrase}${NOR}\tUse {passphrase} for Crypt"
		echo -e "\t${BOLD}-t${NOR}\t\tEnable TRIM for Crypt\n\n"
		echo -e "The $1 Command Can Be Used it Two Ways.\nThe First ( ${BOLD}[ -i ] { crypt | device }${NOR} ) Will Add a Crypt or Device Which is Already on the Crypttab"
		echo -e "The Second ( ${BOLD}[ -i ] { -p passphrase crypt device }${NOR} ) Will Add a crypt (and Corresponding Backing Device) to the Crypttab\nThe Option '${BOLD}-p passphrase${NOR}' Must Be Specified in the Second Case\n"
		echo -e "The Options and Arguments Can Be Specified in any Order"
		echo -e "${BOLD}${UL}${MYNAME} $1 -p passphrase crypt device${NOR}\tand\t${BOLD}${UL}${MYNAME} $1 crypt -i\n${MYNAME} $1 crypt -i device -p passphrase${NOR}\tand\t${BOLD}${UL}${MYNAME} $1 -t device -p passphrase crypt -i${NOR}"
		echo -e "Are All Valid $1 Command Specifications\n"			
		echo -e "The ${MYNAME} Will Look for Block Devices in \"${BOLD}${conf[BLOCKDEVSDIRS]}${NOR}\"\n";;
	del)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tRemove an Encrypted Block Device from the Manager\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -htc ] { crypt | device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-i${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
		echo -e "\t${BOLD}-t${NOR}\t\tRemove the crypt (and Corresponding Backing Device) from the Crypttab\n\n"
		echo -e "The Options and Arguments Can Be Specified in any Order\n";;
	putkey)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tPut Key File to Boot Servers\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h -c -s (-a -l) -f -k HOST ] passphrase${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-i${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
		echo -e "\t${BOLD}-k${NOR}\t\tPut key only to local keyserver for HOST"
		echo -e "\t${BOLD}-c${NOR}\t\tPut key only to cache"
		echo -e "\t${BOLD}-f${NOR}\t\tPut key only to firmware"
		echo -e "\t${BOLD}-s${NOR}\t\tPut key only to servers"
		echo -e "\t${BOLD}-a${NOR}\t\tPut key to servers cache"
		echo -e "\t${BOLD}-l${NOR}\t\tUse local configured timeout values instead of keyserver values\n"
		echo -e "The option -i is a confirmation flag, when no other options are specified\nit disables confirmation, enables confirmation otherwise"
		echo -e "The options -s -f -c can be combined to put key to these places only\With -c an optional timeout can be specified, if not configured values are used"
		echo -e "With -s a server can be specified and this may occur more than once\nIt may only occur once without server to remove from all servers"
		echo -e "Multiple servers can be specified with , as separator"
		echo -e "When -s is used, -a will also add passphrase to boot servers cache\nOptionally a timeout for the passphrase can be specified"	
		echo -e "When -a is used without a timeout value, by default the keyserver timeout values are used\nWith -l the locally configured timeout values will be used"
		echo -e "${BOLD}${UL}(\"-s\" and \"-s server1 -s server2,server3\" are valid but \"-s -s server1\" or \"-s server1 -s\" are not.)${NOR}"
		echo -e "${BOLD}${MYNAME} putkey { passphrase }${NOR}\t\t- without any option puts key to everywhere asking for confirmation each step"
		echo -e "${BOLD}${MYNAME} putkey -i { passphrase }${NOR}\t\t- puts key to everywhere not asking for confirmation"
		echo -e "${BOLD}${MYNAME} putkey -i -c -f { passphrase }${NOR}\t- puts key to specified locations asking for confirmation"
		echo -e "${BOLD}${MYNAME} putkey -c -f { passphrase }${NOR}\t- puts key to specified locations not asking for confirmation";;
	rmkey)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tRemove Key File from Firmware and/or Boot Servers\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h -c -s (-a) -f -k ] passphrase${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-i${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
		echo -e "\t${BOLD}-k${NOR}\t\tRemove key only from local keyserver for HOST"
		echo -e "\t${BOLD}-c${NOR}\t\tRemove key only from cache"
		echo -e "\t${BOLD}-f${NOR}\t\tRemove key only from firmware"
		echo -e "\t${BOLD}-s${NOR}\t\tRemove key only from servers"
		echo -e "\t${BOLD}-a${NOR}\t\tRemove key from servers cache\n"
		echo -e "The option -i is a confirmation flag, when no other options are specified\nit disables confirmation, enables confirmation otherwise"
		echo -e "The options -s -f -c can be combined to remove key from these places only"
		echo -e "With -s a server can be specified and this may occur more than once\nIt may only occur once without server to remove from all servers"
		echo -e "Multiple servers can be specified with , as separator"
		echo -e "When -s is used, -a can be used to also remove passphrase from boot servers cache"
		echo -e "${BOLD}${UL}(\"-s\" and \"-s server1 -s server2,server3\" are valid but \"-s -s server1\" or \"-s server1 -s\" are not.)${NOR}"
		echo -e "${BOLD}${MYNAME} rmkey { passphrase }${NOR}\t\t- without any option removes key from everywhere asking for confirmation each step"
		echo -e "${BOLD}${MYNAME} rmkey -i { passphrase }${NOR}\t\t- removes key from everywhere not asking for confirmation"
		echo -e "${BOLD}${MYNAME} rmkey -i -c -f { passphrase }${NOR}\t- removes key from specified locations asking for confirmation"
		echo -e "${BOLD}${MYNAME} rmkey -c -f { passphrase }${NOR}\t- removes key from specified locations not asking for confirmation";;
	smart)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tShow S.M.A.R.T. Information for Backing Device\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hax ] {crypt | device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-a|-x${NOR}\t\tShow all S.M.A.R.T. information (Only Atrributes Otherwise)"
		echo -e "\t${BOLD}-t${NOR}\t\tRun S.M.A.R.T. Long Self Test on Device\n";;
	erase)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tSecure Erase Device\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h ] {crypt | device }${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text";;
	keyserver)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tSecure Erase Device\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h | -f | status HOST ]${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-f${NOR}\t\tRun in Foreground (Debug) Mode. Can not be Started by root"
		echo -e "\t${BOLD}status HOST${NOR}\tDisplay Status of Keyserver for HOST";;
	bootsan)
		echo -e "${BOLD}${MYNAME} $1${NOR}\t\tAdd Keys to Keyserver and Start Host\n"
		echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h | -t timeout } HOST${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e " \t${BOLD}-t${NOR}\t\tSpecify Timeout Overriding Config\n";;
	*)
		echo -e " Usage:\n\t${BOLD}${MYNAME} { [ -hdf ] ${UL}COMMAND ...${NOR} }\n"
		echo -e "\tEncrypted Block Devices Manager, Command Line Requires at Least one Option or Command"
		echo -e "\tMultiple Commands May Be Specified in Order, Commands Can Have Multiple Options and Arguments"
		echo -e "\tAll Commands Options and Arguments Are cAsE iNSensItiVe, except for ${UL}Device Names${NOR}\n"
		echo -e "\tUse ${UL}${BOLD}${MYNAME} command -h${NOR} To Display Help for That Command${NOR}\n\n"
		echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
		echo -e "\t${BOLD}-d${NOR}\t\tSet Configuration Directory (${BOLD}${UL}Default: /etc/${MYNAME:0:-1}.d${NOR})"
		echo -e "\t${BOLD}-f${NOR}\t\tRun in Foreground (Debug) Mode. Can Only be Started by root"
		echo -e "\n\n Commands:\n\t${BOLD}status${NOR}\t\tDisplays Status of Encrypted Block Device Manager"
		echo -e "\t${BOLD}smart${NOR}\t\tDisplay S.M.A.R.T. Status of Encrypted Block Device"
		echo -e "\t${BOLD}erase${NOR}\t\tSecure Erase Encrypted Block Device"
		echo -e "\t${BOLD}stop${NOR}\t\tStop the Encrypted Device Manager"
		echo -e "\t${BOLD}reload${NOR}\t\tReload the Configuration of the Encrypted Device Manager"
		echo -e "\t${BOLD}add${NOR}\t\tAdd Encrypted Block Device to Manager"
		echo -e "\t${BOLD}del${NOR}\t\tDelete Encrypted Block Device from Manager"
		echo -e "\t${BOLD}putkey${NOR}\t\tPut Keyfile (Passphrase) to Boot Servers"
		echo -e "\t${BOLD}rmkey${NOR}\t\tRemove Keyfile (Passphrase) from Firmware"
		echo -e "\t${BOLD}keyserver${NOR}\tKeyserver Start or Status"
		echo -e "\t${BOLD}bootsan${NOR}\t\tAdd Keys to Keyserver and Start Host\n";;
	esac
	exit 127
}

do_parse_opt()
{
	# Parse command line options (-h -d -f). Function is run from main cli to parse as first options given.
	# Function can also run from the parse cmds function, it that case only -d option can be valid.
	local opt; OPTIND=1; getopts :fFd:D:hHiIlLcCaAxXk:K:sSp:P:tT opt
	opt="${opt,,}"
	case ${opt} in
	h|:) # if -h is specified as a command line option echo usage for the command running if run from parse cmds.
		do_echo_use "${command}";;
	a) # Option for smart -x or add to bootserver cache for putkey/rmkey
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(smart|putkey|rmkey)$ ]] && do_echo_use "${command}"
		if [[ "${command,,}" == "smart" ]]; then
			smartall=1
		else
			[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
			[[ ${_cache} == "1" ]] && _cache=0
			[[ -n "${add}" ]] && do_echo_use "${command}"
			add=-1 _add=1
		fi
		return 1;;
	k) # Option to put/del key from/to local keyserver..
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(putkey|rmkey)$ || -n "${ks}" || -z "${OPTARG}" ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		ks="${OPTARG}"
		return $((OPTIND-1));;
	l) # option for using local timeout values instead of keyserver values when adding keys to keyserver cache.
		[[ ${cmd} -eq 0 || ! "${command,,}" == "putkey" || ${loc} -ne 0 ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		loc=1
		return 1;;
	x) # Option for smart -x
		[[ ${cmd} -eq 0 || ! "${command,,}" == "smart" ]] && do_echo_use "${command}"
		smartall=1
		return 1;;
	i) # Option to ask for confirmation for non critical actions.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(add|del|putkey|rmkey)$ ]] && do_echo_use "${command}"
		[[ ${confirm} -eq 1 ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		confirm=1
		return 1;;
	c) # Option to add/remove key from cache.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(putkey|rmkey)$ || ${key} -eq 1 ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		cache=-1 _cache=1
		return 1;;
	p) # Option to specify a passphrase name for the new crypt to be added to the crypttab.
		[[ ${cmd} -eq 0 || ! "${command,,}" == "add" || ${srv} == "1" || ${_srv} -eq 1 ]] && do_echo_use "${command}"
		crypttab=1
		pp="${OPTARG}"
		return $((OPTIND-1));;
	s) # Option to remove key from boot servers. We keep _srv to track how option is used
	   # 1 for first time option is encountered, 2 for consecutive. May only contain server names when it occurs more than once.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(putkey|rmkey)$ || ${srv} == "1" || ${_srv} -eq 1 ]] && do_echo_use "${command}"
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		[[ -z "${srv}" ]] && _srv=1 srv=1 || _srv=2
		return 1;;
	t) # Option trim enable foor add, remove crypt from crypttap for del command. Or Run smart self test.
		[[ ${cmd} -eq 0 || ! "${command,,}" =~ ^(add|del|smart|bootsan)$ ]] && do_echo_use "${command}"
		[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
		[[ ${_add} == "1" ]] && _add=0
		[[ ${_cache} == "1" ]] && _cache=0
		if [[ "${command}" == "bootsan" ]]; then
			[[ -n "${timeout}" ]] && do_echo_use "${command}"
			timeout=-1
		elif [[ "${command}" == "add" ]]; then
			[[ ${add_trim} -eq 1 ]] && do_echo_use "${command}"
			add_trim=1
		elif [[ "${command}" == "del" ]]; then
			[[  ${crypttab} -eq 1 ]] && do_echo_use "${command}"
			crypttab=1
		elif [[ "${command}" == "smart" ]]; then
			[[  ${smarttest} -eq 1 ]] && do_echo_use "${command}"
			smarttest=1
		fi
		return 1;;
	d) # Set configuration directory. If no dir specified echo usage. Option is only valid for global, not for command.
		[[ ! -d ${OPTARG} ]] && echo "Configuration Directory ${OPTARG} Does not Exist"
		[[ ${cmd} -eq 1 || ! -d ${OPTARG} || ${_conf} -ne 0 ]] && do_echo_use "${command}"
		_conf=1
		CONFDIR=${OPTARG}
		# Shift the parameters and check if more arguments specified, continue with processing options if so.
		[[ $# -ge ${OPTIND} ]] && return $((OPTIND-1))
		shift $((OPTIND-1));;
	f) # Flag to run in foreground mode. Option to remove key from firmware.
		[[ ( ${cmd} -eq 1 && ( ! "${command,,}" =~ ^(putkey|rmkey)$ || ${fw} -eq 1 ) ) || ${FOREGROUND} -eq 1 ]] && do_echo_use "${command}"
		if [[ "${command}" =~ ^(putkey|rmkey)$ ]]; then
			[[ ${srv} == "1" && ${_srv} -eq 1 ]] && _srv=0
			[[ ${_add} == "1" ]] && _add=0
			[[ ${_cache} == "1" ]] && _cache=0
			fw=1
			return 1
		fi
		FOREGROUND=1
		# If there are more options continue parsing. -f can only be followed by -d.
		shift
		[[ ! -z "$1" ]] && return 1;;
	?) # If run from parse cmds function, we need to check if the option specified matches a known command.
	   # If that is the case we have reached the end of the current command and can start processing the next.
		if [[ ${cmd} -eq 1 && ! -z "$1" ]] && ! do_parse_cmd check $1; then
			next_cmd=1
		elif [[ ${cmd} -eq 1 && ! -z "$1" ]]; then
			# We may get here if put/rmkey command contains -s server options. Check here if it was specified without server before.
			# If this is the last word in the command return 0 because we are done and it is the keynamen, not a server.
			[[ ( ${_srv} -eq 2 && ${srv} == 1 ) || ( ${timeout} == "-1"  && ! ${!OPTIND} =~ ^[0-9]+$ ) ]] && do_echo_use "${command}"
			if [[ ${timeout} == "-1" ]]; then
				timeout=$((${!OPTIND}*60))
				return 1
			fi
			# -s -c and -a have optional values, so check for next command first.
			[[ -z "$2" ]] || ! do_parse_cmd check $2 ]] && return 0
			if [[ ${_srv} -ge 1 ]]; then
				[[ ${srv} == "1" ]] && srv=""
				srv+="${!OPTIND}," _srv=0
				return 1
			elif [[ ${_cache} -eq 1 || ${_add} -eq 1 ]]; then
				[[ ! ${!OPTIND} =~ ^[0-9]+$ ]] && do_echo_use "${command}"
				[[ "${_add}" -eq 1 ]] && add=$((${!OPTIND}*60)) _add=0 || cache=$((${!OPTIND}*60)) _cache=0
				return 1
			fi
		elif [[ ${cmd} -eq 1 ]]; then
			# If there are no more arguments set to process next command, which will be none.
			next_cmd=1
		fi;;
	esac

	# Check rmkey server option for validity. If -s server was specified before and now only -s this is an error and we catch it here.
	[[ ${_srv} -eq 2 ]] && do_echo_use "${command}"
	[[ ${_srv} -eq 1 ]] && _srv=0

	# If foreground mode was requested execute. Echo command usage if specified in wrong place.
	if [[ ${FOREGROUND} -eq 1 ]]; then
		# If -f is not first option specified, it must be last (after -d) and no more options can be present.
		[[ ${nr} -gt 1 && ! -z "$1" ]] && do_echo_use "${command}"
		# Start in debug/foreground mode.
		if [[ ${UID} -ne 0 && $# -le 1 ]]; then
			echo "${MYNAME} foreground can only be started as root"
			exit 1
		fi
		do_systemd_daemon_start
		exit $?
	fi

	# Return 1 if next command is found, 0 otherwise.
	[[ ${next_cmd} -eq 1 ]] && return 1
	return 0
}

do_parse_cmd()
{
	# Parse the commands specified on the command line, one by one. If called with check, then return 1 on match.
	# This is to let the parse opt function know a match for a new command has been found.
	local command="${1,,}" check msg="$1 " s timeout=""
	if [[ "${command}" == "check" ]]; then 
		shift
		command="${1,,}" check=1;
	fi
	case ${command} in
	udev)
		[[ ${check} -eq 1 ]] && return 1
		do_cmd_parseopt $@
		do_init_conf || return 1
		do_cryptdisksd_udev $@
		return $#;;
	stop)
		[[ ${check} -eq 1 ]] && return 1
		do_cmd_parseopt $@
		do_init_conf || return 1
		/bin/kill -SIGTERM $(cat ${conf[PIDFILE]})
		return $#;;
	reload)
		[[ ${check} -eq 1 ]] && return 1
		do_cmd_parseopt $@
		do_init_conf || return 1
		/bin/kill -SIGHUP $(cat ${conf[PIDFILE]})
		return 1;;
	status|shell|add|del|putkey|rmkey|smart|erase)
		[[ ${check} -eq 1 ]] && return 1
		do_cryptdisksd_cmd $@
		return $?;;
	bootsan)
		[[ ${check} -eq 1 ]] && return 1
		do_cmd_parseopt $@
		s=$?
		[[ $(wc -w <<<"${msg}") -ne 2 || "${timeout}" == "-1" ]] && do_echo_use "${command}"
		do_init_conf || return ${s}
		[[ -z "${timeout}" ]] && timeout=-1
		do_bootsan ${msg}
		return ${s};;
	*)
		[[ ${check} -ne 1 ]] && do_echo_use "${command}"
		return 0;;
	esac
	return 0
}

do_cmd_parseopt()
{
	# If there are more arguments to process, check for command options or or for a new command to be processed.
	local next_cmd=0 res s=0 _srv=0
	shift
	while [[ ${next_cmd} -eq 0 ]]; do
		do_parse_opt $@
		res=$? 
		if [[ ${res} -eq 0 ]]; then
			msg+="$1 "
			shift
			s=$((s+1))
		else
			shift ${res}
			s=$((s+res))
		fi
	done
	return ${s}
}

trap_term_cryptdisksd_cmd()
{
	trap 'echo "${RED}${MYNAME} unclean finish${NOR}"; exit 1;' SIGINT SIGTERM

	# Kill socat coproc if still active and remove the socket if still present. Restore stdin to the tty.
	if [[ ! -z "${pid_socat}" && "$(cat /proc/${pid_socat}/comm 2>/dev/null)" == "socat" ]]; then
		kill -SIGTERM ${pid_socat}
		[[ ${conf[LOGLEVEL]} -gt 2 ]] && echo -e "\rKilled ${pid_socat}"
	fi
	if [[ -n "${sock}" && -e ${conf[CRYPTDISKSDDIR]}/${sock} ]]; then
		rm -f ${conf[CRYPTDISKSDDIR]}/${sock} && echo -e "\rRemoved ${conf[CRYPTDISKSDDIR]}/${sock}\r\n"
	fi
	[[ -e ${CONFDIR}/${c}.$$.res ]] && rm -f ${CONFDIR}/${c}.$$.res
	[[ -n "${stdin}" ]] && exec 0<&${stdin}-
	stty sane

	echo -e "${NOR}\r"
	exit 1
}

do_cryptdisksd_cmd()
{
	trap 'trap_term_cryptdisksd_cmd' SIGINT SIGTERM

	local crypttab=0 confirm=0 smartall=0 smarttest=0 cache="" srv="" add="" fw=0 loc=0 trim=0 ks="" stty_opt="-echo" msg="$1 " s sock pid_socat stdin passphrase _passphrase=x
	[[ -n "${ks}" ]] && HOME=$(getent passwd "${ks}" |cut -d':' -f6 2>/dev/null)

	# Parse the options to the command and store the nr. of paramters to shift for next command n s. Check provided paramters and innitialize config.
	do_cmd_parseopt $@
	s=$?
	[[ -z "${srv}" ]] && srv=0; [[ -z "${cache}" ]] && cache=-2; [[ -z "${add}" ]] && add=-3; [[ ${add} -eq -1 && ${loc} -eq 1 ]] && add=-2; pp="$(do_eval_pp ${msg#* })"
	[[ "${command,,}" == "rmkey" && ( $(wc -w <<<"${msg}") -ne 2 || ( ${add} == "-1" && "${srv}" == "0" && -z "${ks}" ) || ${cache} -ge 0 ) ]] && do_echo_use "${command}"
	[[ "${command,,}" == "putkey" && ( $(wc -w <<<"${msg}") -ne 2 || ( ${loc} -eq 1 && ( ${add} -eq -3 || ${add} -ge 0 ) ) || ( ${add} -ne -3 && "${srv}" == "0" && -z "${ks}" ) ) ]] && do_echo_use "${command}"
	if [[ -n "${ks}" && -z "${HOME}" ]] || ! do_init_conf keyserver; then
		echo -e "${BOLD}${RED}Unable to Initialize$([[ -n "${ks}" && -z "${HOME}" ]] && echo ", ${host} is not a Valid Host" || echo " Config").${NOR}"
		return ${s}
	fi

	# Execute local keyserver commands first.
	if [[ -n "${ks}" ]]; then 
		do_keysrv_cmd "$([[ "${command,,}" == "rmkey" ]] && echo del || echo put)" "${ks}" "${pp}" "${passphrase}"
		[[ "${command,,}" == "rmkey" && "${add}" == "-1" ]] && do_keysrv_cmd "rem" "${ks}" "${pp}"
		[[ "${command,,}" == "putkey" && "${add}" != "-3" ]] && do_keysrv_cmd "add" "${ks}" "${pp}" "${add}" "${passphrase}"
		[[ "${srv}" == "0" && ${fw} -eq 0 && ${cache} -eq -2 ]] && return ${s}
	fi

	# Reload config, necessary when executing put to local keyserver.
	sock=${conf[CRYPTDISKSDDIR]}/${MYNAME}-${BASHPID}.sock
	if [[ ! "$(NOTIFY_SOCKET= systemctl is-active ${MYNAME:0:-1}.service 2>&1)" =~ activating|active ]]; then
		echo "${MYNAME} not Running"
		exit 1
	fi
	
	# Start socat in background and attach stdin, listen on a socket in RUNDIR. 
	# The daemon will spawn a worker which will connect and start interactive session.
	exec {stdin}<&0
	socat -t${conf[QUEUE_TIMEOUT]} - UNIX-LISTEN:${sock},unlink-early,unlink-close,group=${conf[CRYPTDISKSD_GROUP]},mode=600 0<&${stdin}- &
	pid_socat=$!

	case ${command,,} in
	add)
		[[ ${crypttab} -eq 1 && $(wc -w <<<"${msg}") -ne 3 ]] && do_echo_use "${command}"
		[[ ${crypttab} -eq 1 && $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		msg+="${pp} ${trim} ${confirm} ${crypttab}";;
	del)
		[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		msg+="${confirm} ${crypttab}";;
	status|shell)
		[[ $(wc -w <<<"${msg}") -ne 1 ]] && do_echo_use "${command}";;
	smart)
		[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		msg+="${smartall} ${smarttest}";;
	rmkey|putkey)
		msg+="${confirm} ${add} ${cache} ${fw} ${srv}";;
	*)
		[[ $(wc -w <<<"${msg}") -ne 2 ]] && do_echo_use "${command}"
		msg+="${confirm}";;
	esac

	# Notify the daemon to connect to the socket and wait until it's finished. Then restore stdin and exit.
	[[ "${command,,}" == "smart" ]] && stty_opt+=" isig"
	[[ "${command,,}" == "shell" ]] && stty_opt+=" raw -isig"
	[[ ! ${command,,} =~ ^(smart|shell)$ ]] && stty_opt+=" raw isig"
	stty ${stty_opt}
	[[ ${conf[LOGLEVEL]} -gt 2 ]] && echo -e "Requesting \"$@\" \"${msg}\" from ${MYNAME} - ${conf[FIFO]}\r"
	echo "control ${BASHPID},${pid_socat} ${msg}" >${conf[FIFO]}
	wait ${pid_socat}

	# Restore stdin, remove socket and exit.
	stty sane
	[[ -e ${sock} ]] && rm -f ${sock}

	[[ ${conf[LOGLEVEL]} -gt 3 ]] && echo "Done requesting \"$@\" from ${MYNAME}"
	return ${s}
}

do_keysrv_cmd()
{
	local cmd="${1,,}" host="$2" pp="$(do_eval_pp "$3")" timeout="$4" key="$5" fd_fifo res

	## For add or put we need a passphrase first.
	if [[ ${cmd} =~ ^(put|add)$ && ${_passphrase} != "1" ]]; then
		until ( [[ "${_passphrase}" == "0" ]] && openssl aes-256-cbc -d -salt -pbkdf2 -in ${f} -out /dev/null -k "${passphrase}" ) || [[ "${passphrase}" == "${_passphrase}" ]]; do
			! do_ask_passphrase "${passphrase}Enter ${pp} Passphrase: " {__fd_user[0]}<&0 {__fd_user[1]}>&1 && echo -e "${BOLD}${RED}TIMEOUT!${NOR}" && return
			[[ "${_passphrase}" == "0" ]] && passphrase="Incorrect Passphrase. " && continue
			_passphrase="${passphrase}"
			! do_ask_passphrase "Confirm ${pp} Passphrase: " {__fd_user[0]}<&0 {__fd_user[1]}>&1 && echo -e "${BOLD}${RED}TIMEOUT!${NOR}" && return
			[[ "${passphrase}" != "${_passphrase}" ]] && passphrase="Passhrases do not Match. "
		done
	fi

	# create fifo for anser and send requet.
	if ! mkfifo ${CONFDIR}/${cmd}.$$.res >/dev/null 2>&1 || ! chgrp ${conf[KEYSRV_GROUP]} ${CONFDIR}/${cmd}.$$.res || ! chmod 620 ${CONFDIR}/${cmd}.$$.res; then
		echo -e "${BOLD}${RED}Unable to Create FIFO.${NOR}"
		return
	fi
	[[ ${cmd} =~ ^(put|add)$ && "${passphrase}" == "" ]] && echo -e "${BOLD}${YEL}Is Your Skull as Empty as Your ${pp} Passphrase?${NOR}"

	# Get result.
	exec {fd_fifo}<>${CONFDIR}/${cmd}.$$.res
	echo "$$" "${cmd}" "${pp}" "${timeout}" >${conf[KEYSRV_FIFO]}
	[[ ${cmd} =~ ^(put|add)$ ]] && echo "${passphrase}" >${conf[KEYSRV_FIFO]}
	until ! read -t${conf[KEYSRV_TIMEOUT]} -ru${fd_fifo} res || [[ ${res} == . ]]; do
		if [[ "${cmd}" == "status" ]]; then
			echo -e "${res}"
		elif [[ "${cmd}" == "put" ]]; then
			[[ "${res,,}" == "same" ]] && echo -e "${BOLD}${YEL}${pp} Passphrase Equal to Stored Passphrase on Keyserver.${NOR}"
			[[ "${res,,}" == "nok" ]]  && echo -e "${BOLD}${RED}Failed to Put ${pp} Passphrase to Keyserver.${NOR}"
			[[ "${res,,}" == "ok" ]]   && echo -e "${BOLD}${GRN}Put ${pp} Passphrase to Keyserver Succeeded.${NOR}"
		elif [[ "${cmd}" == "del" ]]; then
			[[ "${res,,}" == "same" ]] && echo -e "${BOLD}${YEL}${pp} Passphrase not Stored on Keyserver.${NOR}"
			[[ "${res,,}" == "nok" ]]  && echo -e "${BOLD}${RED}Failed to Del ${pp} Passphrase from Keyserver.${NOR}"
			[[ "${res,,}" == "ok" ]]   && echo -e "${BOLD}${GRN}Del ${pp} Passphrase from Keyserver Succeeded.${NOR}"
		elif [[ "${cmd}" == "add" ]]; then
			[[ "${res,,}" == "same" ]] && echo -e "${BOLD}${YEL}${pp} Passphrase Already Cached on Keyserver.${NOR}"
			[[ "${res,,}" == "nok" ]]  && echo -e "${BOLD}${RED}Failed to Cache ${pp} Passphrase on Keyserver.${NOR}"
			[[ "${res,,}" == "ok" ]]   && echo -e "${BOLD}${GRN}Cache ${pp} Passphrase on Keyserver Succeeded.${NOR}"
		elif [[ "${cmd}" == "rem" ]]; then
			[[ "${res,,}" == "same" ]] && echo -e "${BOLD}${YEL}${pp} Passphrase not Cached on Keyserver.${NOR}"
			[[ "${res,,}" == "nok" ]]  && echo -e "${BOLD}${RED}Failed to Remove ${pp} Passphrase from Keyserver Cache.${NOR}"
			[[ "${res,,}" == "ok" ]]   && echo -e "${BOLD}${GRN}Remove ${pp} Passphrase from Keyserver Cache Succeeded.${NOR}"
		fi
		[[ "${cmd}" != "status" ]] && break
	done
	rm -f ${CONFDIR}/${cmd}.$$.res
}

# [END OF INTERACTIVE CONTROL FUNCTIONS]

# [BEGIN OF EXECUTION FUNCTIONS]

do_systemd_daemon_start()
{
	# Check if we are started from systemd (PID 1).
	[[ ( ! "${UID}" -eq 0 || ! ${PPID} -eq 1 ) && ${FOREGROUND} -eq 0 ]] && do_echo_use
	local myname="daemon (${BASHPID}):" hostname="$(hostname)" pid_daemon=${BASHPID} starting=1 start_status=0 time_start=$(do_timer)
	local systemdconf="" crypttab="" pid_logwriter fd_logwriter fd_journal

	# Close stdin, fd3 to stdout (systemd journald) for worker processes. Redirect stdout and stderr to /dev/null.
	# If we are running in foreground mode evrything goes to stdout of the user's terminal. And we wish him or her good luck with that.
	[[ ${FOREGROUND} -ne 1 ]] && exec 0>&- {fd_journal}>&1- 1>/dev/null 2>&1
	[[ ${FOREGROUND} -eq 1 ]] && exec {fd_logwriter}>&1 {fd_journal}>&${fd_logwriter} 2>&1

	# Load config and start new key session and link the user key ring to the session key ring. On boot keys will be cached in user key ring. 
	set -mo pipefail
	[[ ${FOREGROUND} -eq 1 ]] && echo -n "Session Key: "
	keyctl new_session
	keyctl link @u @s
	if ! do_init_conf; then
		systemd-notify --pid=$$ --stopping --status="${MYNAME}: Cannot Initialize Config" 
		exit 0
	fi
	[[ ${FOREGROUND} -eq 1 ]] && echo "loglevel=${conf[LOGLEVEL]}"

	# Start the logwriter.
	[[ ! -d ${conf[LOGDIR]} ]] && mkdir -p ${conf[LOGDIR]}
	[[ ! -e ${conf[LOGFILE]} ]] && touch ${conf[LOGFILE]}
	chgrp ${conf[CRYPTDISKSD_GROUP]} ${conf[LOGDIR]} ${conf[LOGFILE]} ${conf[CRYPTDISKSDDIR]} ${conf[FIFO]}
	chmod 750 ${conf[LOGDIR]}
	chmod 640 ${conf[LOGFILE]}
	chmod ${conf[CRYPTDISKSDDIR_MODE]} ${conf[CRYPTDISKSDDIR]}
	chmod ${conf[FIFO_MODE]} ${conf[FIFO]}
	[[ ${FOREGROUND} -eq 0 ]] && do_daemon_start_logwriter
	do_log info "${myname} initializing"

	# Here we go, we are started from systemd. We will first process to queue entirely and notify systemd if we're done.
	# A cleanup will be run every minute. There we will detect if configuration has changed and remove timed out workers and mounts.
	[[ ${conf[DEBUGSHELL]} -eq 1 ]] && set -a
	echo ${pid_daemon} >${conf[PIDFILE]}

	# Check if the queue exists first, exit with error if it isn't. It should be there, or something is wrong with socket.
	if [[ ! -p ${conf[FIFO]} ]]; then
		do_log error "${myname} queue not found" 
		systemd-notify --pid=$$ --stopping --status="${MYNAME}: Queue not Found, Restart ${MYNAME}.socket" 
		exit 0
	fi

	# Parse and load the configuration, exit if either fails.
	if ! do_daemon_check_conf; then 
		do_log error "${myname} failed to load config" 
		systemd-notify --pid=$$ --stopping --status="${MYNAME}: Failed to Load Configuration"
		exit 0
	fi

	# Check if there is a crypttab, log message if there isn't since everything we do is based on it.
	if [[ ! -f ${conf[CRYPTTAB]} ]]; then
		echo -e "#Crypt\t\t\t#Device\t\t\t\t#Passphrase\t\t#TRIM" >${conf[CRYPTTAB]}
		do_log warning "${myname} crypttab not found" 
		systemd-notify --pid=$$ --status="${MYNAME}: Crypttab (${conf[CRYPTTAB]}) not Found"
		start_status=2
	fi

	systemd_daemon
}

do_systemd_keysrv_start()
{
	local myname="${MYNAME}-keyserver" time_start=$(do_timer) host=${USER} fd_logwriter pid_logwriter fd_journal
	[[ ${UID} -eq 0 ]] && echo "${myname} can not  be started as root" && exit 1
	
	# Load the configuration.
	if ! do_init_conf keyserver; then
		systemd-noify --pid=$$ --stopping --status="${myname}: Cannot Initialize Config" 
		exit 0
	elif [[ ! -p ${conf[KEYSRV_FIFO]} ]]; then
		systemd-notify --pid=$$ --stopping --status="${myname}: Queue not Found, Restart ${myname}.socket" 
		exit 0
	fi
	( [[ ! -d ${CONFDIR} ]] && ! mkdir ${CONFDIR} ) || ( [[ ! -d ${conf[KEYDIR]} ]] && ! mkdir ${conf[KEYDIR]} ) && exit 1
	chmod 770 ${CONFDIR} 
	chmod 750 ${conf[KEYDIR]}

	# Start Log Writer
	[[ ${FOREGROUND} -ne 1 ]] && exec 0>&- {fd_journal}>&1- 1>/dev/null 2>&1
	[[ ${FOREGROUND} -eq 1 ]] && exec {fd_logwriter}>&1 {fd_journal}>&${fd_logwriter} 2>&1
	[[ ! -d ${conf[LOGDIR]} ]] && mkdir -p ${conf[LOGDIR]}
	[[ ! -e ${conf[LOGFILE]} ]] && touch ${conf[LOGFILE]}
	[[ ${FOREGROUND} -ne 1 ]] && case ${conf[LOGLEVEL]} in
		0|1|2)  exec {fd_logwriter}> >(logwriter);;
		3|4)    exec {fd_logwriter}> >(logwriter) 1>&${fd_logwriter} 2>&1;;
	esac
	pid_logwriter=$!

	cd ${CONFDIR}
	keyctl new_session >/dev/null 2>&1
	do_systemd_keysrv
}

do_cryptdisksd_cli()
{
	local nr=$# cmd=0 _conf=0 res fd_logwriter myname=${MYNAME}
	exec {fd_logwriter}>&1
	# Enter a loop to evaluate all command line options and commands specified.
	while true; do
		# Parse options, the return code will be the nr of parameters to shift or 0 if all options parsed.
		# Continue with processing commands fase if all options parsed.
		if [[ ${cmd} -eq 0 ]]; then 
			do_parse_opt $@
			res=$?
			shift ${res}
			[[ ${res} -ne 0 ]] && continue
		fi
		# Command line options are parsed, evaluate and execute commands specified. Return code will be nr of arguments to shift.
		# If after shifting there are no more commands to process we can exit.
		cmd=1
		do_parse_cmd $@
		res=$?
		shift ${res}
		[[ -z "$1" ]] && return 0
	done
}

MYNAME="$(basename $0)" FOREGROUND=0 PATH=/bin:/sbin
[[ ! -z "${LC_NUMERIC}" ]] && unset LC_NUMERIC

# Check if we're started interactively (options must be specified) or from systemd (run without any options from PID 1).
if [[ $# -eq 0 ]]; then
	# No command line options specified. check if we're started from systemd, start daemon if so.
	do_systemd_daemon_start
	exit 1
elif [[ "$1" == "keyserver" && $(($#-2)) -le 1 ]]; then
	[[ ( $# -ge 2 && ! "$2" =~ ^(-f|-h|status)$ ) || $# -gt 3 || "$2" == "-h" || ( "$2" == "status" && -z "$3" ) ]] && do_echo_use keyserver
	if [[ "$2" == "status" ]]; then
		HOME=$(getent passwd "$3" |cut -d':' -f6 2>/dev/null)
		if [[ -z "${HOME}" ]] || ! do_init_conf keyserver; then
			echo -e "${RED}${BOLD}Unable to Initialize$([[ -z "${HOME}" ]] && echo ", ${host} is not a Valid Host" || echo " Config").${NOR}"
		else
			do_keysrv_cmd "status" "$3"
		fi
		exit
	fi
	[[ "$2" == "-f" ]] && FOREGROUND=1
	do_systemd_keysrv_start
elif [[ "$(basename ${SHELL})" == "${MYNAME}" ]]; then
	[[ "$(cat /proc/${PPID}/comm)" != "sshd" ]] && exit 1
	exec {in}>&0- {out}>&1- 2>/dev/null
	a=($2);	cmd="${a[0],,}" pp="$(do_eval_pp "${a[1]}")" timeout="${a[2]}"
	do_sanboot
	rm -f ${CONFDIR}/${cmd}.$$.res
	exit $?
else
	# Command line options present, run in interactive mode.
	do_cryptdisksd_cli $@
	# Exit if there are no more commands to execute.
	exit $?
fi

# [END OF EXECUTION FUNCTIONS]

# We should never get here, error exit if we do.
echo "${MYNAME} Reached End of the Line, Bye Bye"
exit 1
