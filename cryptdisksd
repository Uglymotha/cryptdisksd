#!/bin/bash

# Function Definitions. All functions for serialized commands shall have their nemae prefixed by do_ all others shall not.

do_init_conf()
{
	# Initialize System Variables. Default config in /etc/cryptdisks.d/cryptdisksd.conf. Systemd env CONF(DIR) will override.
	[[ -z "${CONFDIR}" ]] && CONFDIR="/etc/${MYNAME:0:-1}.d"
	[[ ! -d "${CONFDIR}" ]] && return 1
	[[ -z "${CONF}" ]] && CONF="${CONFDIR}/${MYNAME}.conf"
	unset conf
	declare -gA conf
	if [[ -s ${CONF} ]]; then
		local __var __val
		while IFS="=" read -r __var __val; do
			[[ ! -z "${__val}" ]] && conf[${__var^^}]="${__val}"
	   	done <<<"$(cat ${CONF} |grep -ve "^\s*#")"
	fi
	[[ -z "${conf[LOGLEVEL]}" ]] && conf[LOGLEVEL]=0
	[[ -z "${conf[DEBUGSHELL]}" ]] && conf[DEBUGSHELL]=0
	[[ -z "${conf[RUNDIR]}" ]] && conf[RUNDIR]="/run"
	[[ -z "${conf[LOGDIR]}" ]] && conf[LOGDIR]="/var/log/${MYNAME}"
	[[ -z "${conf[LOGFILE]}" ]] && conf[LOGFILE]="/var/log/${MYNAME}.log"
	[[ -z "${conf[CRYPTDISKSDDIR]}" ]] && conf[CRYPTDISKSDDIR]=${conf[RUNDIR]}/${MYNAME}
	[[ -z "${conf[PIDFILE]}" ]] && conf[PIDFILE]="${conf[CRYPTDISKSDDIR]}/${MYNAME}.pid"
	[[ -z "${conf[CRYPTDISKSD_GROUP]}" ]] && conf[CRYPTDISKSD_GROUP]="disk"
	[[ -z "${conf[CRYPTDISKSDDIR_MODE]}" ]] && conf[CRYPTDISKSDDIR_MODE]=700
	[[ -z "${conf[FIFO]}" ]] && conf[FIFO]="${conf[CRYPTDISKSDDIR]}/${MYNAME}.queue"
	[[ -z "${conf[FIFO_MODE]}" ]] && conf[FIFO_MODE]=600
	[[ -z "${conf[CRYPTTAB]}" ]] && conf[CRYPTTAB]="${CONFDIR}/crypttab"
	[[ -z "${conf[BLOCKDEVSDIRS]}" ]] && conf[BLOCKDEVSDIRS]="/dev/disk/by-id"
	[[ -z "${conf[START_TIMEOUT]}" ]] && conf[START_TIMEOUT]=5
	[[ -z "${conf[LOCK_TIMEOUT]}" ]] && conf[LOCK_TIMEOUT]=5
	[[ -z "${conf[PP_TIMEOUT]}" ]] && conf[PP_TIMEOUT]=3
	[[ -z "${conf[QUEUE_TIMEOUT]}" ]] && conf[QUEUE_TIMEOUT]=2
	[[ -z "${conf[KEYLIFE]}" ]] && conf[KEYLIFE]=10
	[[ -z "${conf[CLEANUP_TIMER]}" ]] && conf[CLEANUP_TIMER]=60
	[[ -z "${conf[FWDIR]}" ]] && conf[FWDIR]="/sys/firmware/efi/efivars"
	[[ -z "${conf[FWGUID]}" ]] && conf[FWGUID]="ca25478a-acb8-44ac-8c55-d5d45dfe25c5"
	[[ -z "${conf[FWBOOTCONF]}" ]] && conf[FWBOOTCONF]="${conf[FWDIR]}/UglyLinuxBootCFG-${conf[FWGUID]}"
	[[ -z "${conf[BOOTCONF]}" ]] && conf[BOOTCONF]="${CONFDIR}/boot.conf"
	[[ -z "${conf[NET_ONLINE]}" ]] && conf[NET_ONLINE]=1
	[[ -z "${conf[USER_TIEMOUT]}" ]] && conf[USER_TIMEOUT]=10
	conf[START_TIMEOUT]=$((conf[START_TIMEOUT]*60))
	conf[PP_TIMEOUT]=$((conf[PP_TIMEOUT]*60))
	conf[KEYLIFE]=$((conf[KEYLIFE]*60))

	# Initialize formatting parameters for console output.
	RED="\033[91m" GREY="\033[94m" YEL="\033[93m" GRN="\033[92m" BOLD="\033[1m" UL="\033[4m" NOR="\033[0m" RES="\0332J"
	PR="\033[s" PD="\033[u\033[16C\033[s" PE="\033[u\033[62C\033[s" PP="\033[u\033[6C\033[s" PT="\033[u\033[22C\033[s" PS="\033[u\033[21C"
}

# [BEGIN OF LOGGING FUNCTIONS]

trap_term_logwriter()
{
	trap 'logger -p daemon.warning "cryptdisksd: ${_myname} unclean finish after $(do_timer ${_time_start})s"; exit 1' SIGINT SIGTERM

	# When the log writer is killed, set the read timeout to 1s (no exit) to allow the writer to parse remaining log messages.
	local _date="$(date '+%d-%m %H:%M:%S.%3N')"
	logger -p daemon.info "cryptdisksd: ${_myname} terminating"
	[[ ${conf[LOGLEVEL]} -gt 0 ]] && echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${_myname} terminating after $(do_timer ${_time_start})s" >>${conf[LOGFILE]}
	exit 0
}

logwriter()
{
	trap 'trap_term_logwriter' SIGINT SIGTERM

	# The log write will parse lines from stdin, sent by various workers. The lines are written to log and sent to syslog.
	local _myname="logger (${BASHPID}):" _time_start=${EPOCHREALTIME:0:-3} _lf _line

	# Initialize the log file. Set the correct access rights.
	[[ ! -d ${conf[LOGDIR]} ]] && mkdir -p ${conf[LOGDIR]}
	chgrp ${conf[CRYPTDISKSD_GROUP]} ${conf[LOGDIR]}
	chmod 750 ${conf[LOGDIR]}
	if [[ ! -z "$1" ]]; then
		conf[LOGFILE]=${conf[LOGDIR]}/$1
		touch ${conf[LOGFILE]}
	fi
	chgrp ${conf[CRYPTDISKSD_GROUP]} ${conf[LOGFILE]}
	chmod 640 ${conf[LOGFILE]}
	[[ ${conf[LOGLEVEL]} -gt 0 ]] && echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${_myname} initialized" >>${conf[LOGFILE]}

	# Prepend every line recieved with date and time and write to logfile.
	while read -r _lf _line; do
		local _date="$(date '+%d-%m %H:%M:%S.%3N')"
		if [[ "${_lf}" == "debug" && ${conf[LOGLEVEL]} -ge 1 ]]; then
			echo "${_date} ${hostname} ${_line}" >>${conf[LOGFILE]}
		elif [[ "${_lf}" == "debug2" && ${conf[LOGLEVEL]} -ge 3 ]]; then
			echo "${_date} ${hostname} ${_line}" >>${conf[LOGFILE]}
		elif [[ ${_lf} == "info" || ${_lf} == "warning" || ${_lf} == "error" ]]; then
			logger -p daemon.${_lf} "cryptdisksd: ${_line}"
			[[ ${conf[LOGLEVEL]} -ge 1 ]] && echo "${_date} ${hostname} ${_line}" >>${conf[LOGFILE]}
		elif [[ ${conf[LOGLEVEL]} -ge 3 ]]; then
			echo "${_date} ${hostname} ${_lf} ${_line}" >>${conf[LOGFILE]}
		fi
	done
	echo "$(date '+%d-%m %H:%M:%S.%3N') ${hostname} ${_myname} read error! ($?)" >>${conf[LOGFILE]}
	exit 1
}

do_log()
{
	# Send a message to the log writer, or to systemd if that fails.
	echo "$@" >&6 || echo "$@" >&3
}

do_timer()
{
	# Start a timer for debugging purposes. We will track to the ms.
	if [[ $# -eq 0 ]]; then
		# Started with no args, start a timer, echo the start time.
		echo ${EPOCHREALTIME:0:-3}
	elif [[ ${1,,} == "date" ]]; then
		# Output the exact date of the timestamp.
		local ___date="$(date --date @$2 +%Y-%m-%d.%H:%M:%S)"
		echo "${___date}"
	else
		# Started with start time as args, calculate and echo the time difference.
		local ___stime=$1
		local ___etime=${EPOCHREALTIME:0:-3}
		if [[ -z "${___stime}" ]]; then ___stime=${___etime}; fi
		# Calculate the difference between start and end time and echo.
		# to be removed
		local ___dtime="$(bc <<<"x=${___etime}-${___stime}; if (x<1) print 0; x")"
		echo "${___dtime}"
	fi
}

# [END OF LOGGING FUNCTIONS]

# [BEGIN OF MAIN DAEMON FUNCTIONS]

trap_term_daemon()
{
	trap 'systemd-notify --pid=$$ --status="cryptdisksd: unclean finish after $(do_timer ${time_start})s"; exit 1' SIGINT SIGTERM

	# Main process received SIGTERM or SIGINT, shutdown reader and logwriter processes.
	systemd-notify --pid=$$ --stopping --status="cryptdisksd: terminating"
	do_log warning "${myname} terminating after ${time_active}s"
	do_daemon_check_conf
	for _pid in ${pid_ctrl[@]}; do
		if [[ "$(cat /proc/${pid_ctrl[${_pid}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${pid_ctrl[${_pid}]}
			wait ${pid_ctrl[${_pid}]}
			do_log debu2 "${myname} killed control process (PID: ${pid_ctrl[${_pid}]})"
		fi
	done
	if [[ ! -z "${pid_reader}" && "$(cat /proc/${pid_reader}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_reader}
		wait ${pid_reader}
	fi
	if [[ ! -z "${pid_logwriter}" && "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${pid_logwriter}
		wait ${pid_logwriter}
	fi
	rm -f ${conf[PIDFILE]} ${conf[CRYPTDISKSDDIR]}/*.sock
	systemd-notify --pid=$$ --status="cryptdisksd: finished after $(do_timer ${time_start})s"
	
	exit $1 
}

trap_hup_daemon()
{
	# Received reload request from systemd. Reload the config asap (no active commands/workers). confok, contains status.
	# 0 - Config is ok.
	# 1 - Config changed, or SIGHUP received
	# 2 - Notified reader of reload
	# When the reader is ready to reload it will notify us and we can reload the config and restart the reader.
	if [[ ${starting} -eq 0 && ${confok} -eq 0 ]]; then
		do_log warning "${myname} received SIGHUP, reload config asap"
		confok=2
		kill -SIGHUP ${pid_reader}
		do_log debug2 "${myname} notified reader (PID: ${pid_reader}) of config reload"
	fi
}

systemd_daemon()
{
	trap 'trap_term_daemon' SIGINT SIGTERM
	trap 'trap_hup_daemon' SIGHUP

	# Here we go, we are started from systemd. We will first process to queue entirely and notify systemd if we're done.
	# The daemon and queue reader are recursive processes. They will re-enter themselves after processing a command. 
	# The reader spawns worker processes to get passphrases and the daemon will mount the actual cryptdisks. 
	# After receiving a command from udev the reader will have to do some atomical procesing, like checking for active
	# passphrase workers and sending info about crypts to the daemon. The daemon queues all mounts until passphrase is received.
	# After receiving a passphrase the worker will send it to the daemon, which then mounts the crypts on the respective queueu.
	# A cleanup will be run every minute. There we will detect if configuration has changed and remove timed out workers and mounts.
	[[ ${conf[DEBUGSHELL]} -eq 1 ]] && set -a

	local hostname="$(hostname)" pid_daemon=${BASHPID} myname="daemon (${BASHPID}):" time_start=${EPOCHREALTIME:0:-3}
	local starting=1 start_status=0 time_active=0.000 cleanup=0.000 systemdconf="" crypttab="" confok=0
	local pid_logwriter pid_reader fd_reader reader_alive=0 readerr=0 cached_pp=""
	declare -A active_mnt pid_ctrl fd_ctrl time_ctrl bootconf

	echo ${pid_daemon} >${conf[PIDFILE]}

	# Close stdin, fd3 to stdout (systemd journald) for reader and worker processes. Redirect stdout and stderr to /dev/null.
	# If we are running in foreground mode evrything goes to stdout of the user's terminal. And we wish him or her good luck with that.
	[[ ${FOREGROUND} -ne 1 ]] && exec 0>&- 3>&1- 1>/dev/null 2>&1
	[[ ${FOREGROUND} -eq 1 ]] && exec 6>&1 3>&6

	# Start the logwriter.
	[[ ${FOREGROUND} -ne 1 ]] && do_daemon_start_logwriter
	do_log info "${myname} initializing"

	# Check if the queue exists first, exit with error if it isn't. It should be there, or something is wrong with socket.
	if [[ ! -p ${conf[FIFO]} ]]; then
		do_log error "${myname} queue not found" 
		systemd-notify --ready --pid=$$
		systemd-notify STOPPING=1 --pid=$$ --status="cryptdisksd: Queue not Found, Restart cryptdisksd.socket" 
		exit 0
	fi

	# Check if there is a crypttab, log message if there isn't since everything we do is based on it.
	if [[ ! -f ${conf[CRYPTTAB]} ]]; then
		echo -e "#Crypt\t\t\t#Device\t\t\t\t#Passphrase\t\t#TRIM" >${conf[CRYPTTAB]}
		do_log warning "${myname} crypttab not found" 
		systemd-notify --pid=$$ --status="cryptdisksd: Crypttab (${conf[CRYPTTAB]}) not Found"
		start_status=2
	fi

	# Parse and load the configuration, exit if either fails.
	if ! do_daemon_check_conf; then 
		do_log error "${myname} failed to load config" 
		if [[ "$(cat /proc/${pid_reader}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${pid_reader}
			do_log debug "${myname} killed reader (PID: ${pid_reader})"
		fi
		systemd-notify --ready --pid=$$
		systemd-notify STOPPING=1 --pid=$$ --status="cryptdisksd: Failed to Load Configuration"
		exit 0
	fi

	# Start the reader, it will notify us when it has emptied the queue or other events.
	# When wait returns exit status <128 we will know the reader has terminated.
	# The reader and all workers will be started with the following available fds:
	# 1 (stdout) 2 (stderr) and 6 (for subshells) point to a log writer.
	# 3 systemd socket to send messages which will be logged by systemd and can be viewed with systemctl status and journalctl -xe
	# 4 (in) and 5(out) where applicable to the daemon process.
	systemd-notify --pid=$$ --status="cryptdisksd: Starting Up, Timeout $((conf[START_TIMEOUT]+conf[QUEUE_TIMEOUT]*2))s"
	systemd-notify EXTEND_TIMEOUT_USEC=$(((conf[START_TIMEOUT]+conf[QUEUE_TIMEOUT]*2)*1000000))

	do_daemon_start_reader
	do_log debug "${myname} started reader (PID: ${pid_reader})"

	# The readers and will send us messages about events, we need to keep track of time for (debug) logging and cleanup.
	# If we are starting up, read time-out is start timeout so cleanup etc will be done only after start
	# If we are in normal op, keep cleanup timer (60secs). The timeouts will be evaluated every command iteration.
	while true; do	
		# Evaluate timeouts and cleanup, and reset status.
		local read_to status=0 msg=() res
		do_daemon_timeout
		
		# Start reading from the reader message queue. Parse the message into an arry the first element will be reader second the pid of the reader, rest is the message.
		IFS=" " read ${read_to} -ru ${fd_reader} -a msg
		res=$?
		
		# Evaluate the exit status of the message queue read and act accordingly.
		time_active=$(do_timer ${time_start})
		if [[ ${res} -eq 142 ]]; then 
			case ${starting} in 
				1|2|3)
					# Start timeout reached, notify systemd.
					do_log debug2 "${myname} start timeout reached, notifying reader and systemd"
					starting=0
					start_status=3
					do_daemon_notify_systemd
					;;
				0)
					# Queue timeout for cleanup.
					do_log debug2 "${myname} waking up from slumber"
					;;
			esac
			do_log debug2 "${myname} running since $(do_timer date ${time_start})"
			continue
		elif [[ ${res} -gt 128 ]]; then
			# Should not happen, daemon process received unhandled signal from somewhere.
			do_log debug "${myname} read result ${res}, may have been trapped"
			do_daemon_cleanup 
			continue
		elif [[ ${res} -ne 0 ]]; then
			# Reader has terminated unexpectedly or fd has somehow been closed from reader end.
			if [[ ${readerr} -eq 0 ]]; then 
				do_log error "${myname} read error ${res} \"${msg[@]}\""
			elif [[ $((readerr%20)) -eq 0 ]]; then
				reader_alive=2
				do_daemon_cleanup
			elif [[ ${readerr} -gt 99 ]]; then
				do_log error "${myname} too many read errors, terminating"
				trap_term_daemon 1
			fi
			readerr=$((readerr+1))
			continue
		fi
		readerr=0

		# Evaluate the start status.
		if [[ ${starting} -ne 0 ]]; then
			[[ ${status} -eq 1 ]] && start_status=1
			[[ ${start_status} -eq 0 && ${status} -eq 2 ]] && start_status=2
			# Check if we have a start timeout. If so we are started and will notify systemd.
			if [[ ${time_active:0:-4} -ge ${conf[START_TIMEOUT]} ]]; then 
				starting=0
				start_status=3
				do_daemon_notify_systemd
				continue
			fi
		fi
		
		if [[ -z "${msg[@]}" ]]; then
			# Should not occur, run cleanup if it does, if reader has exited next read will fail, see above.
			do_log error "${myname} reached EOF on reader, running cleanup"
			reader_alive=2
			do_daemon_cleanup
			continue
		fi

		# Process the message sent by the reader.
		do_log debug "${myname} processing \"${msg[@]}\", ${msg[0]}, ${msg[1]}" 
		if [[ "${msg[0],,}" == "reader" && ${msg[1]} -eq ${pid_reader} ]]; then
			do_daemon_reader
		else	
			do_log error "${myname} received invalid message \"${msg[@]}\""
		fi

	done

	# We should never get here, exit with error if we do.
	time_active="$(do_timer ${time_start})"
	do_log error "${myname} terminated unexpectedly after ${time_active}s"
	systemd-notify --pid=$$ --status="cryptdisksd: Daemon Terminated Unexpectedly After ${time_active}s (PID: ${BASHPID}))"
	trap_term_daemon 2
}

do_daemon_start_logwriter()
{
	# LOGLEVEL 0, log only to syslog (daemon facility). 
	# LOGLEVEL 1, log to syslog and debug to dedicated logfile.
	# LOGLEVEL 2 is loglevel 1 with components having dedicated log file.
	# LOGLEVEL 3, extra debug logging, stdout and stderr of processes also sent to log.
	# BEWARE PASSPHRASES WILL BE LOGGED ALSO!!!!
	# LOGLEVEL 4, sames as level 3 with components having dedicated log file.
	case ${conf[LOGLEVEL]} in
		0|1) 	exec 6> >(logwriter);;
		2)		exec 6> >(logwriter daemon-${pid_daemon}.log);;
		3)		exec 6> >(logwriter) 1>&6 2>&6;;
		4)		exec 6> >(logwriter daemon-${pid_daemon}.log) 1>&6 2>&6;;
	esac
	pid_logwriter=$!
}

do_daemon_start_reader()
{
	# Set the group and mode for the rundir and queue.
	[[ ! -z ${fd_reader} ]] && exec {fd_reader}>&-
	chgrp ${conf[CRYPTDISKSD_GROUP]} ${conf[CRYPTDISKSDDIR]} ${conf[FIFO]}
	chmod ${conf[CRYPTDISKSDDIR_MODE]} ${conf[CRYPTDISKSDDIR]}
	chmod ${conf[FIFO_MODE]} ${conf[FIFO]}
	case ${conf[LOGLEVEL]} in
		0|1|2)	# Start the reader with stdout and stderr redirected to /dev/null (silent).
				exec {fd_reader}< <(udev_reader 5>&1- 1>/dev/null 2>&1);;
		3|4)	# Start the reader with stdout and stderr redirected to the logwriter.
				exec {fd_reader}< <(udev_reader 5>&1- 1>&6 2>&1);;
	esac
	pid_reader=$!
}

do_daemon_timeout()
{
	# If we are starting up, read time-out when initial queue is empty so we can notify parent.
	# If we are in normal operation, keep cleanup timer (60secs).
	do_log debug2 "${myname} running since $(do_timer date ${time_start})"
	time_active=$(do_timer ${time_start})
	
	# Set the new queue read timeout, we will run a cleanup every conf[CLEANUP_TIMER]. Cleanup will not run before we are started.
	case ${starting} in
		0)
			# Do a cleanup if the timer is about to expire.
			if [[ ${time_active:0:-4} -gt $((${cleanup:0:-4}+${conf[CLEANUP_TIMER]}-${conf[QUEUE_TIMEOUT]})) ]] || [[ ${res} -eq 142 && ${read_to##* } -gt $((conf[CLEANUP_TIMER]/2)) ]]; then
				do_daemon_cleanup
			fi
			read_to="-t $(((${conf[CLEANUP_TIMER]}+${conf[QUEUE_TIMEOUT]})-(${time_active:0:-4}%${conf[CLEANUP_TIMER]})))";;
		1|2)
			# Make sure the read timeout is never 0 as this will complicate things (read will not read if to = 0).
			read_to="-t $(((${conf[START_TIMEOUT]}+${conf[QUEUE_TIMEOUT]})-(${time_active:0:-4}%${conf[START_TIMEOUT]})))";;
	esac
}

do_daemon_notify_systemd()
{
	# Daemon notify about startup status.
	systemd-notify --ready --pid=$$
	case ${start_status} in 
		0)
			do_log info "${myname} startup completed succesfully in ${time_active}s"
			systemd-notify --pid=$$ --status="cryptdisksd: Startup completed succesfully in ${time_active}s (PID: ${BASHPID})";;
		1)
			do_log warning "${myname} startup completed with errors in ${time_active}s"
			systemd-notify --pid=$$ --status="cryptdisksd: Startup completed with errors in ${time_active}s (PID: ${BASHPID})";;
		2)
			do_log warning "${myname} startup completed with warnings in ${time_active}s"
			systemd-notify --pid=$$ --status="cryptdisksd: Startup completed with warnings in ${time_active}s (PID: ${BASHPID})";;
		3)
			do_log warning "${myname} startup timed out after ${time_active}s"
			systemd-notify --pid=$$ --status="cryptdisksd: Startup timed out after ${time_active}s (PID: ${BASHPID})"
			kill -SIGHUP ${pid_reader};;
	esac
	do_daemon_cleanup
}

do_daemon_check_conf()
{
	# Parse the configuration from firmware and compare it to the config stored in the confdir.
	# If there are any differences, the configuration in confidir will take precedence and overwrite the firmware.
	do_log debug "${myname} checking config"

	if [[ -s ${conf[FWBOOTCONF]} && ! -s ${conf[BOOTCONF]} ]]; then
		# Config in firware, not in confdir, copy fw to confdir.
		[[ ${confok} -eq 0 ]] && confok=1
		do_log debug "${myname} copying ${conf[FWBOOTCONF]} config to ${CONFDIR}"
		cat ${conf[FWBOOTCONF]} | tail -c +5 >${conf[BOOTCONF]} || return 1
	elif [[ -s ${conf[FWBOOTCONF]} && -s ${conf[BOOTCONF]} ]]; then
		# Compare the firmware config to confdir.
		local __diff="$(cat ${conf[FWBOOTCONF]} | tail -c +5)"
		local __diff1="$(cat ${conf[BOOTCONF]})"
		if ! diff -q <(echo "${__diff}") <(echo "${__diff1}") >/dev/null; then
			# Configs are different, overwrite confdir on startup firmware config otherwise.
			[[ ${confok} -eq 0 ]] && confok=1
			if [[ ${starting} -eq 0 ]]; then
				do_log warning "${myname} ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} differ, replacing ${conf[FWBOOTCONF]}"
				[[ -e ${conf[FWBOOTCONF]} ]] && chattr -i ${conf[FWBOOTCONF]}
				printf "\x07\x00\x00\x00\x00" >${conf[FWBOOTCONF]} || do_log error "${myname} error creating ${conf[FWBOOTCONF]}"
				efivar -n ${conf[FWGUID]}-UglyLinuxBootCFG -w -f ${conf[BOOTCONF]} 2>&1 || do_log error "${myname} error copying ${conf[BOOTCONF]} to ${conf[FWBOOTCONF]}"
				chattr +i ${conf[FWBOOTCONF]}
			else
				do_log warning "${myname} ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} differ, replacing ${conf[BOOTCONF]}"
				cat ${conf[FWBOOTCONF]} | tail -c +5 >${conf[BOOTCONF]}
			fi
		else
			do_log debug2 "${myname} ${conf[FWBOOTCONF]} and ${conf[BOOTCONF]} equal"
		fi
	elif [[ ! -s ${conf[FWBOOTCONF]} && -s ${conf[BOOTCONF]} ]]; then
		# No fwconfig store confdir.
		[[ ${confok} -eq 0 ]] && confok=1
		do_log debug "${myname} no firmware config, copying from ${conf[BOOTCONF]}"
		[[ -e ${conf[FWBOOTCONF]} ]] && chattr -i ${conf[FWBOOTCONF]}
		printf "\x07\x00\x00\x00\x00" >${conf[FWBOOTCONF]} || do_log error "${myname} error creating ${conf[FWBOOTCONF]}"
		efivar -n ${conf[FWGUID]}-UglyLinuxBootCFG -w -f ${conf[BOOTCONF]} || do_log error "${myname} error copying ${conf[BOOTCONF]} to ${conf[FWBOOTCONF]}"
		chattr +i ${conf[FWBOOTCONF]}
	else
		# No bootconf at all.
		do_log warning "${myname} no boot config found"
		bootconf[BOOTSERVERS]=""
	fi

	# If we are starting up, now is the time to load the config.	
	if [[ ${starting} -eq 1 ]]; then
		do_daemon_reload_conf	
	fi

	# Check if the service config or crypttab has changed on disk.
	if [[ ${starting} -eq 0 && ${confok} -eq 0 ]]; then
		if [[ ! -f ${conf[CRYPTTAB]} ]]; then
			do_log warning "${myname} ${conf[CRYPTTAB]} disappeared, terminating"
		fi
		if [[ ! -f ${CONF} ]]; then
		 	do_log error "${myname} ${CONF} disappeared, terminating"
			return 1
		fi
		local __diff="$(cat ${CONF} |grep -ve "^\s*#")"
		if ! diff -q <(echo "${__diff}") <(echo "${systemdconf}") >/dev/null; then
			do_log error "${myname} ${CONF} changed, terminating"
			return 1
		fi
		local __diff="$(cat ${conf[CRYPTTAB]} |grep -ve "^\s*#")"
		if ! diff -q <(echo "${__diff}") <(echo "${crypttab}") >/dev/null; then
			do_log debug "${myname} crypttab changed, reloading asap"
			confok=1
		fi
	fi

	# Check the bootserver and user keys if present.
	[[ -z ${bootconf[BOOTSERVERS]} ]] && return
	local _fwsrvvar="${conf[FWGUID]}-UglyLinux${bootconf[BOOTSERVERKEYS]}"
	local _fwsrvkey="${conf[FWDIR]}/UglyLinux${bootconf[BOOTSERVERKEYS]}-${conf[FWGUID]}"
	local _srvkey="${CONFDIR}/${bootconf[BOOTSERVERKEYS]}"
	local _fwusrvar="${conf[FWGUID]}-UglyLinux${bootconf[BOOTUSERKEY]}"
	local _fwusrkey="${conf[FWDIR]}/UglyLinux${bootconf[BOOTUSERKEY]}-${conf[FWGUID]}"
	local _usrkey="${CONFDIR}/${bootconf[BOOTUSERKEY]}"
	if [[ -s ${_fwsrvkey} && -s ${_srvkey} ]]; then
		# compare the keys, overwrite if necessary
		local _diff="$(cat ${_fwsrvkey} | tail -c +5)"
		local _diff1="$(cat ${_srvkey})"
		if ! diff -q <(echo "${_diff}") <(echo "${_diff1}") >/dev/null; then
			# Configs are different, overwrite firmware config
			do_log warning "${myname} ${_fwsrvkey} and ${_srvkey} differ, replacing ${_fwsrvkey}"
			[[ -e ${_fwsrvkey} ]] && chattr -i ${_fwsrvkey}
			printf "\x07\x00\x00\x00\x00" >${_fwsrvkey} || do_log error "${myname} error creating ${_fwsrvkey}"
			efivar -n ${_fwsrvvar} -w -f ${_srvkey} || do_log error "${myname} error copying ${_srvkey} to ${_fwsrvkey}"
			chattr +i ${_fwsrvkey}
		else
			do_log debug2 "${myname} ${_fwsrvkey} and ${_srvkey} equal"
		fi
	elif [[ -s ${_fwsrvkey} && ! -s ${_srvkey} ]]; then
		# Keys in fw not in confdir, copy
		do_log debug "${myname} copying ${_fwsrvkey} to ${_srvkey}"
		cat ${_fwsrvkey} | tail -c +5 > ${_srvkey} || return 1
	elif [[ ! -s ${_fwsrvkey} && -s ${_srvkey} ]]; then
		# No fwbootkeys, copy from confdir.
		do_log debug "${myname} no firmware bootserver keys, copying from ${_srvkey}"
		[[ -e ${_fwsrvkey} ]] && chattr -i ${_fwsrvkey}
		printf "\x07\x00\x00\x00\x00" >${_fwsrvkey} || do_log error "${myname} error creating ${_fwsrvkey}"
		efivar -n ${_fwsrvvar} -w -f ${_srvkey} || do_log error "${myname} error copying ${_srvkey} to ${_fwsrvkey}"
		chattr +i ${_fwsrvkey}
	else
		# No bootserverkeys at all
		do_log error "${myname} no bootserver keys found"
		bootconf[BOOTSERVERS]=""
	fi

	# No need to check user key, if server key not present.
	[[ -z ${bootconf[BOOTSERVERS]} ]] && return
	if [[ -s ${_fwusrkey} && ! -s ${_usrkey} ]]; then
		# Key in fw not in confdir, copy
		do_log debug "${myname} copying ${_fwusrkey} to ${_usrkey}"
		chattr -i ${_fwusrkey}; chmod 400 ${_fwusrkey}; chattr +i ${_fwusrkey}
		cat ${_fwusrkey} | tail -c +5 > ${_usrkey} || return 1
		chmod 400 ${_usrkey}
	elif [[ -s ${_fwusrkey} && -s ${_usrkey} ]]; then
		# compare the keys, overwrite if necessary
		local _diff="$(cat ${_fwusrkey} | tail -c +5)"
		local _diff1="$(cat ${_usrkey})"
		if ! diff -q <(echo "${_diff}") <(echo "${_diff1}") >/dev/null; then
			# Configs are different, overwrite firmware config
			do_log warning "${myname} ${_fwusrkey} and ${_usrkey} differ, replacing ${_fwusrkey}"
			[[ -e ${_fwusrkey} ]] && chattr -i ${_fwusrkey}
			printf "\x07\x00\x00\x00\x00" >${_fwusrkey} || do_log error "${myname} error creating ${_fwusrkey}"
			efivar -n ${_fwusrvar} -w -f ${_usrkey} || do_log error "${myname} error copying ${_usrkey} to ${_fwusrkey}"
			chattr -i ${_fwusrkey}; chmod 400 ${_fwusrkey}; chattr +i ${_fwusrkey}
		else
			do_log debug2 "${myname} ${_fwusrkey} and ${_usrkey} equal"
			chattr -i ${_fwusrkey}; chmod 400 ${_fwusrkey}; chattr +i ${_fwusrkey}
			chmod 400 ${_usrkey}
		fi
	elif [[ ! -s ${_fwusrkey} && -s ${_usrkey} ]]; then
		# No fwbootuserkey, copy from confdir
		do_log debug "${myname} no firmware bootuser key, copying from ${_usrkey}"
		[[ -e ${_fwusrkey} ]] && chattr -i ${_fwusrkey}
		printf "\x07\x00\x00\x00\x00" >${_fwusrkey} || do_log error "${myname} error creating ${_fwusrkey}"
		efivar -n ${_fwusrvar} -w -f ${_usrkey} || do_log error "${myname} error copying ${_usrkey} to ${_fwusrkey}"
		chattr -i ${_fwusrkey}; chmod 400 ${_fwusrkey}; chattr +i ${_fwusrkey}
	else
		# No bootuserkeys at all
		bootconf[BOOTSERVERS]=""
	fi
	return 0
}

do_daemon_reload_conf()
{
	do_log debug "${myname} loading configuration"
	crypttab=""
	systemdconf=""

	# Load the crypttab into memory.
	[[ -s ${conf[CRYPTTAB]} ]] && crypttab="$(cat ${conf[CRYPTTAB]} |grep -ve "^\s*#")" 

	# Source the boot config if necessary.
	local __var __val
	for __var in ${!bootconf[@]}; do
		unset bootconf[${__var}]
	done
	if [[ -s ${conf[BOOTCONF]} ]]; then
		while IFS="=" read -r __var __val; do
			[[ ! -z "${__val}" ]] && bootconf[${__var^^}]="${__val}"
	   	done <<<"$(cat ${conf[BOOTCONF]} |grep -ve "^\s*#")"
	fi
	[[ -s ${CONF} ]] && systemdconf="$(cat ${CONF} |grep -ve "^\s*#")"
}

do_daemon_cleanup()
{
	# Readers should not ever exit, the is an error / bug. Restart the reader
	local _time_start=${EPOCHREALTIME:0:-3} _logwriter_running _tab_crypt="" _pp _crypt _dev _trim _time _pid __crypt __crypt_arr _mnt_crypt
	cleanup=$(do_timer ${time_start})
	do_log debug "${myname} cleanup starting at ${time_active}"

	# Ping systemd.
	systemd-notify WATCHDOG=1 WATCHDOG_USEC=$(((2*conf[CLEANUP_TIMER])*1000000))

	# Check if the log writer is still active, restart it and the reader if necessary.
	if [[ ! -z ${pid_logwriter} ]]; then
		if [[ "$(cat /proc/${pid_logwriter}/comm 2>/dev/null)" != "${MYNAME}" ]] || ! kill -0 ${pid_logwriter} && kill -SIGKILL ${pid_logwriter}; then
			do_log error "${myname} logwriter (PID: ${pid_logwriter}) terminated after ${time_active}s, restarting"
			systemd-notify "cryptdisksd: logwriter (PID: ${pid_logwriter}) terminated after ${time_active}s, restarting"
			if [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]] && [[ ! -z "${pid_reader}" && "$(cat /proc/${pid_reader}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
				kill -SIGTERM ${pid_reader} && unset pid_reader
				[[ -e /proc/self/fd/${fd_reader} ]] && exec {fd_reader}>&-
				do_log debug2 "${myname} killed reader (PID: ${pid_reader})"
			fi
			do_daemon_start_logwriter
		fi
	fi

	# Kill too long running control conections.
	for _pid in ${!pid_ctrl[@]}; do
		_time=$(do_timer ${time_ctrl[${_pid}]})
		if [[ ${_time:0:-4} -ge $((conf[PP_TIMEOUT]+conf[QUEUE_TIMEOUT])) ]]; then 
			do_log debug "${myname} cleanup killed control worker (PID: ${pid_ctrl[${_pid}]})"
			if [[ ! -z "${pid_ctrl[${_pid}]}" && "$(cat /proc/${pid_ctrl[${_pid}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
				kill -SIGKILL ${pid_ctrl[${_pid}]}
				do_log debug2 "${myname} killed ${pid_ctrl[${_pid}]}"
			fi
			exec {pid_ctrl[${_pid}]}>&-; unset pid_ctrl[${_pid}] fd_ctrl[${_pid}] time_ctrl[${_pid}]
		fi
	done
	[[ -z ${!pid_ctrl[@]} ]] && rm -f ${conf[CRYPTDISKSDDIR]}/*.sock

	# Check the config.
	if ! do_daemon_check_conf; then
		do_log error "${myname} failed to check config, terminating"
		systemd-notify --ready --pid=$$
		systemd-notify STOPPING=1 --pid=$$ --status="cryptdisksd: Failed to Load Configuration"
		trap_term_daemon
	fi
		
	if [[ ${starting} -eq 0 && ${confok} -eq 1 ]]; then
		# Config has changed, needs to be reloaded.
		confok=2
		kill -SIGHUP ${pid_reader}
		do_log debug2 "${myname} notified reader (PID: ${pid_reader}) of config reload"
	fi

	# Check if the reader is still alive and restart it if necessary.	
	if [[ ${reader_alive} -eq 2 || "$(cat /proc/${pid_reader}/comm 2>/dev/null)" != "${MYNAME}" ]] || ! kill -0 ${pid_reader}; then
		do_log error "${myname} reader (PID: ${pid_reader}) not functioning after ${time_active}s"
		systemd-notify --pid=$$ --status="cryptdisksd: reader (PID: ${pid_reader}) terminated after ${time_active}s"
		if [[ "$(cat /proc/${pid_reader}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${pid_reader}
			do_log debug2 "${myname} killed reader (PID: ${pid_reader})"
		fi
		[[ -e /proc/self/fd/${fd_reader} ]] && exec {fd_reader}>&-
		do_daemon_reload_conf
		confok=0
		reader_alive=0
		do_daemon_start_reader
		# Check if any crpyts have been removed from the crypttab and try to remove then. Then trigger udev to add new devices.
		# We will set a list with all crypts in the crypttab and will check that list against active mounts later.
		_tab_crypt="$(tr "\t" " " <<<"${crypttab}" |cut -d" " -f1)"
	elif [[ ${reader_alive} -eq 1 ]]; then
		do_log warning "${myname} have not received ping from reader (PID: ${pid_reader})"
		reader_alive=2
	else
		reader_alive=1
	fi

	# Check the active crypts and add to active list if not already present.
	_mnt_crypt="$(dmsetup ls --target crypt |cut -f1 |grep -vi "No devices found")"
	for _crypt in ${_mnt_crypt}; do
		if [[ -z "${active_mnt[${_crypt}]}" ]]; then
			do_xcrypt_fromtab myname "${_crypt}"
			[[ "$(lsblk -rD /dev/mapper/${_crypt} |head -n2 |tail -n1 |cut -d " " -f3)" == "0B" ]] && _trim=0 || _trim=1
			if [[ ! -z "${__crypt_arr[0]}" ]]; then
				_dev="${__crypt_arr[1]}"
				_pp="$(do_eval_pp "${__crypt_arr[2]}")"
				active_mnt[${_crypt}]="${_dev} ${_pp} ${_trim} ${EPOCHREALTIME:0:-3}"
			else
				_dev=/dev/"$(dmsetup deps ${_crypt} -o blkdevname |cut -d: -f2 |tr -d " ()")"
				active_mnt[${_crypt}]="${_dev} - ${_trim} ${EPOCHREALTIME:0:-3}"
			fi
			do_log debug "${myname} found ${_dev} as ${_crypt} TRIM ${_trim} passphrase ${_pp} adding to active list"
		fi
	done

	# Check for removed crypts and remove the from active list.
	for _crypt in ${!active_mnt[@]}; do
		for __crypt in ${_mnt_crypt}; do
			[[ "${_crypt}" == "${__crypt}" ]] && continue 2
		done
		IFS=" " read -r _dev _pp _trim _time <<<"${active_mnt[${_crypt}]}"
		do_log warning "${myname} ${_dev} as ${_crypt} TRIM ${_trim} passphrase ${_pp} mounted since $(do_timer date ${_time}) dissapeared"
		unset active_mnt[${_crypt}]
	done

	# If we have reloaded look up any managed crypts removed from crypttab and try to unmount them.
	if [[ ! -z "${_tab_crypt}" ]]; then
		for _crypt in ${!active_mnt[@]}; do
			IFS=" " read -r _dev _pp _trim _time <<<"${active_mnt[${_crypt}]}"
			[[ "${_pp}" == "-" ]] && continue
			for __crypt in ${_tab_crypt}; do
				[[ "${_crypt}" == "${__crypt}" ]] && continue 2
			done
			do_log warning "${myname} ${_dev} as ${_crypt} TRIM ${_trim} passphrase ${_pp} mounted since $(do_timer date ${_time}) removed from crypttab"
			do_daemon_unmount_crypt "${_crypt}"
		done

		# Trigger udev to mount any new devices on the crypttab not already mounted.
		do_log debug "${myname} triggering udev"
		udevadm trigger -s block -c change
	fi

	do_log debug2 "${myname} cleanup took $(do_timer ${_time_start})s, cached passphrases: ${cached_pp}- active mounts: ${!active_mnt[@]}"
}

# [END OF MAIN DAEMON FUNCTIONS]

# [BEGIN OF DAEMON CONTROL FUNCTIONS]
trap_term_systemd_daemon_cmd()
{
	trap 'do_log warning "${__myname} unclean exit after ${__time_start})s"; exit 1' SIGINT SIGTERM

	if [[ ! -z "${__socat_PID}" && "$(cat /proc/${__socat_PID}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__socat_PID}
		wait ${__socat_PID}
		do_log debug2 "${__myname} killed socat coproc (PID: ${__socat_PID})"
	fi
	if [[ ! -z "${__pid_putkey}" ]]; then
		kill -SIGTERM ${__pid_putkey}
		wait ${__pid_putkey}
		do_log debug2 "${__myname} killed putkey worker (PID: ${__pid_putkey})"
	fi
	do_log debug2 "${__myname} terminating after $(do_timer ${__time_start})s"
	if [[ ! -z "${__pid_logwriter}" &&"$(cat /proc/${__pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_logwriter}
		wait ${__pid_logwriter}
	fi
	rm -f ${_sock_ctrl}
	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}

	exit $1
}

daemon_control_status()
{
	# Connect to control socket and blurt status in some form of a pretty fashion.
	local __myname __time_start __confirm=0 __crypttab=0 __socat __key __passphrase="" __crypt_arr
	local __crypt __dev __pp __trim __time __status __storageprefix="storage"
	do_control_init "status" "Status Report"

	# Output the status to the coproc, which will transfer it to stdout of the requestor. First al active mounts.
	echo -e "\r${GREY}${BOLD}${PR}CRYPT${PD}DEVICE${PE}TRIM${PP}PASSPHRASE${PT}ACTIVE SINCE${PS}STATUS${NOR}\r" >&${__socat[1]}
	[[ -n "${bootconf[STORAGEPREFIX]}" ]] && __storageprefix="${bootconf[STORAGEPREFIX]}"
	for __crypt in ${!active_mnt[@]}; do
		__status=""
		IFS=" " read -r __dev __pp __trim __time <<<"${active_mnt[${__crypt}]}"
		[[ "${__trim}" == "1" ]] && __trim="On" || __trim="Off"
		if [[ "${__pp}" == "-" ]]; then
			if [[ "${__crypt}" =~ ^${__storageprefix}[0-9]{1,2}$ ]]; then
				__status="${GRN}Online (M)"
				if [[ -n "${bootconf[STORAGEPP]}" ]]; then
					__pp="$(do_eval_pp "${bootconf[STORAGEPP]}")"
				else
					__pp="system:master"
				fi
			else
				__status="${YEL}Online (U)"
			fi
		else
			__status="${GRN}Online (M)"
		fi
		__time=$(do_timer date ${__time}); __dev=${__dev##*/}
		echo -e "${PR}${__crypt}${PD}${__dev}${PE}${__trim}${PP}${__pp}${PT}${__time}${PS}${__status}${NOR}\r" >&${__socat[1]}
	done

	# Output all unmounted and waiting crypts.
	local __tab_crypt="$(tr "\t" " " <<<"${crypttab}" |cut -d" " -f1)" ___crypt ____crypt __crypt_arr
	for __crypt in ${__tab_crypt}; do
		__status=""
		for ___crypt in ${!active_mnt[@]}; do
			[[ "${__crypt}" == "${___crypt}" ]] && continue 2
		done
		for __pp in ${!waiting_mnt[@]}; do
			while IFS=" " read -r ____crypt __dev __trim __time; do 
				if [[ "${__crypt}" == "${____crypt}" ]]; then
					__status="${YEL}Waiting"
					__time=$(do_timer date ${__time})
					break 2
				fi
			done <<<"${waiting_mnt[${__pp}]}"
		done
		if [[ ! "${__status}" == "${YEL}Waiting" ]]; then
			__status="${RED}Offline"
			__time="-"
		fi
		do_xcrypt_fromtab __myname "${__crypt}"
		__dev=${__crypt_arr[1]##*/}
	       	__pp="$(do_eval_pp "${__crypt_arr[2]}")"
		[[ "${__crypt_arr[3]}" == "1" ]] && __trim="On" || __trim="Off"
		echo -e "${PR}${__crypt}${PD}${__dev}${PE}${__trim}${PP}${__pp}${PT}${__time}${PS}${__status}${NOR}\r" >&${__socat[1]}
	done
	echo >&${__socat[1]}

	if [[ ${conf[LOGLEVEL]} -ge 1 ]]; then
		# Output cached passphrases.
		echo -e "${PR}${GREY}${BOLD}Cached Passphrases:${PS}${NOR}${cached_pp}\r\n" >&${__socat[1]}
	fi
	if [[ ${conf[LOGLEVEL]} -ge 3 ]]; then
		# Output passphrases.
		echo -e "${PR}${GREY}${BOLD}PASSPHRASE${PS}VALUE${NOR}\r" >&${__socat[1]}
		for __pp in ${cached_pp}; do
			__key="$(keyctl request user "${__pp}")" 
			__passphrase="$(keyctl pipe "${__key}")"
			echo -ne "${PR}${__pp}${PS}" >&${__socat[1]}
			if [[ -z "${key}" ]]; then
				echo -me "${RED}${BOLD}FAIL${NOR}" >&${__socat[1]}
			else
				echo -n  "\"${__passphrase}\"" >&${__socat[1]}
			fi
			echo -e "${NOR}\r" >&${__socat[1]}
		done
		echo >&${__socat[1]}
	fi

	echo -e "${UL}${myname} Running Since $(do_timer date ${time_start}) ($(do_timer ${time_start})s)${NOR}\r" >&${__socat[1]}

	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}
	do_log debug2 "${__myname} finished after $(do_timer ${__time_start})s"
}

daemon_control_smart()
{
	# Display SMART Information for Device
	local __smartall=0 __smarttest=0 __crypt_arr __add_dev __add_crypt __myname
	do_control_init "smart" "Do S.M.A.R.T."

	if ! do_xcrypt_fromtab __myname "${msg[5]}"; then
		echo -e "\r${RED}${BOLD}${msg[5]} not Found in Crypttab.${NOR}\r" >&${__socat[1]}
		trap_term_systemd_daemon_cmd 1
	elif ! do_find_dev ${___crypt_arr[1]} ${__crypt_arr[0]}; then
		echo -e "\r${RED}${BOLD}Device ${___crypt_arr[1]} not Found in ${conf[BLOCKDEVSDIRS]}.${NOR}\r" >&${__socat[1]}
		trap_term_systemd_daemon_cmd 1
	fi

	if [[ ${__smartall} -eq 1 ]]; then
		smartctl -x ${__add_dev} >&${__socat[1]} 2>&1
	else
		smartctl -A ${__add_dev} >&${__socat[1]} 2>&1
	fi
	
	if [[ ${__smarttest} -eq 1 ]]; then
		if dmsetup info "${__add_crypt}" >/dev/null 2>&1; then
			echo -e "\r${RED}${BOLD}${msg[5]} Still Active.${NOR}\r" >&${__socat[1]}
			return 1
		fi
		smartctl -t long ${__add_dev} >&${__socat[1]} 2>&1
	fi

	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}
	do_log debug2 "${__myname} finished after $(do_timer ${__time_start})s"
}

daemon_control_erase()
{
	# Secure Erase Device.
	local __crypt_arr __add_dev __add_crypt __myname __res
	do_control_init "erase" "Secure Erase"

	if ! do_xcrypt_fromtab __myname "${msg[5]}"; then
		echo -e "\r${RED}${BOLD}${msg[5]} not Found in Crypttab.${NOR}\r" >&${__socat[1]}
		trap_term_systemd_daemon_cmd 1
	elif ! do_find_dev ${___crypt_arr[1]} ${__crypt_arr[0]}; then
		echo -e "\r${RED}${BOLD}Device ${___crypt_arr[1]} not Found in ${conf[BLOCKDEVSDIRS]}.${NOR}\r" >&${__socat[1]}
		trap_term_systemd_daemon_cmd 1
	fi

	if dmsetup info "${__add_crypt}" >/dev/null 2>&1; then
		echo -e "\r${RED}${BOLD}${msg[5]} Still Active.${NOR}\r" >&${__socat[1]}
		trap_term_systemd_daemon_cmd 1
	fi

	echo -ne "${RED}${BOLD}This Will Wipe all Data on ${__add_dev}, Are You Sure (y/N)? " >&${__socat[1]}
	IFS= read -t${conf[USER_TIMEOUT]} -rsn1 -u ${__socat[0]} __res
	echo -e "${NOR}${BOLD}${__res}${NOR}\r" >&${__socat[1]}

	if [[ "${__res,,}" == "y" ]]; then
		echo -e "${RED}${BOLD}Secure Erasing ${__add_dev} ${YEL}password: $(hostname)${NOR}\r" >&${__socat[1]}
		hdparm --security-set-pass "$(hostname)" ${__add_dev}
		hdparm --security-erase-enhanced "$(hostname)" ${__add_dev} &
	fi

	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}
	do_log debug2 "${__myname} finished after $(do_timer ${__time_start})s"
}

daemon_control_put()
{
	# Put the passphrase to the boot servers.
	local __myname __time_start __confirm=0 __socat __passphrase="" __add_pp="$(do_eval_pp "${msg[5]}")" __res="" __add_crypt="-" __add_dev="-"
	do_control_init "put" "Putting Key"

	if do_control_read_passphrase; then
		put_key &
		__pid_putkey=$!
		echo -e "\r${BOLD}${GRN}Putting ${__add_pp} Key to Boot Servers.${NOR}\r" >&${__socat[1]}
	else
		echo -e "\r${BOLD}${RED}No Passphrase Received, Bye Bye.${NOR}\r" >&${__socat[1]}
	fi

	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}
	do_log debug2 "${__myname} finished after $(do_timer ${__time_start})s"
}

daemon_control_rmkey()
{
	# Remove the key file for the passphrase.
	local __myname __time_start __confirm=0 __socat __passphrase="" __add_pp="$(do_eval_pp "${msg[5]}")" __res=""
	do_control_init "rmkey" "Removing Key File"
	
	local __keyfile="${conf[FWDIR]}/UglyLinux${__add_pp}.key-${conf[FWGUID]}"
	if [[ ! -e ${__keyfile} ]]; then
		echo -e "\r${BOLD}${RED}${__keyfile} Does not Exist.${NOR}\r" >&${__socat[1]}
		trap_term_systemd_daemon_cmd 1
	fi
	
	if chattr -i ${__keyfile} && rm -f ${__keyfile}; then
		echo -e "\r${BOLD}${GRN}Removed ${__keyfile}.${NOR}\r" >&${__socat[1]}
		trap_term_systemd_daemon_cmd 0
	else
		echo -e "\r${BOLD}${RED}Failed to Remove ${__keyfile}.${NOR}\r" >&${__socat[1]}
		trap_term_systemd_daemon_cmd 1
	fi

	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}
	do_log debug2 "${__myname} finished after $(do_timer ${__time_start})s"
}

daemon_control_del()
{
	# Remove and delete crypt from crypttab if requested.
	local __myname __time_start __confirm=0 __crypttab=0 __socat __passphrase="" 
	local __crypt_arr __del_crypt __del_dev __del_pp __del_trim __del_time __res=""
	do_control_init "del" "Removing Crypt"

	do_control_del_crypt
	__res=$?
	if [[ ${__res} -eq 2 ]]; then
		trap_term_systemd_daemon_cmd 0
	elif [[ ${__res} -ne 0 ]]; then
		do_log warning "${__myname} failed to process \"${msg[@]:4}\""
	fi
	if [[ ${__crypttab} -eq 1 && ( ${__res} -eq 1 || ${__confirm} -eq 1 ) ]]; then
		echo -ne "\r${BOLD}Continue Removing ${__del_crypt} from Crypttab (Y/n)?${NOR}" >&${__socat[1]}
		IFS= read -t${conf[USER_TIMEOUT]} -rsn1 -u ${__socat[0]} __res
		echo -e "${BOLD}${__res}${NOR}\r" >&${__socat[1]}
	fi
	if [[ ${__crypttab} -eq 1 && ( "${__res,,}" == "y" || "${__res}" == $'\r' || -z "${__res}" ) ]]; then
		sed -i "/^${__del_crypt}\\s/D" ${conf[CRYPTTAB]}
		kill -SIGHUP ${pid_daemon}
		echo -e "\r${BOLD}${GRN}Removed ${__del_dev} as ${__del_crypt} TRIM ${__del_trim} from Crypttab${NOR}\r" >&${__socat[1]}
	fi

	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}
	do_log debug2 "${__myname} finished after $(do_timer ${__time_start})s"
}

daemon_control_add()
{
	# Add the crypt received on the cryptdiskd command line and to crypttab if request.
	local __myname __time_start __confirm=0 __crypttab=0 __socat __passphrase="" __crypt_arr
	do_control_init "add" "Adding Crypt"
	
	local __add_crypt __add_dev __add_pp __add_trim __res=""
	if [[ ${__crypttab} -eq 0 ]]; then
		do_control_add_crypt || do_log debug "${__myname} failed to process \"${msg[@]:4}\""
	else
		do_control_add_crypttab || do_log debug "${__myname} failed to process \"${msg[@]:4}\""
	fi
	
	echo "control ${_pid_ctrl} finished" >${conf[FIFO]}
	do_log debug2 "${__myname} finished after $(do_timer ${__time_start})s"
}

do_control_init()
{
	trap 'trap_term_systemd_daemon_cmd' SIGINT SIGTERM

	# Initialize the control worker and connect to the requestor socket.
	local __pid_putkey __pid_logwriter=""
	__myname="daemon-$1 (${BASHPID}:${_pid_ctrl}):" __time_start=${EPOCHREALTIME:0:-3}
	
	# Check if socket exists first.
	if [[ ! -S ${_sock_ctrl} ]]; then
		do_log error "${__myname} ${_sock_ctrl} is not a socket, pocket rocket or a locket"
		trap_term_systemd_daemon_cmd 1
	fi
	# Start logwriter with dedicated logfile when LOGLEVEL=2 or = 4. When level = 4 redirect out stdout and stderr to the logwriter.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && __pid_logwriter="1>&6 2>&1"
		exec 6> >(logwriter control-$!.log) ${__pid_logwriter}
		__pid_logwriter=$!
	fi

	# Open the client socket.
	do_log debug "${__myname} connecting to ${_sock_ctrl}"
	coproc __socat { socat - UNIX-CONNECT:${_sock_ctrl}; }
	[[ ${conf[LOGLEVEL]} -ge 3 ]] && echo -e "\r${__myname} Connected for $2.\r\n" >&${__socat[1]}

	# Check the command line, it should contain crypt, device and passphrase and two options (confirm / crypttab) for add or del.
	if [[ "${_cmd}" == "put" ]]; then
		__confirm=${msg[$((${#msg[@]}-1))]}
	elif [[ "${_cmd}" == "smart" ]]; then
		__smartall=${msg[$((${#msg[@]}-2))]}
		__smarttest=${msg[$((${#msg[@]}-1))]}
	elif [[ "${_cmd}" =~ ^(add|del)$ ]]; then
		__confirm=${msg[$((${#msg[@]}-2))]}
		__crypttab=${msg[$((${#msg[@]}-1))]} 
	fi
}

do_control_del_crypt()
{
	# Check if the specified device is on the crypttab. If it's not we can continue removing, but not from tab (__t).
	local ___res="" ___t=2

	if ! do_xcrypt_fromtab __myname "${msg[5]}"; then
		echo -ne "\r${RED}${BOLD}${msg[5]} not on Crypttab, Continue Removing (y/N)? ${NOR}" >&${__socat[1]}
		IFS= read -t${conf[USER_TIMEOUT]} -rsn1 -u ${__socat[0]} ___res
		echo -e "${BOLD}${___res}${NOR}\r" >&${__socat[1]}
		[[ ! "${___res,,}" == "y" || -z "${___res,,}" || "${___res,,}" == $'\r' ]] && return 2
		__del_crypt="${msg[5]}" __del_dev="-" __del_pp="-"
	else
		__t=1 __del_crypt="${__crypt_arr[0]}" __del_dev="${__crypt_arr[1]}" __del_pp="${__crypt_arr[2]}"
	fi

	# Check if the crypt is active and/or on the active mount list.
	if ! dmsetup info "${__del_crypt}" >/dev/null 2>&1; then 
		echo -e "\r${RED}${BOLD}${__del_crypt} not Active.${NOR}\r" >&${__socat[1]}
	   	return ${__t}
	fi
	if [[ -z ${active_mnt[${__del_crypt}]} ]]; then
		echo -e "\r${BOLD}${YEL}${__del_crypt} is not on Active Mount List.${NOR}\r" >&${__socat[1]}
	else
		IFS=" " read -r __del_dev __del_pp __del_trim __del_time <<<"${active_mnt[${__del_crypt}]}"
	fi
	
	# Notify the daemon to remove the crypt and await the outcome.
	if do_control_notify_daemon "${__del_crypt}"; then
		echo -e "\r${BOLD}${GRN}Removed ${__del_dev##*/} as ${__del_crypt} Using ${__del_pp} TRIM ${__del_trim} Passphrase, Active Since $(do_timer date ${__del_time})${NOR}\r" >&${__socat[1]}
	   	return ${__t}
	else
		echo -e "\r${BOLD}${RED}Failed to Remove ${__del_dev##*/} as ${__del_crypt} Using ${__del_pp} TRIM ${__del_trim} Passphrase${NOR}\r" >&${__socat[1]}
	   	return ${__t}
	fi
}

do_control_add_crypt()
{
	# If the device should not be added to the crypttab it should be on the crypttab.
	do_xcrypt_fromtab __myname "${msg[5]}" || { echo -e "\r${RED}${BOLD}${msg[5]} not Found in Crypttab.${NOR}\r" >&${__socat[1]}; return 1; }
	
	# Check if the crypt is already active, and check if the device is present.
	__add_crypt="${__crypt_arr[0]}" __add_dev="${__crypt_arr[1]}" __add_pp="$(do_eval_pp ${__crypt_arr[2]})" __add_trim="${__crypt_arr[3]}"
	if dmsetup info "${__add_crypt}" >/dev/null 2>&1; then
		echo -e "\r${RED}${BOLD}${msg[5]} Already Active.${NOR}\r" >&${__socat[1]}
		return 1
	elif ! do_find_dev ${__add_dev} ${__add_crypt}; then
		echo -e "\r${RED}${BOLD}Device ${__add_dev} not Found in ${conf[BLOCKDEVSDIRS]}.${NOR}\r" >&${__socat[1]}
		return 1
	fi
	
	# Get the passphrase and notify the daemon or exit if no passphrase received.
	if do_control_read_passphrase; then
		if do_control_notify_daemon "${__add_crypt} ${__add_dev} ${__add_pp} ${__add_trim}"; then
			echo -e "\r${BOLD}${GRN}Mounted ${__add_dev} as ${__add_crypt} TRIM ${__add_trim} Using ${__add_pp} Passphrase${NOR}\r" >&${__socat[1]}
			return 0
		else
			echo -e "\r${BOLD}${RED}Failed to Mount ${__add_dev} as ${__add_crypt} TRIM ${__add_trim} Using ${__add_pp} Passphrase${NOR}\r" >&${__socat[1]}
			return 1
		fi
	else
		echo -e "\r${BOLD}${RED}No Passphrase Received, Bye Bye.${NOR}\r"
		return 1
	fi
}

do_control_add_crypttab()
{
	# Crypt should be added to crypttab. We should have a crypt, a dev and a passphrase name to use.
	__add_crypt="${msg[5]}" __add_dev="${msg[6]}" __add_pp="$(do_eval_pp "${msg[7]}")" __add_trim="${msg[8]}" __add=0 __res=""
	
	# Check if the crypt or device are already on the crypttab, error exit if so.
	if do_xcrypt_fromtab __myname "${__add_crypt}" || do_xcrypt_fromtab __myname "${__add_dev}"; then
		echo -e "\r${RED}${BOLD}${__add_crypt} or ${__add_dev} Already on Crypttab.${NOR}\r" >&${__socat[1]}
		return 1
	fi

	# Check which parameter is crypt and wich is dev. Lookup dev in blockdevsdirs, only one should match.
	if ! do_find_dev ${__add_dev} ${__add_crypt} && ! do_find_dev ${__add_crypt} ${__add_dev}; then
		# No match found for first parameter, try the second if still no match, error exit
		echo -e "\r${RED}${BOLD}Neither ${__add_crypt} or ${__add_dev} Is a Valid Block Device in \"${conf[BLOCKDEVSDIRS]}\" Bye Bye.${NOR}\r" >&${__socat[1]}
		return 1
	else
		# First parameter is a valid block device, check second, if also a match error exit.
		local __t="${__add_crypt}"
		if do_find_dev ${__t}; then
			echo -e "\r${RED}${BOLD}Both ${__add_crypt} and ${__add_dev} Are Valid Block Devices in \"${conf[BLOCKDEVSDIRS]}\" Bye Bye.${NOR}\r" >&${__socat[1]}
			return 1
		fi
	fi
	if [[ ${__add_trim} -eq 1 && "$(lsblk -rD ${__add_dev} |head -n2 |tail -n1 |cut -d " " -f3)" == "0B" ]]; then
		echo -ne "\r${YEL}${BOLD}${__add_dev} Does not Support TRIM.${NOR}\r"
		__add_trim=0
	fi

	# Check if the crypt is already active and ask to continue with adding to crypttab if so.
	if dmsetup info "${__add_crypt}" >/dev/null 2>&1; then
		if [[ ${__confirm} -eq 1 ]]; then
			__add=1
			echo -ne "\r${RED}${BOLD}${__add_crypt} Already Active, Add to Crypttab? (Y/n)${NOR}\r" >&${__socat[1]}
			IFS= read -t${conf[USER_TIMEOUT]} -rsn1 -u ${__socat[0]} __res
			echo -e "${BOLD}${__res}${NOR}\r" >&${__socat[1]}
		fi
	fi

	# Get the passphrase and notify the daemon, after response, add to crypttab.
	if [[ ${__add} -eq 1 ]] || do_control_read_passphrase; then
		if [[ ${__add} -eq 0 ]]; then
			do_control_notify_daemon "${__add_crypt} ${__add_dev} ${__add_pp} ${__add_trim}"
			if [[ $? -eq 0 ]]; then
				echo -e "\r${BOLD}${GRN}Mounted ${__add_dev} as ${__add_crypt} Using ${__add_pp} TRIM ${__add_trim} Passphrase${NOR}\r" >&${__socat[1]}
			else
				echo -e "\r${BOLD}${RED}Failed to Mount ${__add_dev} as ${__add_crypt} Using ${__add_pp} TRIM ${__add_trim} Passphrase${NOR}\r" >&${__socat[1]}
			fi
		fi
		# If the crypt failed to mount ask for confirmation to still add it to crypttab.
		if [[ ( ${__r} -ne 0 || ${__confirm} -eq 1 ) && ${__add} -eq 0 ]]; then
			echo -ne "\r${BOLD}Add ${__add_dev} as ${__add_crypt} Passphrase ${__add_pp} TRIM ${__add_trim} to Crypttab (Y/n)?${NOR}" >&${__socat[1]}
			IFS= read -t${conf[USER_TIMEOUT]} -rsn1 -u ${__socat[0]} __res
			echo -e "${BOLD}${___res}${NOR}\r" >&${__socat[1]}
		fi
		if [[ "${__res,,}" == "y" || "${__res}" == $'\r' || -z "${__res}" ]]; then
			# Add the crypt to the crypttab and send reload signal to daemon.
			echo -e "${__add_crypt}\t${__add_dev##*/}\t${__add_pp}\t${__add_trim}" >> ${conf[CRYPTTAB]}
			echo -e "\r${BOLD}${GRN}Added ${__add_dev} as ${__add_crypt} Passphrase ${__add_pp} TRIM ${__add_trim} to Crypttab${NOR}\r" >&${__socat[1]}
			kill -SIGHUP ${pid_daemon}
		fi
		return 0
	else
		echo -e "\r${BOLD}${RED}No Passphrase Received, Bye Bye.${NOR}\r"
		return 1
	fi
}

do_control_read_passphrase()
{
	# Ask to get passphrase from network, if not cached, or query the user for the passphrase.
	local ___key="$(keyctl request user "${__add_pp}")" ___res="" ___fd_ppwrk ___srv
	if [[ -n "${___key}" ]]; then
		# Passphrase is still cached, use it and notify the daemon about the crypt.
		__passphrase="$(keyctl pipe "${___key}")"
		echo -e "\r${BOLD}${GREEN}Found Cached ${__add_pp} Passphrase for ${__add_crypt}${NOR}\r" >&${__socat[1]}
		return 0
	fi

	# If confirm option is speciefied ask to retreive passphrase from boot servers.
	if [[ ${__confirm} -eq 1 ]]; then
		echo -ne "\r${BOLD}${__add_pp} Passphrase Not Cached, Get Passphrase from Boot Servers (Y/n)?${NOR}" >&${__socat[1]}
		IFS= read -t${conf[USER_TIMEOUT]} -rsn1 -u ${__socat[0]} ___res
		echo -e "${BOLD}${___res}${NOR}\r" >&${__socat[1]}
	fi

	# Get passphrase from bootservers, we can use the passphrase ssh worker for this.
	if [[ "${___res,,}" == "y" || "${___res}" == $'\r' || -z "${___res}" ]]; then
		echo -e "\r${BOLD}Getting Passphrase from Boot Servers: ${NOR}${YEL}${bootconf[BOOTSERVERS]}${NOR}\r" >&${__socat[1]}
		[[ ${conf[LOGLEVEL]} -le 2 ]] && exec {___fd_ppwrk}< <(ppwrk_net_passphrase 4>&1- 1>/dev/null 2>&1)
		[[ ${conf[LOGLEVEL]} -gt 2 ]] && exec {___fd_ppwrk}< <(ppwrk_net_passphrase 4>&1- 1>&6 2>&1)
		IFS="|" read -t${conf[USER_TIMEOUT]} -ru ${___fd_ppwrk} ___srv __passphrase
		__passphrase="${__passphrase:1}"
		if [[ ! -z "${__passphrase}" && $(do_check_passphrase)$? -ne 1 ]]; then
			echo -e "\r${BOLD}${GRN}Got ${__add_pp} Passphrase for ${__add_crypt} from ${___srv}${NOR}\r" >&${__socat[1]}
			return 0
		else
			echo -e "\r${RED}${BOLD}Failed to Get ${__add_pp} Passphrase for ${__add_crypt} from Boot Servers${NOR}\r" >&${__socat[1]}
		fi
	fi

	# Query the user for the passphrase.
	echo -ne "\r${BOLD}Enter ${__add_pp} passphrase: ${NOR}" >&${__socat[1]}
	until do_control_ask_passphrase; do
		case $? in
			1)
				echo -ne "\r${BOLD}Incorrect ${__add_pp} Passphrase, Retry: ${NOR}" >&${__socat[1]}
				;;
			2)
				echo -ne "\r${BOLD}Creating Keyfile, Confirm ${__add_pp} Passphrase: ${NOR}" >&${__socat[1]}
				__passphrase=""
				do_control_ask_passphrase rmkey && break
				echo -ne "\r${BOLD}Passphrases do not Match. Enter ${__add_pp} Passphrase: ${NOR}" >&${__socat[1]}
				;;
			3)
				echo -e "${BOLD}${RED}TIMEOUT${NOR}\r" >&${__socat[1]}
				return 1
				;;
		esac
		__passphrase=""
	done

	# We will have a passphrase by now.
	return 0
}

do_control_ask_passphrase()
{
	local REPLY="" DEL="$(printf "\x7F")"
	until [[ "${REPLY}" == $'\r' ]]; do
	   	read -t${conf[USER_TIMEOUT]} -rsn1 -u ${__socat[0]} REPLY
		[[ "$?" -gt 128 ]] && return 3
		[[ -z "${REPLY}" ]] && return 1
		if [[ "${REPLY}" == "${DEL}" ]]; then
			if [[ "${#__passphrase}" -ne 0 ]]; then
				echo -ne "\b \b" >&${__socat[1]}
				__passphrase="${__passphrase::-1}"
			fi
			continue
		fi
		if [[ ! "${REPLY}" == $'\r' ]]; then
			__passphrase+="${REPLY}"
			echo -n "*" >&${__socat[1]}
		fi
	done
	echo -e "\r" >&${__socat[1]}
	return $(do_check_passphrase $1)$?
}

do_control_notify_daemon()
{
	# Notify the daemon to mount the crypt and relay status.
	echo "notify ${_pid_ctrl} ${_cmd} $@" >${conf[FIFO]}

	if [[ ! -z ${__passphrase} && ! -z ${__add_pp} ]]; then
		put_key & 
		__pid_putkey=$!
	fi
	local __res; IFS= read -t${conf[USER_TIMEOUT]} -r __res
	# Check response from daemon and report status of mount.
	[[ "${__res,,}" == "ok" ]] && return 0 || return 1
}

# [END OF DAEMON CONTROL FUNCTIONS]

# [BEGIN OF DAEMON READER FUNCTIONS]

do_daemon_reader()
{
	# Main daemon process received meesage from reader or passphrase worker.
	local _time_start=${EPOCHREALTIME:0:-3}
	time_active=$(do_timer ${time_start})

	case ${msg[2]} in
		started|control|notify)
			do_daemon_${msg[2]};;
		active)
			reader_alive=0
			do_log debug "${myname} reader (PID: ${pid_reader}) ping received";;
		remove)
			do_daemon_unmount_crypt "${msg[3]}";;
		add)
			do_daemon_mount_crypt "${msg[3]}" "${msg[4]}" "${msg[5]}" "${msg[6]}";;
		cached)
			cached_pp+="${msg[3]} ";;
		reload)
			[[ ${confok} -lt 2 ]] && do_log warning "${myname} incorrect reload request from reader";
			[[ -e /proc/self/fd/${fd_reader} ]] && exec {fd_reader}>&-
			unset pid_reader
			do_daemon_cleanup;;
		*)	
			do_log debug "${myname} received invalid message from reader \"${msg[@]}\"";;
	esac

	do_log debug2 "${myname} processing \"${msg[@]}\" took $(do_timer ${_time_start})s total"
	return 0
}

do_daemon_started()
{
	# Process the start status, sent by the reader and our own.
	[[ ${start_status} -eq 0 && ${msg[4]} -eq 0 ]] && start_status=0
	[[ ${start_status} -eq 2 || ${msg[4]} -eq 2 ]] && start_status=2
	[[ ${start_status} -eq 1 || ${msg[4]} -eq 1 ]] && start_status=1

	# Set the new starting status, will need to wait for active workers, or notify systemd we are started
	case ${msg[3]} in
		0)
			# Reader has completed startup succesfully
			do_log debug "${myname} reader has started succesfully"
			do_daemon_notify_systemd
			do_daemon_cleanup
			starting=0;;
		2)
			# We are in inital startup. The reader notifies us the queue is empty and is still waiting for passphrases..
			starting=2
			do_log debug "${myname} reader has processed queue and is awaiting passphrases";;
		*)
			# Incorrect
			do_log warning "${myname} received incorrect start status from reader"
	esac
}

do_daemon_notify()
{
	local _pid_ctrl=${msg[3]} _cmd="${msg[4],,}" _myname="daemon-notify (${BASHPID}):" _time_start=${EPOCHREALTIME:0:-3}
	local _sock_ctrl="${conf[CRYPTDISKSDDIR]}/${MYNAME}-${_pid_ctrl}.sock"
	do_log debug "${_myname} processing \"${msg[@]:4}\""

	# Process a command received from a control sub-process and notify about the result.
	case ${_cmd} in
		add)
			if do_daemon_mount_crypt ${msg[5]} ${msg[6]} ${msg[7]} ${msg[8]}; then
				echo "OK" >&${fd_ctrl[${_pid_ctrl}]}
			else
				echo "FAIL" >&${fd_ctrl[${_pid_ctrl}]}
			fi
			do_log debug "${myname} active mounts: ${!active_mnt[@]}" ;;
		del)
			if do_daemon_unmount_crypt ${msg[5]}; then
				echo "OK" >&${fd_ctrl[${_pid_ctrl}]}
			else
				echo "FAIL" >&${fd_ctrl[${_pid_ctrl}]}
			fi
			do_log debug "${myname} active mounts: ${!active_mnt[@]}" ;;
		*)
			do_log debug "${_myname} received invalid notify command \"${msg[@]:2}\"" ;;
	esac
	do_log debug2 "${_myname} processing \"${msg[@]:4}\" took $(do_timer ${_time_start})s"
}

do_daemon_control()
{
	# Daemon received control command from cryptdisksd command line.
	local _pid_ctrl=${msg[3]} _cmd="${msg[4],,}"; local _sock_ctrl="${conf[CRYPTDISKSDDIR]}/${MYNAME}-${_pid_ctrl}.sock"
	local _myname="daemon-control (${BASHPID}):" _time_start=${EPOCHREALTIME:0:-3}
	do_log debug "${_myname} processing \"${msg[@]:4}\""

	# Set the FD redirections as per the loglevel.	
	case ${conf[LOGLEVEL]} in
		0|1|3)
			local _fd_r="1>/dev/null 2>&1" ;;
		2|4)
			local _fd_r="1>&6 2>&1" ;;
	esac

	# Process the command received and start the according control worker process.
	case ${_cmd} in
		finished)
			do_log debug "${_myname} control connection (PID: ${pid_ctrl[${_pid_ctrl}]}) finished"
			exec {fd_ctrl[${_pid_ctrl}]}>&-
			unset pid_ctrl[${_pid_ctrl}] fd_ctrl[${_pid_ctrl}] time_ctrl[${_pid_ctrl}]
			[[ -e ${_sock_ctrl} ]] && rm -f ${_sock_ctrl}
			;;
		add|del|put|rmkey|status|smart|erase)
			exec {fd_ctrl[${_pid_ctrl}]}> >(daemon_control_${_cmd} "$fd_r}") 
			pid_ctrl[${_pid_ctrl}]=$!
			time_ctrl[${_pid_ctrl}]=${EPOCHREALTIME:0:-3} 
			;;
		*)
			do_log debug "${_myname} invalid control command \"${msg[@]:4}\""
			;;
	esac
	
	do_log debug2 "${_myname} processing \"${msg[@]:4}\" took $(do_timer ${_time_start})s"
}

do_daemon_mount_crypt()
{
	local _add_dev="$1" _add_crypt="$2" _add_pp="$3" _add_trim="$5" _add_time=${EPOCHREALTIME:0:-3}
	do_log debug "${myname} mounting ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} with ${_add_pp} passphrase"

	local _key _passphrase
	# The passphrase should be cached by now, error exit if not.
	__key="$(keyctl request user "${_add_pp}")"
	if [[ -z "${_key}" ]]; then
		do_log error "${myname} passphrase ${_add_pp} not cached!" 
		return 1
	fi
	_passphrase="$(keyctl pipe ${_key})"

	# First check if the crypt is already mounted. If so, check if it's on the active list and add if not.	
	if dmsetup info "${_add_crypt}" >/dev/null 2>&1; then
		[[ "$(lsblk -rD /dev/mapper/${_add_crypt} |head -n2 |tail -n1 |cut -d " " -f3)" == "0B" ]] && _add_trim=0 || _add_trim=1
		if [[ -z "${active_mnt[${_add_crypt}]}" ]]; then
			active_mnt[${_add_crypt}]="${_add_dev} ${_add_pp} ${_add_trim} ${_add_time}"
			do_log debug "${myname} added ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} passphrase ${_add_pp} to active list"
			return 0
		else
			IFS=" " read -r _add_dev _add_pp _add_trim _add_time <<< "${active_mnt[${_add_crypt}]}"
			do_log info "${myname} ${_add_dev} already active as ${_add_crypt} TRIM ${_add_trim} since $(do_timer date ${_add_time})"
			return 1
		fi
	else
		if [[ "$(lsblk -rD ${_add_dev} |head -n2 |tail -n1 |cut -d " " -f3)" == "0B" ]]; then
		       	_add_trim=0
			do_log info "${myname} requested TRIM for ${add_crypt} but device ${_add_dev} does not support it"
		fi
		if cryptsetup open --type plain $([[ ${_add_trim} -eq 1 ]] && echo "--allow-discards") "${_add_dev}" "${_add_crypt}" <<<"${_passphrase}"; then
			# Mounted, add to active list.
			do_log info "${myname} mounted ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} passphrase ${_dd_pp}"
			do_log debug2 "${myname} mounting ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} passphrase \"${_passphrase}\" took $(do_timer ${_add_time})s"
			active_mnt[${_add_crypt}]="${_add_dev} ${_add_pp} ${_add_trim} ${_add_time}"
			return 0
		else
			do_log error "${myname} error mounting ${_add_dev} as ${_add_crypt} TRIM ${_add_trim} after $(do_timer ${_add_time})s"
			status=1
			return 1
		fi
	fi
}

do_daemon_unmount_crypt()
{
	local __del_crypt="$1" __time_start=${EPOCHREALTIME:0:-3}
	if dmsetup info "${__del_crypt}" >/dev/null 2>&1; then
		local __del_dev __del_pp _del_time 
		IFS=" " read -r __del_dev __del_pp __del_trim __del_time <<<"${active_mnt[${__del_crypt}]}"
		if kpartx -d /dev/mapper/${__del_crypt} && cryptsetup remove "${__del_crypt}"; then
			do_log info "${myname} removed ${__del_dev} as ${__del_crypt} TRIM ${__del_trim} passphrase ${__del_pp} mounted since $(do_timer date ${__del_time})"
			do_log debug2 "${myname} removing ${__del_crypt} took $(do_timer ${__time_start})s"
			unset active_mnt[${__del_crypt}]
			return 0
		else
			do_log warning "${myname} failed to remove ${__del_dev} as ${__del_crypt} TRIM ${__del_trim} passphrase ${__del_pp} mounted since $(do_timer date ${__del_time})"
			status=2
			return 2
		fi
	else
		do_log debug "${myname} crypt ${__del_crypt} not present, skipping"
		unset active_mnt[${__del_crypt}]
		return 0
	fi
}

# [END OF DAEMON READER FUNCTIONS]

# [BEGIN OF DAEMON & READER SHARED FUNCTIONS]

do_xcrypt_fromtab()
{
	# Extract the line for the device received in the udev command from the crypttab into __crypt_arr array.
	# Element 1 = cryptdisk name
	# Element 2 = cryptdisk block device
	# Element 3 = passphrase
	# Element 4 = TRIM
	local ___i
	for ((___i=2;___i<=$#;___i++)); do
		__crypt_arr=($(grep -iE "(^|\s)${!___i}\s" <<<"${crypttab}")) 
		[[ "${#__crypt_arr[@]}" -eq 3 ]] && __crypt_arr[3]=0
		if [[ "${#__crypt_arr[@]}" -eq 0 ]]; then
			do_log debug "${!1} device ${!___i} not found in crypttab"
		elif [[ "${#__crypt_arr[@]}" -ne 4 ]]; then
			do_log warning "${!1} incorrect crypttab entry ${__crypt_arr[@]}"
			_status=2
		else
			[[ "${__crypt_arr[3]}" == "1" || "${__crypt_arr[3],,}" == "y" || "${__crypt_arr[3],,}" == "yes" ]] && __crypt_arr[3]=1 || __crypt_arr[3]=0
			return 0
		fi
	done
	return 1
}

do_eval_pp()
{
	# Evaluate the passphrase and prepend cryptdisks: or make system:master. 
  	if [[ ${1,,} =~ ^(1|master|system|system:master)$ ]]; then
   		echo "system:master"
	elif [[ ! ${1,,} =~ ^cryptdisks: ]]; then
		echo "cryptdisks:${1,,}"
	else 
		echo "${1,,}"
	fi
}

do_find_dev()
{
	local __blockdevdir
	for __blockdevdir in ${conf[BLOCKDEVSDIRS]}; do
		if [[ ! -b ${__blockdevdir}/$1 ]]; then
			do_log debug2 "${__myname} ${__blockdevdir}/$1 not a valid block device"
		else
			do_log debug "${__myname} found ${__blockdevdir}/$1 for $2"
			__add_dev="${__blockdevdir}/$1"
			__add_crypt="$2"
			return 0
		fi
	done
	return 1
}

do_check_passphrase()
{
	# Check the received passphrase against the stored key in firmware. Write key if it doesn't exist.
	if [ -s ${conf[FWDIR]}/UglyLinux${__add_pp}.key-${conf[FWGUID]} ]; then
		if  $(cat ${conf[FWDIR]}/UglyLinux${__add_pp}.key-${conf[FWGUID]} | tail -c +5 | openssl aes-256-cbc -d -salt -pbkdf2 -in - -out /dev/null -k "${__passphrase}"); then
			do_log debug "${__myname} passphrase check ok"
			return 0
		else
			do_log debug "${__myname} passphrase check fail"
			if [[ "$1" == "rmkey" ]]; then 
				chattr -i ${conf[FWDIR]}/UglyLinux${__add_pp}.key-${conf[FWGUID]} 
				rm -f ${conf[FWDIR]}/UglyLinux${__add_pp}.key-${conf[FWGUID]}
			fi
			return 1
		fi
	else
		do_write_keyfile || return 3
		do_log debug "${__myname} passphrase not checked"
		return 2
	fi
}

do_write_keyfile()
{
	# Write a keyfile for key received to firmware.
	if ! printf "\x07\x00\x00\x00\x00" > ${conf[FWDIR]}/UglyLinux${__add_pp}.key-${conf[FWGUID]}; then
		do_log error "${__myname} error creating ${conf[FWDIR]}/UglyLinux${__add_pp}.key-${conf[FWGUID]}"
	elif ! head -c256 /dev/urandom |openssl aes-256-cbc -e -salt -pbkdf2 -in - -out ${conf[CRYPTDISKSDDIR]}/${__add_pp}.key -k "${__passphrase}"; then
		do_log error "${__myname} error creating ${conf[CRYPTDISKSDDIR]}/${__add_pp}.key"
	elif ! efivar -n ${conf[FWGUID]}-UglyLinux${__add_pp}.key -w -f ${conf[CRYPTDISKSDDIR]}/${__add_pp}.key; then
		do_log error "${__myname} error writing ${conf[FWDIR]}/UglyLinux${__add_pp}.key-${conf[FWGUID]}"
	else
		do_log debug "${__myname} wrote ${conf[FWDIR]}/UglyLinux${__add_pp}.key-${conf[FWGUID]}"
	fi
	rm -f ${conf[CRYPTDISKSDDIR]}/${__add_pp}.key
}

do_cache_pp()
{
	local ___key=""
	
	# Cache if the passphrase is already cached.
	if [[ ${_pp_cached[${__add_pp}]} -eq 1 ]]; then
		do_log warning "${__myname} ${__add_pp} passphrase already cached"
		return
	fi
	if [[ ! -z "${__passphrase}" ]]; then
		if [[ "$(keyctl request user "${__add_pp}")" == "" ]]; then
			___key="$(keyctl padd user "${__add_pp}" @s <<<"${__passphrase}")"
		else
			do_log warning "${__myname} ${__add_pp} passphrase was already cached, adding to list"
		fi
	fi
	if [[ -z "${___key}" ]]; then
		do_log warning "${__myname} failed to cache ${__add_pp} passphrase"
		return
	fi
	_pp_cached[${__add_pp}]=1
	do_reader_notify_daemon "cached ${__add_pp}"

	do_log debug "${__myname} cached ${__add_pp} passphrase indefinitely"
}

trap_term_put_key()
{
	trap 'do_log warning "${___myname} unclean exit after $(do_timer ${___time_start})s"; exit 1' SIGINT SIGTERM

	if [[ ! -z "${!___pid_ssh[@]}" ]]; then
		for ___i in ${!___pid_ssh[@]}; do
			if [[ "$(cat /proc/${___pid_ssh[${___i}]}/comm 2>/dev/null)" == "ssh" ]]; then
				kill -SIGKILL ${___pid_ssh[${___i}]}
				do_log debug2 "${___myname} killed ssh (PID: ${___pid_ssh[${___i}]})"
				unset ___fd_ssh[${___i}] ___pid_ssh[${___i}]
			fi
		done
	fi

	do_log debug2 "${___myname} terminating after $(do_timer ${___time_start})s"
	exit 0
}

put_key()
{
	trap 'trap_term_put_key' SIGINT SIGTERM

	# Put the key to the the boot servers one by one and log status.
	local ___i ___res ___time_start=${EPOCHREALTIME:0:-3} ___myname="passphrase_put:${__add_pp} (${BASHPID}):" ___to_start ___to_stop
	declare -A ___pid_ssh ___fd_ssh

	do_log debug "${___myname} putting ${__add_pp} to boot servers"

	# When starting wait for network before trying to put keys to servers.
	if [[ ${starting} -ne 0 ]]; then
		___to_start=${EPOCHREALTIME:0:-3}
		___to_stop=$(do_timer ${___to_start})
		until [[ ${___to_Stop} -ge ${conf[START_TIMEOUT]} && $(NOTIFY_SOCKET= systemctl status network-online.target >/dev/null 2>&1)$? -ne 3 ]]; do
			sleep ${conf[QUEUE_TIMEOUT]} &
			wait $!
			___to_stop=$(do_timer ${___to_start})
		done
	fi

	# For every boot server start an ssh process to put the key in the background.
	for ___i in ${bootconf[BOOTSERVERS]}; do
		exec {___fd_ssh[${___i}]}< <(ssh -i ${CONFDIR}/${bootconf[BOOTUSERKEY]} -o UserKnownHostsFile=${CONFDIR}/${bootconf[BOOTSERVERKEYS]} ${bootconf[BOOTUSER]}@${___i} "PUT "${__add_pp}" "${__passphrase}"")
		___pid_ssh[${___i}]=$!
	done

	# Until timeout is reached check all the fd for the status of the put key commands.
	___to_start=${EPOCHREALTIME:0:-3}
	___to_stop=$(do_timer ${___to_start})
	while [[ ! -z "${!___pid_ssh[@]}" && ${___to_stop%%.*} -lt ${conf[PP_TIMEOUT]} ]]; do  
		for ___i in ${bootconf[BOOTSERVERS]}; do
			if read -t0 -u ${___fd_ssh[${___i}]}; then
				# SSH put key finished read status.
				read -u ${___fd_ssh[${___i}]} ___res
				if [[ "${___res,,}" == "ok" ]]; then
					do_log debug "${__myname} put ${__add_pp} key on ${___i} for ${bootconf[BOOTUSER]} succeeded"
				elif [[ "${___res,,}" == "same" ]]; then
					do_log info "${__myname} put ${__add_pp} key on ${___i} for ${bootconf[BOOTUSER]} equal"
				else
					do_log warning "${__myname} put ${__add_pp} key on ${___i} for ${bootconf[BOOTUSER]} failed"
				fi
			fi
			unset ___fd_ssh[${___i}] ___pid_ssh[${___i}]
		done
		sleep ${conf[QUEUE_TIMEOUT]} &
		wait $!
		___to_stop=$(do_timer ${___to_start})
	done
	# Check for connections that timed out.
	if [[ ! -z "${!___pid_ssh[@]}" ]]; then
		for ___i in ${!___pid_ssh[@]}; do
			do_log debug "${__myname} put ${__add_pp} key on ${___i} for ${bootconf[BOOTUSER]} timeout"
			[[ "$(cat /proc/${____pid_ssh[${___i}]}/comm 2>/dev/null)" == "ssh" ]] && kill -9 ${___pid_ssh[${___i}]}
			do_log debug2 "${___myname} killed ssh (PID: ${___pid_ssh[${___i}]})"
			unset ___fd_ssh[${___i}] ___pid_ssh[${___i}]
		done
	fi

	do_log debug2 "${___myname} finished after $(do_timer ${___time_start})s"
}

# [END OF DAEMON & READER SHARED FUNCTIONS]

# [BEGIN OF UDEV QUEUE READER FUNCTIONS

trap_term_reader()
{
	trap 'do_log warning "${_myname} unclean exit after $(do_timer ${_time_start})s"; exit 1' SIGINT SIGTERM

	# Reader received SIGTERM or SIGINT. See if we have any workers to kill and remove the queue.
	_time_active="$(do_timer ${_time_start})"
	do_log debug2 "${_myname} terminating after ${_time_active}s"

	# Kill all active passphrase workers.
	local _pp
	for _pp in ${!_pid_ppwrk[@]}; do
		if [[ ! -z "${_pid_ppwrk[${_pp}]}" && "$(cat /proc/${_pid_ppwrk[${_pp}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_ppwrk[${_pp}]}
			wait ${_pid_ppwrk[${_pp}]}
			do_log debug2 "${_myname} killed passphrase worker for ${_pp} (PID: ${_pid_ppwrk[${_pp}]})"
		fi
	done
	for _pp in ${!_pid_putkey[@]}; do
		if [[ ! -z "${_pid_putkey[${_pp}]}" && "$(cat /proc/${_pid_putkey[${_pp}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_putkey[${_pp}]}
			wait ${_pid_putkey[${_pp}]}
			do_log debug2 "${_myname} killed putkey worker for ${_pp} (PID: ${_pid_putkey[${_pp}]})"
		fi
	done
	for __pp in ${!_pid_shell[@]}; do
		if [[ "$(cat /proc/${_pid_shell[${__pp}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
			kill -SIGTERM ${_pid_shell[${__pp}]}
			wait ${_pid_shell[${__pp}]}
		fi
	done

	# If we are in startup we should not be terminated, exit with error. Otherwise exit with current status.
	if [[ "${_starting}" -ne 0 ]]; then
		do_log error "${_myname} terminated while in startup"
	fi
	if [[ "$(cat /proc/${_pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${_pid_logwriter}
		wait ${_pid_logwriter}
	fi

	exit 0
}

trap_hup_reader()
{
	# Received reload request from systemd. Reload the config when not handling command and no active workers.
	_time_active=$(do_timer ${_time_start})
	if [[ ${_starting} -eq 0 && ${_confok} -eq 0 ]]; then
		do_log warning "${_myname} received SIGHUP, reload config asap"
		if [[ -z "${_cmd}" ]]; then
			do_reader_cleanup
			if [[ -z "${!_waiting_mnt[@]}" ]]; then
				do_reader_notify_daemon "reload"
				trap_term_reader
			fi
		fi
		_confok=1
	elif [[ ${_starting} -ne 0 && ${_time_active:0:-4} -ge ${conf[START_TIMEOUT]} ]]; then
		do_log warning "${_myname} start timeout reached, running cleanup"
		_starting=0
		do_reader_cleanup
	fi
}

udev_reader()
{
	trap 'trap_term_reader' SIGINT SIGTERM
	trap 'trap_hup_reader' SIGHUP

	# The reader process will read commands from the queue. When command is read some atomical stuff needs to be done
	# At the very least we should check for any running password workers, start worker process and keep track of them all.
	# Just like the daemon process the reader will run a cleanup timer and do cleanup every conf[CLEANUP_TIMER].
	local _pid_reader=${BASHPID} _myname="reader (${BASHPID}):" _time_start=${EPOCHREALTIME:0:-3} _time_active=0.000
 	local _nr_cmds=1 _start_status=0 _cleanup=0.000 _pid_logwriter="" _key="" _fd_fifo _pp _confok=0 _starting=${starting}
	declare -A _pid_ppwrk _time_ppwrk _pp_cached _pid_putkey _pid_shell _waiting_mnt
	
	do_log info "${_myname} initializing"

	# If we are reloaded check for already cached passphrases.
	if [[ ${_starting} -eq 0 && ! -z "${cached_pp}" ]]; then
		for _pp in ${cached_pp}; do _pp_cached[${_pp}]=1; done
	fi

	# Start logwriter with dedicated logfile when LOGLEVEL=2 or = 4. When level = 4 redirect out stdout and stderr to the logwriter.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && _pid_logwriter="1>&6 2>&1"
		exec 6> >(logwriter reader-${_pid_reader}.log ${_pid_logwriter})
		_pid_logwriter=$!
	fi

	# If we are booting up the master passphrase may be in the user keyring, revoke and cache in session keyring.
	if [[ ! -z "${_key}" && ${_starting} -ne 0 && ${_pp_cached[system:master]} -ne 1 ]]; then
		do_log debug "${_myname} removed system:master key from user keyring"
		local _key="$(keyctl request user "system:master")"
		local __passphrase="$(keyctl pipe "${_key}")" __add_pp="system:master" __myname="${_myname}"
		keyctl revoke "${_key}"
		do_cache_pp
		put_key &
		_pid_putkey[${__add_pp}]=$!
	fi
	
	exec {_fd_fifo}<>${conf[FIFO]}
	while true; do
		# Before returning to waiting for new command, set the status to 0.
		local _status=0 _read_to _cmd=()

		# Evaluate process timeouts (always evaluate against daemon start time).
		do_reader_timeout
        
		# Start reading from the queue.
		IFS=" " read ${_read_to} -ru${_fd_fifo} -a _cmd
		local _res=$?

		if [[ ${_res} -eq 142 ]]; then
			# Read timed out. Set the starting status if we are starting up, or run cleanup.
			# Cleanup will start after conf[START_TIMEOUT] to give all initial workers the chance to finish.
			case ${_starting} in
				0)	
					do_log debug2 "${_myname} waking up from slumber";;
				1)	
					# Initial queue empty.
					if [[ -z "${!_waiting_mnt[@]}" ]]; then
						# If there are no mounts wainting for passphrase we are started.
						_starting=0
						do_reader_cleanup
					else
						_starting=2
					fi
					do_reader_notify_daemon "started ${_starting} ${_start_status}";;
			esac
			do_log debug2 "${_myname} running since $(do_timer date ${_time_start})"
			continue
		elif [[ ${_res} -gt 128 ]]; then
			# Should not happen, only if we received signal during read.
			do_log debug "${_myname} read result ${_res} may have been trapped"
			[[ ${_cleanup} -eq 0 ]] && do_reader_cleanup
		elif [[ ${_res} -ne 0 ]]; then
			do_log error "${__myname} read error, terminating after $(do_timer ${_time_start})s"
			do_reader_notify_daemon "reload"
			trap_term_reader
		fi

		if [[ -z "${_cmd[@]}" ]]; then
			do_log error "${_myname} reached EOF on queue, terminating"
			do_reader_notify_daemon "reload"
			trap_term_reader
		fi

		do_log debug "${_myname} new command received \"${_cmd[@]}\""
		do_reader_fifo

		# Done processing, calculate time spent and if we are still staring check against time-out. Evaluate the start status..
		if [[ ${_starting} -ne 0 ]]; then
			[[ ${_status} -eq 1 ]] && _start_status=1
			[[ ${_start_status} -eq 0 && ${_status} -eq 2 ]] && _start_status=2
		fi
		_nr_cmds=$((_nr_cmds+1))
		do_log debug2 "${_myname} running since $(do_timer date ${_time_start})"
	done

	# We should never get here, exit with error if we do.
	_time_active="$(do_timer ${time_start})"
	do_log error "${_myname} terminated unexpectedly after ${time_active}s"
	trap_term_reader
}

do_reader_timeout()
{
	# If we are starting up, read time-out when initial queue is empty so we can notify parent.
	# If we are in normal op, keep cleanup timer (60secs).
	time_active=$(do_timer ${time_start})
	
	# Rceived SIGHUP. Do a config reload (restart the reader), when no active workers.
	if [[ ${_starting} -eq 0 && ${_confok} -eq 1 && -z "${!_active_mnt[@]}" ]]; then
		do_reader_notify_daemon "reload"
		trap_term_reader
	fi

	# Evaluate the queue read timeout, to see at which point in time we are.
	case ${_starting} in
		0)
			# Evaluate cleanup timer against daemon active time
			if [[ ${_confok} -eq 1 ]] || [[ ${time_active:0:-4} -gt $((${_cleanup:0:-4}+${conf[CLEANUP_TIMER]}-${conf[QUEUE_TIMEOUT]})) ]] || [[ ${_res} -eq 142 && ${_read_to##* } -gt $((conf[CLEANUP_TIMER]/2)) ]]; then
				do_reader_cleanup
			fi
			if [[ ${_confok} -eq 1 ]]; then
				# If we need to reloud config use a short timeout.		
				_read_to="-t${conf[QUEUE_TIMEOUT]}"
			else
				_read_to="-t$(((${conf[CLEANUP_TIMER]}+${conf[QUEUE_TIMEOUT]})-((${time_active:0:-4}+${conf[CLEANUP_TIMER]}/2)%${conf[CLEANUP_TIMER]})))"
			fi;;
		1|2)
			# Make sure the read timeout is never 0 as this will complicate things (read will not read if to = 0).
			_read_to="-t${conf[QUEUE_TIMEOUT]}";;
	esac
}

do_reader_fifo()
{
	local __myname="${_myname} ${_nr_cmds} -" __time_start="${EPOCHREALTIME:0:-3}" __crypt_arr
	local __time_active=0.000 __msg="" __cmd="${_cmd[0],,}" __crypt __dev __trim __time

	# We have a command to process so start processing. First split up the command into an array.
	do_log debug "${__myname} processing \"${_cmd}\"" 

	# Parse the command, the first element in the array is the command itself, the other elements the arguments to the command.
	# From UDEV we will receive add and remove commands with one paramter only, the disk.
	case ${__cmd} in
		add|change)
			do_reader_add_crypt;;
		remove)
			do_xcrypt_fromtab __myname "${_cmd[@]:1}" && do_reader_notify_daemon "remove ${__crypt_arr[0]}";;
		passphrase)
			while IFS=" " read -r __crypt __dev __trim __time; do 
				do_reader_notify_daemon "add ${__add_crypt} ${__add_dev} ${__add_pp} ${__add_trim}"
			done <<<"${_waiting_mnt[${_cmd[1]}]}"
			unset _waiting_mnt[${_cmd[1]}];;
		control|notify)
			case ${_cmd[2]} in
				status|smart|erase|finished|add|del|put|rmkey)
					do_reader_notify_daemon "${_cmd[@]}";;
				shell) 
					reader_control_shell &
					_pid_shell[${_cmd[1]}]=$!;;
				*) 
				do_log debug "${__myname} received invalid control command \"${_cmd[@]:2}\"";;
			esac;;
		*)
			do_log debug "${__myname} received invalid command: \"${_cmd[@]}\"";;
	esac
	__time_active="$(do_timer ${__time_start})"
	do_log debug2 "${__myname} processing command \"${_cmd[@]}\" took ${__time_active}s total"
}

reader_control_shell()
{
	trap 'trap_term_systemd_daemon_cmd' SIGINT SIGTERM 

	# Open a debug shell, will run under root so be careful with this.
	local __myname __time_start __socat __pid_logwriter="" __pid_ctrl="${_cmd[1]}" __sock_ctrl="${conf[CRYPTDISKSDDIR]}/${MYNAME}-${_cmd[1]}.sock"
	__myname="reader-shell ${_nr_shell} (${BASHPID}:${__pid_ctrl}):" __time_start=${EPOCHREALTIME:0:-3}

	# Start logwriter with dedicated logfile when LOGLEVEL=2 or = 4. When level = 4 redirect out stdout and stderr to the logwriter.
	if [[ ${FOREGROUND} -ne 1 ]] && [[ ${conf[LOGLEVEL]} -eq 2 || ${conf[LOGLEVEL]} -eq 4 ]]; then
		[[ ${conf[LOGLEVEL]} -eq 4 ]] && __pid_logwriter="1>&6 2>&1"
		exec 6> >(logwriter shell-${_pid_reader}.log) ${__pid_logwriter}
		__pid_logwriter=$!
	fi
	
	if [[ ! conf[DEBUGSHELL] -eq 1 ]]; then
		do_log error "${__myname} debug shell not enabled"
		kill -SIGTERM ${__pid_ctrl}
		trap_term_systemd_daemon_cmd
	fi

	# Open a connection to the listening socket. Check if it exists first.
	TERM=xterm; coproc __socat { socat exec:"bash -i",pty,stderr,setsid,sigint,sane UNIX-CONNECT:${__sock_ctrl}; }
	do_log warning "${__myname} debug shell started"
	wait ${__socat_PID}
	do_log warning "${__myname} debug shell ended"
}

do_reader_add_crypt()
{
	# The add command received from UDEV will contain 1 argument, the block device that is added.
	# At least a mount worker for adding the cryptdisk A passphrase worker process is spawned if there is not already 
	# one running for the passphrase. We will keep a list of passhrase workers and mount workers using that passphrase.

	# First lookup the device in the crypttab file, if there is no associated cryptdisk exit.
	local __crypt_arr __fd_pp __passphrase __key="$(keyctl request user "${__add_pp}" 2>/dev/null)"
	do_xcrypt_fromtab __myname ${_cmd[@]:1} || return
	local _add_crypt="${__crypt_arr[0]}"  __add_dev=""${__crypt_arr[1]} __add_pp="$(do_eval_pp "${__crypt_arr[2]}")" __add_trim="${__crypt_arr[3]}"
	
	# Set the variables for the crypt to be added, search for the backing device in conf[BLOCKDEVSDIRS].	
	do_log debug "${__myname} adding ${__add_dev} as ${__add_crypt} TRIM ${__add_trim} using ${__add_pp} passphrase"
	if ! do_find_dev ${__crypt_arr[1]} ${__crypt_arr[0]}; then
		do_log warning "${__myname} ${__add_dev} not found in ${conf[BLOCKDEVSDIRS]}"
		_status=2
		return
	elif [[ "${__cmd}" == "change" ]] && dmsetup info "${__add_crypt}" >/dev/null 2>&1; then
		# If the UDEV action is change (reload) we will not bother the daemon with mounts that are still active.
		do_log debug "${__myname} cryptdisk ${__add_crypt} already present"
		return
	elif [[ -n "${__key}" ]]; then
		# Passphrase is still cached, uotify the daemon about the crypt.
		do_log info "${__myname} found cached ${__add_pp} passphrase" 
		do_reader_notify_daemon "add ${__add_crypt} ${__add_dev} ${__add_pp} ${__add_trim}"
		# If we are in boot up the passphrase may be in the user keyring (not cached by us) revoke and cache in session keyring.
		if [[ ${_pp_cached[${__add_pp}]} -ne 1 ]]; then
			__passphrase="$(keyctl pipe "${__key}")"
			put_key &
			_pid_putkey[${__add_pp}]=$!
			keyctl revoke "${__key}"
			do_cache_pp
		fi
		return 
	fi

	# No worker and no passphrase cached, start new worker.
	do_log debug "${__myname} adding ${__add_dev} as ${__add_crypt} TRIM ${__add_trim} to waiting list for ${__add_pp} passphrase"
	_waiting_mnt[${__add_pp}]+="${__add_crypt} ${__add_dev} ${__add_trim} ${EPOCHREALTIME:0:-7} "
	if [[ -z "${_pid_ppwrk[${__add_pp}]}" ]]; then
		do_log debug "${__myname} no cached passphrase or active worker for ${__add_pp}, starting"
		case ${conf[LOGLEVEL]} in
			0|1|2)
				# Start passphrase worker with stdout and stderr redirected to /dev/null (silent). fd 4 will point back to us.
				udev_reader_ppwrk 1>dev/null 2>&1 &
				;;
			3|4)
				# Start passphrase worker with stdout and stderr redirected to logwriter (fd 6). fd 4 will point back to us.
				udev_reader_ppwrk 1>&6 2>&1 &
				;;
		esac
		_pid_ppwrk[${__add_pp}]=$!
		_time_ppwrk[${__add_pp}]=${EPOCHREALTIME:0:-3}
	fi

	do_log debug2 "${__myname} ${_cmd[0],,} ${__crypt_arr[@]} took $(do_timer ${__time_start})s"
}

do_reader_notify_daemon()
{
	[[ -z "${__myname}" ]] && local __myname="${_myname}"
	echo "reader ${_pid_reader} $@" >&5
	do_log debug "${__myname} sent message \"$@\" to daemon (PID: ${pid_daemon})"
}

do_reader_cleanup()
{
	# Reader cleanup routine. Check all the active workers, se if they're still running, terminate after timeout.
	local __time_start="${EPOCHREALTIME:0:-3}" __pp
	_cleanup=$(do_timer ${time_start})
	_time_active=$(do_timer ${_time_start})
	do_log debug "${_myname} cleanup starting at ${_time_active}"

	# Check logwriter status, restart if necessary.
	if [[ ! -z ${_pid_logwriter} ]]; then
		if [[ "$(cat /proc/${_pid_logwriter}/comm 2>/dev/null)" != "${MYNAME}" ]] || ! kill -0 ${_pid_logwriter} && kill -SIGKILL ${_pid_logwriter}; then
			do_log error "${_myname} logwriter (PID: ${_pid_logwriter}) terminated after ${_time_active}s, restarting"
			[[ ${conf[LOGLEVEL]} -eq 4 ]] && _pid_logwriter="1>&6 2>&1"
			exec 6> >(logwriter reader-${_pid_reader}.log) ${_pid_logwriter}
			_pid_logwriter=$!
		fi
	fi

	# Remove too long outstanding mounts.
	for __pp in ${!_waiting_mnt[@]}; do
		local __waiting_mnt="" __crypt __dev __trim __time
		while IFS=" " read -r __crypt __dev __trim __time; do
			local ___time=$(do_timer ${__time})
			if [[ ${___time:0:-4} -ge $((conf[PP_TIMEOUT])) ]]; then
				do_log debug "${_myname} cleanup removed waiting mount ${__dev} for ${__crypt} passphrase ${__pp} after timeout"
			else
				__waiting_mnt+="${__crypt} ${__dev} ${__trim} ${__time}"
			fi
		done <<<"${_waiting_mnt[${__pp}]}"
		_waiting_mnt[${__pp}]="${__waiting_mnt} "
	done
	
	# Cleanup shells.
	if [[ ! -z "${!_pid_shell[@]}" ]]; then
		for	__pp in ${!_pid_shell[@]}; do
			[[ "$(cat /proc/${_pid_shell[${__pp}]}/comm 2>/dev/null)" != "${MYNAME}" ]] && unset _pid_shell[${__pp}]
		done
	fi

	# Kill too long running passphrase workers and remove them from the list of active workers.
	for __pp in ${!_pid_ppwrk[@]}; do
		if [[ ${_time_active:0:-4} -gt $((${_time_ppwrk[${__pp}]:0:-4}+(conf[PP_TIMEOUT]))) ]]; then
			do_log warning "${_myname} cleanup removed passphrase worker for ${__pp} (PID: ${_pid_ppwrk[${__pp}]})"
			if [[ ! -z "${_pid_ppwrk[${__pp}]}" && "$(cat /proc/${_pid_ppwrk[${__pp}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
				kill -SIGTERM ${_pid_ppwrk[${__pp}]}
				do_log debug2 "${_myname} killed passphrase worker for ${__pp} (PID: ${_pid_ppwrk[${__pp}]})"
			fi
			unset _pid_ppwrk[${__pp}]
			unset _time_ppwrk[${__pp}]
		fi
	done

	# Reset the command counter if nothing is active.
	[[ -z "${!_pid_ppwrk[@]}" ]] && _nr_cmds=1

	# Notify daemon we are still active.
	do_reader_notify_daemon "active"
	
	do_log debug2 "${_myname} cleanup done in $(do_timer ${__time_start})s, active workers for ${!_pid_ppwrk[@]}"
}

# [END OF UDEV QUEUE READER FUNCTIONS]

# [BEGIN OF PASSPHRASE WORKER FUNCTIONS]

trap_term_ppwrk()
{
	trap 'do_log warning "${__myname unclean exit after $(do_timer ${__time_start})s"; exit 1' SIGINT SIGTERM

	# Kill the workers and exit.
	do_log debug2 "${__myname} terminating after $(do_timer ${__time_start})s"
	if [[ ! -z ${__pid_getpp} && "$(cat /proc/${__pid_getpp}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_getpp}
		wait ${__pid_getpp}
		do_log debug2 "${__myname} killed get worker (PID: ${__pid_getpp})"
	fi
	if [[ ! -z ${__pid_putkey} && "$(cat /proc/${__pid_putkey}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_putkey}
		wait ${__pid_putkey}
		do_log debug2 "${__myname} killed put key worker (PID: ${__pid_putkey})"
	fi
	if [[ ! -z "${__pid_logwriter}" && "$(cat /proc/${__pid_logwriter}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_logwriter}
		wait ${__pid_logwriter}
		do_log debug2 "${__myname} killed log writer (PID: ${__pid_logwriter})"
	fi

	exit 0
}

udev_reader_ppwrk()
{
	trap 'trap_term_ppwrk' SIGINT SIGTERM

	# We need to get a passphrase. We will start a worker to get the passphrase from the boot servers
	# and a worker to ask for the passphrase using systemd-ask-password at the same time.
	# The workers will notify the daemon if they get a passphrase.
	local __pid_ppwrk=${BASHPID} __myname="passphrase:${__add_pp} (${BASHPID}):" __time_start="${EPOCHREALTIME:0:-3}" __pid_logwriter
	local __fd_getpp __pid_getpp __fd_querypp __pid_querypp __pid_putkey __passphrase="" __time_active=$(do_timer ${_time_start})  __to
	local __net_status="$(NOTIFY_SOCKET= networkctl status | grep "Online state")"

	# Start a logwriter when LOGLEVEL = 2 or 4, redirect our stdout and stderr to that logwiter whenn level = 4.
	if [[ ${FOREGROUND} -ne 1 && ${conf[LOGLEVEL]} -eq 2 ]]; then
		exec 6> >(logwriter passphrase-${__add_pp}-${__pid_ppwrk}.log 4>&-)
	elif [[ ${FOREGROUND} -ne 1 && ${conf[LOGLEVEL]} -eq 4 ]]; then
		exec 6> >(logwriter passphrase-${__add_pp}-${__pid_ppwrk}.log 4>&-) 1>&6 2>&1
	fi
	__pid_logwriter=$!
	do_log debug "${__myname} started"

	# When starting we will wait max PP_TIMEOUT for the network to come up, or fail.
	[[ ${conf[NET_ONLINE]} -eq 1 && ${_starting} -ne 0 ]] && until [[ "${__net_status##*: }" =~ online|partial ]]; do
		sleep ${conf[QUEUE_TIMEOUT]} & wait
		__net_status="$(NOTIFY_SOCKET= networkctl status | grep "Online state")"
		__time_active=$(do_timer ${__time_start})
		[[ ${__time_active%%.*} -ge ${conf[PP_TIMEOUT]} || "${__net_status##*: }" =~ offline ]] && break
	done

	# Start the worker to get the passphrase from the boot servers or from the user. fd 4 will point back to us.
	if [[ ${conf[LOGLEVEL]} -le 2 ]]; then
		exec {__fd_getpp}< <(ppwrk_get_passphrase 4>&1- 5>&- 1>/dev/null 2>&1)
	else
		exec {__fd_getpp}< <(ppwrk_get_passphrase 4>&1- 5>&- 1>&6 2>&1)
	fi
	__pid_getpp=$!
	do_log debug "${__myname} started get passphrase worker (PID: ${__pid_getpp})"

	# We should get a pssphrase or an empty response from the workers or timeout.
	if [[ ${_starting} -ne 0 ]]; then
		# If we are starting evaluate the timout against the active time of the reader.
		__to=$((${conf[START_TIMEOUT]}-${__time_active:0:-4}))
	else
		__to=${conf[PP_TIMEOUT]}
	fi
	if ! read -t${__to} -u${__fd_getpp} __passphrase; then
		do_log warning "${__myname} timeout after $(do_timer ${__time_start})s"
		trap_term_ppwrk
    fi
	# Check the received passphrase and relay it or an empty response to the daemon.
	if [[ $(do_ckeck_passphrase)$? -eq 1 ]]; then
		do_log warning "${__myname} received incoorect ${__ad_pp} passphrase after $(do_timer ${__time_start})s"
		trap_term_ppwrk
    fi
	[[ -z "${__passphrase}" ]] && do_log warning "${__myname} only fools use emtpy passphrases for ${__add_pp} disks"

	# Put key (back) to servers, cache and send to reader.
	put_key &
	__pid_pukey=$!
    do_cache_pp
	echo "passphrase ${__add_pp}" >${conf[FIFO]}

	do_log debug2 "${__myname} took $(do_timer ${__time_start})s"
	wait ${__pid_pukey}
}

trap_term_ppwrk_get_passphrase() {
	trap 'do_log warning "${___myname unclean exit after $(do_timer ${___time_start})s"; exit 1' SIGINT SIGTERM

	do_log debug "${___myname} terminating after $(do_timer ${___time_start})"
	local ___srv
	if [[ ! -z "${!___pid_bootserver[@]}" ]]; then
		for ___srv in ${!___pid_bootserver[@]}; do
			if [[ "$(cat /proc/${___pid_bootserver[${___srv}]}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
				kill -SIGTERM ${___pid_bootserver[${___srv}]}
				wait ${___pid_bootserver[${___srv}]}
				do_log debug "${__myname} killed ssh (PID: ${___pid_bootserver[${___srv}]})"
			fi
		done
	fi
	if [[ ! -z ${__pid_querypp} && "$(cat /proc/${__pid_querypp}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGTERM ${__pid_querypp}
		wait ${__pid_querypp}
		do_log debug2 "${__myname} killed query worker (PID: ${__pid_querypp})"
	fi

	exit 0
}

ppwrk_get_passphrase()
{
	trap 'trap_term_ppwrk_get_passphrase' SIGINT SIGTERM

	local ___myname="passphrase-get:${__add_pp} (${BASHPID}):" ___time_start="${EPOCHREALTIME:0:-3}"  ___passphrase ___fd_querypp ___pid_querypp ___res="" ___srv
	declare -A ___fd_bootserver ___pid_bootserver
	do_log debug "${___myname} started getting ${__add_pp} passphrase"

	while [[ -z "${___res}" ]]; do
		# Walk through the bootservers and start a worker per server, relay the passphrase to the main worker which will guard the timeout.
		if [[ ${conf[NET_ONLINE]} -ne 1 || "${__net_status##*: }" =~ online|partial ]]; then 
			do_log debug "${__myname} getting passphrase from ${bootconf[BOOTSERVERS]}"
			for ___srv in ${bootconf[BOOTSERVERS]}; do if [[ -z "${___pid_bootserver[${___srv}]}" ]]; then
				[[ ${conf[LOGLEVEL]} -le 2 ]] && exec {___fd_bootserver[${___srv}]}< <(ssh -i ${CONFDIR}/${bootconf[BOOTUSERKEY]} -o UserKnownHostsFile=${CONFDIR}/${bootconf[BOOTSERVERKEYS]} ${bootconf[BOOTUSER]}@${___srv} "GET "${__add_pp}"" 4>&- 5>&1 2>/dev/null)
				[[ ${conf[LOGLEVEL]} -gt 2 ]] && exec {___fd_bootserver[${___srv}]}< <(ssh -i ${CONFDIR}/${bootconf[BOOTUSERKEY]} -o UserKnownHostsFile=${CONFDIR}/${bootconf[BOOTSERVERKEYS]} ${bootconf[BOOTUSER]}@${___srv} "GET "${__add_pp}"" 4>&- 5>&- 2>&6)
				___pid_bootserver[${___srv}]=$!
			fi done

			# Wait a short while and check if we have received a passphrase.
			sleep $((${conf[QUEUE_TIMEOUT]})) & wait $!
			for ___srv in ${!___fd_bootserver[${___srv}]}; do
				if read -t0 -u${___fd_bootserver[${___srv}]}; then
					unset ___pid_bootserver[${___srv}]
					if read -ru${___fd_bootserver[${___srv}]} ___passphrase; then
						___res="${___srv}" break 2
					fi
					do_log debug "${__myname} failed to get passphrase from ${___srv}"
				fi
			done
		fi

		# We did not receive a passphrase from boot servers. Start the query worker to ask for a passphrase from the user.
		if [[ -z "${___pid_querypp}" ]]; then
		    [[ ${conf[LOGLEVEL]} -le 2 ]] && exec {___fd_querypp}< <(ppwrk_query_passphrase 4>&- 5>&- 4>&1- 1>/dev/null 2>&1)
 			[[ ${conf[LOGLEVEL]} -gt 2 ]] && exec {___fd_querypp}< <(ppwrk_query_passphrase 4>&- 5>&1 4>&1- 1>&6 2>&1)
			___pid_querypp=$!
			do_log debug "${__myname} started query passphrase worker (PID: ${__pid_querypp})"
		fi

		# Check if we received a pssphrase from the user.
		if [[ ! -z ${___fd_querypp} ]] && read -t0 -u${___fd_querypp} && read -ru${___fd_querypp} ___passphrase; then
			___res=user
		fi
	done

	# Received a valid passphrase.
	do_log debug "${___myname} received passphrase from ${___res}"
	echo "${___passphrase}" >&4
	trap_term_ppwrk_get_passphrase
}

trap_term_ppwrk_query_passphrase()
{
	trap 'do_log warning "${__myname} unclean finish after $(do_timer ${___time_start})s"; exit 1' SIGINT SIGTERM

	# Close the fd to the reader, we don't need it and should not keep it.
	if [[ ! -z "${___pid_askpp}" && "$(cat /proc/${___pid_askpp}/comm 2>/dev/null)" == "${MYNAME}" ]]; then
		kill -SIGKILL ${___pid_askpp}
		do_log debug2 "${__myname} killed ask worker (PID: ${___pid_askpp})"
	fi
	if [[ ! -z "${___pid_putkey}" ]]; then
		kill -SIGTERM ${___pid_putkey}
		wait ${___pid_putkey}
		do_log debug2 "${__myname} killed putkey worker (PID: ${___pid_putkey})"
	fi

	do_log debug2 "${__myname} terminating after $(do_timer ${___time_start})s"
	exit 0
}

ppwrk_query_passphrase()
{
	trap 'trap_term_ppwrk_query_passphrase' SIGINT SIGTERM

	# Ask for a pssphrase input by user through systemd-ask-password
	local __myname="passphrase_query:${__add_pp} (${BASHPID}):"
	local ___time_start="${EPOCHREALTIME:0:-3}" ___time_active
	local ___pid_askpp ___fd_askpp ___pid_putkey
	do_log debug "${__myname} query for ${__add_pp} passphrase started"

	do_ppwrk_ask_passphrase "Enter ${__add_pp} Passphrase: "

	# Received a passphrase from the user check it against key stored in firmware.
	local ___ppchk=$(do_check_passphrase)$?
	if [[ ${___ppchk} -eq 3 ]]; then
		do_log error "${__myname} Unable to confirm passphrase due to key error, giving up"
		trap_term_ppwrk_query_passphrase

	elif [[ ${___ppchk} -eq 2 ]]; then
		# Key not present in firmware, ask for confirmation from the user.
		local ___passphrase="${__passphrase}"
		do_ppwrk_ask_passphrase "Created key file. Confirm ${__add_pp} Passphrase: "
		# If the passphrase does not match, enter a loop until it does and wirte the keyfile if ok.
		until [[ "${___passphrase}" == "${__passphrase}" ]]; do
			do_ppwrk_ask_passphrase "Passphrases do not Match. Enter ${__add_pp} Passphrase: "
			___passphrase="${__passphrase}"
			do_check_passphrase rmkey
			do_ppwrk_ask_passphrase "Confirm ${__add_pp} Passphrase: "
			[[ "${___passphrase}" == "${__passphrase}" ]] && do_write_keyfile
		done
		do_log debug "${__myname} received passphrase after $(do_timer ${___time_start})s"

	elif [[ ${___ppchk} -eq 1 ]]; then
		# Passphrase entered does not match stored key, keep asking until it does.
		until [[ ${___ppchk} -eq 0 ]]; do
			do_log debug2 "${__myname} query passphrase check failed"
			do_ppwrk_ask_passphrase "Incorrect Passphrase. Enter ${__add_pp} Passphrase: "
			___ppchk=$(do_check_passphrase)$?
		done
		do_log debug "${__myname} received passphrase after $(do_timer ${___time_start})s"

	elif [[ ${___ppchk} -eq 0 ]]; then
		# Passphrase received is ok.
		do_log debug "${__myname} received passphrase after $(do_timer ${___time_start})s"
	fi
 
 	# Notify the reader, so it knows passphrase worker has finished.
	echo "${__passphrase}" >&4
	
	do_log debug2 "${__myname} took $(do_timer ${___time_start})s total"
}

do_ppwrk_ask_passphrase()
{
	# Query for the passphrase in the background, record pid so we can kill if passphrase is received from server.
	___time_active=$(do_timer ${___time_start})

	if [[ ${conf[LOGLEVEL]} -le 2 ]]; then
		exec {___fd_askpp}< <(NOTIFY_SOCKET= systemd-ask-password --id=${__add_pp} "$1" 4>&- 2>/dev/null)
	else
		exec {___fd_askpp}< <(NOTIFY_SOCKET= systemd-ask-password --id=${__add_pp} "$1" 4>&- 2>&6)
	fi
	___pid_askpp=$!
	wait ${___pid_askpp}
	IFS= read -ru${___fd_askpp} __passphrase
}

# [END OF PASSPHRASE WORKER FUNCTIONS]

# [START OF UDEV PROCESSING FUNCTIONS]

do_udev_queue()
{
	# Put the udev action on the queue.
	[[ -z "${conf[FIFO]}" ]] && conf[FIFO]=/run/${MYNAME}/${MYNAME}.queue
	local _fifo
	if [[ $# -ne 0 ]]; then
		echo "$@" >${conf[FIFO]} 
	fi
	return $?
}

do_cryptdisksd_udev()
{
	# Parse the udev command line and prepare the message to be put on the queue. Udev can only be run by root.
	if [[ ${UID} -ne 0 || -z "${ACTION}" ]]; then
		echo "${MYNAME} udev queue can only be started from udev"
		exit 1
	fi

	# Prepare the message, first check if there is a confdir specified on command line, or load from systemd if not so.
	local __msg="${ACTION}" __res=1 __command=udev __args=$#
	if [[ -z "${CONFDIR}" ]]; then
		local _t="$(grep -ie "^CONFDIR=\/" /etc/systemd/${MYNAME}.conf)"
		CONFDIR="${_t##*=}"
	fi
	shift
	
	# Enter a loop to check if any of the arguments specified is a command, error exit if so, add parameter to message if ok.
	while [[ ! -z "$1" ]]; do
		do_parse_opt $@; __res=$?
		if [[ ${__res} -eq 0 ]]; then
			__msg+=" $1"
			shift
		else
			logger -p daemon.error "${MYNAME} cannot name crypt or dev \"$1\""
			shift
		fi
	done

	# Put the message (if any) on the queue.
	if [[ ! "${__msg}" == "${ACTION}" ]]; then 
		do_udev_queue ${__msg}
	fi
}

# [END OF UDEV PROCESSING FUNCTIONS]

# [START OF INTERACTIVE CONTROL FUNCTIONS]

do_echo_use()
{
	[[ -z "${conf[RUNDIR]}" ]] && { do_init_conf || echo -e "${RED}${MYNAME}, Error Loading Configuration from ${CONFDIR}${NOR}"; }
	echo -e "${GREY}${BOLD}${MYNAME} (Encrypted Block Device Manager)${NOR}\n"
	case $1 in
		status)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tDisplays Status of Encrypted Block Devices"
			echo -e "\t\t\t\tCommand Has no Options or Arguments\n"
			;;
		stop)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tStops the Encrypted Device Manager"
			echo -e "\t\t\t\tCommand Has no Options or Arguments\n"
			;;
		reload)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tReloads the Configuration of the Encrypted Device Manager"
			echo -e "\t\t\t\tCommand Has no Options or Arguments\n"
			;;
		add)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tAdd an Encrypted Block Device to the Manager\n"
			echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hct ] { crypt | device } || { -p passphrase crypt device }${NOR}\n\n"
			echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
			echo -e "\t${BOLD}-c${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
			echo -e "\t${BOLD}-p {passphrase}${NOR}\tUse {passphrase} for Crypt"
			echo -e "\t${BOLD}-t${NOR}\t\tEnable TRIM for Crypt\n\n"
			echo -e "The $1 Command Can Be Used it Two Ways.\nThe First ( ${BOLD}[ -c ] { crypt | device }${NOR} ) Will Add a Crypt or Device Which is Already on the Crypttab"
			echo -e "The Second ( ${BOLD}[ -c ] { -p passphrase crypt device }${NOR} ) Will Add a crypt (and Corresponding Backing Device) to the Crypttab\nThe Option '${BOLD}-p passphrase${NOR}' Must Be Specified in the Second Case\n"
			echo -e "The Options and Arguments Can Be Specified in any Order"
			echo -e "${BOLD}${UL}${MYNAME} $1 -p passphrase crypt device${NOR}\tand\t${BOLD}${UL}${MYNAME} $1 crypt -c\n${MYNAME} $1 crypt -c device -p passphrase${NOR}\tand\t${BOLD}${UL}${MYNAME} $1 device -p passphrase crypt -c${NOR}"
			echo -e "Are All Valid $1 Command Specifications\n"			
			echo -e "The ${MYNAME} Will Look for Block Devices in \"${BOLD}${conf[BLOCKDEVSDIRS]}${NOR}\"\n"
			;;
		del)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tRemove an Encrypted Block Device from the Manager\n"
			echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -htc ] { crypt | device }${NOR}\n\n"
			echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
			echo -e "\t${BOLD}-c${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions"
			echo -e "\t${BOLD}-t${NOR}\t\tRemove the crypt (and Corresponding Backing Device) from the Crypttab\n\n"
			echo -e "The Options and Arguments Can Be Specified in any Order\n"
			;;
		put)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tPut Key File to Boot Servers\n"
			echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hc ] passphrase${NOR}\n\n"
			echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
			echo -e "\t${BOLD}-c${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions\n"
			;;
		rmkey)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tRemove Key File from Firmware\n"
			echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hc ] passphrase${NOR}\n\n"
			echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
			echo -e "\t${BOLD}-c${NOR}\t\tAsk for Confirmation for Non-Crtitical Actions\n"
			;;
		smart)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tShow S.M.A.R.T. Information for Backing Device\n"
			echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -hax ] {crypt | device }${NOR}\n\n"
			echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
			echo -e "\t${BOLD}-a|-x${NOR}\t\tShow all S.M.A.R.T. information (Only Atrributes Otherwise)"
			echo -e "\t${BOLD}-t${NOR}\t\tRun S.M.A.R.T. Long Self Test on Device\n"
			;;
		erase)
			echo -e "${BOLD}${MYNAME} $1${NOR}\t\tSecure Erase Device\n"
			echo -e " Usage:\n\t${BOLD}${MYNAME} $1 [ -h ] {crypt | device }${NOR}\n\n"
			echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
			;;
		*)
			echo -e " Usage:\n\t${BOLD}${MYNAME} { [ -hdf ] ${UL}COMMAND ...${NOR} }\n"
			echo -e "\tEncrypted Block Devices Manager, Command Line Requires at Least one Option or Command"
			echo -e "\tMultiple Commands May Be Specified in Order, Commands Can Have Multiple Options and Arguments"
			echo -e "\tAll Commands Options and Arguments Are cAsE iNSensItiVe, except for ${UL}Device Names${NOR}\n"
			echo -e "\tUse ${UL}${BOLD}${MYNAME} command -h${NOR} To Display Help for That Command${NOR}\n\n"
			echo -e " Options:\n\t${BOLD}-h${NOR}\t\tDisplay This Help Text"
			echo -e "\t${BOLD}-d${NOR}\t\tSet Configuration Directory (${BOLD}${UL}Default: /etc/${MYNAME:0:-1}.d${NOR})"
			echo -e "\t${BOLD}-f${NOR}\t\tRun in Foreground (Debug) Mode. Can Only be Started by root."
			echo -e "\n\n Commands:\n\t${BOLD}status${NOR}\t\tDisplays Status of Encrypted Block Device Manager"
			echo -e "\t${BOLD}smart${NOR}\t\tDisplay S.M.A.R.T. Status of Encrypted Block Device" 
			echo -e "\t${BOLD}erase${NOR}\t\tSecure Erase Encrypted Block Device" 
			echo -e "\t${BOLD}stop${NOR}\t\tStop the Encrypted Device Manager" 
			echo -e "\t${BOLD}reload${NOR}\t\tReload the Configuration of the Encrypted Device Manager" 
			echo -e "\t${BOLD}add${NOR}\t\tAdd Encrypted Block Device to Manager" 
			echo -e "\t${BOLD}del${NOR}\t\tDelete Encrypted Block Device from Manager" 
			echo -e "\t${BOLD}put${NOR}\t\tPut Keyfile (Passphrase) to Boot Servers" 
			echo -e "\t${BOLD}rmkey${NOR}\t\tRemove Keyfile (Passphrase) from Firmware\n" 
			;;
	esac
	exit 127
}

do_parse_opt()
{
	# Parse command line options (-h -d -f). Function is run from main cli to parse as first options given.
	# Function can also run from the parse cmds function, it that case only -d option can be valid.
	local __opt; OPTIND=1; getopts :fFd:D:hHcCaAp:P:tT __opt
	__opt="${__opt,,}"; case ${__opt} in
		h|:) # if -h is specified as a command line option echo usage for the command running if run from parse cmds.
			do_echo_use "${__command}"
			;;
		a|x) # Option for smart -x
			[[ ${_cmd} -eq 0 || ! "${__command,,}" =~ ^(smart)$ ]] && do_echo_use "${__command}"
			__smartall=1
			return 1
			;;
		c) # Option to ask for confirmation for non critical actions.
			[[ ${_cmd} -eq 0 || ! "${__command,,}" =~ ^(add|del|put|rmkey)$ ]] && do_echo_use "${__command}"
			[[  ${__confirm} -eq 1 ]] && do_echo_use "${__command}"
			__confirm=1
			return 1
			;;
		p) # Option to specify a passphrase name for the new crypt to be added to the crypttab.
			[[ ${_cmd} -eq 0 || ! "${__command,,}" == "add" ]] && do_echo_use "${__command}"
			[[  ${__crypttab} -eq 1 ]] && do_echo_use "${__command}"
			__crypttab=1
			__add_pp="${OPTARG}"
			return $((OPTIND-1))
			;;
		t) # Option trim enable foor add, remove crypt from crypttap for del command. Or Run smart self test.
			[[ ${_cmd} -eq 0 || ! "${__command,,}" =~ ^(add|del|smart)$ ]] && do_echo_use "${__command}"
			if [[ "${__command}" == "add" ]]; then
				__add_trim=1
				return 1
			elif [[ "${__command}" == "del" ]]; then
				[[  ${__crypttab} -eq 1 ]] && do_echo_use "${__command}"
				__crypttab=1
				return 1
			elif [[ "${__command}" == "smart" ]]; then
				[[  ${__smarttest} -eq 1 ]] && do_echo_use "${__command}"
				__smarttest=1
				return 1
			fi
			;;
		d) # Set configuration directory. If no dir specified echo usage. Option is only valid for global, not for command.
			[[ ${_cmd} -eq 1 ]] && do_echo_use "${__command}"
			[[ ! -d ${OPTARG} ]] && echo "Configuration Directory ${OPTARG} Does not Exist"
			[[ ! -d ${OPTARG} || ${_conf} -ne 0 ]] && do_echo_use "${__command}"
			_conf=1
			CONFDIR=${OPTARG}
			# Shift the parameters and check if more arguments specified, continue with processing options if so.
			[[ $# -ge ${OPTIND} ]] && return $((OPTIND-1))
			shift $((OPTIND-1))
			;;
		f) # Set the flag that we should run in foreground mode. 
			[[ ${_cmd} -eq 1 || ${FOREGROUND} -eq 1 ]] && do_echo_use "${__command}"
			FOREGROUND=1
			# If there are more options continue parsing. -f can only be followed by -d.
			shift
			[[ ! -z "$1" ]] && return 1
			;;
		?) # If run from parse cmds function, we need to check if the option specified matches a known command.
		   # If that is the case we have reached the end of the current command and can start processing the next.
			if [[ ${_cmd} -eq 1 ]]; then
				if [[ ! -z "$1" ]]; then 
					if ! do_parse_cmd check $1; then
						___next_cmd=1
					else
						shift
					fi
				else
					# If there are no more arguments set to process next command, which will be none.
					___next_cmd=1
				fi
			fi
			;;
	esac

	# All options are evaluated or confdir specified, initialize the configuration.
	if [[ ( ${_cmd} -eq 0 && ( ${_conf} -eq 1 || -z "$1" ) ) || ( ${_cmd} -eq 1 && ${_conf} -eq 0 ) ]]; then
		if ! do_init_conf; then
			echo "Error loading configuration from ${CONFDIR}"; exit 1
		else
			_conf=1
		fi
	fi

	# If foreground mode was requested execute. Echo command usage if specified in wrong place.
	if [[ ${FOREGROUND} -eq 1 ]]; then
		# If -f is not first option specified, it must be last (after -d) and no more options can be present.
		[[ ${_nr} -gt 1 && ! -z "$1" ]] && do_echo_use "${__command}"
		# Start in debug/foreground mode.
		if [[ ${UID} -ne 0 && $# -le 1 ]]; then
			echo "cryptdisksd daemon foreground can only be started as root"; exit 1
		fi
		echo "loglevel=${conf[LOGLEVEL]}"
		systemd_daemon
		exit $?
	fi

	# Return 1 if next command is found, 0 otherwise.
	[[ ${___next_cmd} -eq 1 ]] && return 1
	return 0
}

do_parse_cmd()
{
	# Parse the commands specified on the command line, one by one. If called with check, then return 1 on match.
	# This is to let the parse opt function know a match for a new command has been found.
	local __command="${1,,}"
	if [[ "${__command}" == "check" ]]; then 
		shift; __command="${1,,}"
	       	local __check=1;
       	fi
	case ${__command} in
		udev) [[ ${__check} -eq 1 ]] && return 1; do_cmd_parseopt $@; do_cryptdisksd_udev $@; return $#	;;
		stop) [[ ${__check} -eq 1 ]] && return 1; do_cmd_parseopt $@; /bin/kill -SIGTERM $(cat ${conf[PIDFILE]}); return $#	;;
		reload)	[[ ${__check} -eq 1 ]] && return 1; do_cmd_parseopt $@; /bin/kill -SIGHUP $(cat ${conf[PIDFILE]}); return 1	;;
		status|shell|add|del|put|rmkey|smart|erase) [[ ${__check} -eq 1 ]] && return 1; do_cryptdisksd_cmd $@; return $? ;;
		*) [[ ${__check} -ne 1 ]] && do_echo_use "${__command}"; return 0 ;;
	esac
	return 0
}

do_cmd_parseopt()
{
	# If there are more arguments to process, check for command options or or for a new command to be processed.
	local ___next_cmd=0 ___res ___s=0
	shift; while [[ ${___next_cmd} -eq 0 ]]; do
		do_parse_opt $@; ___res=$? 
		if [[ ${___res} -eq 0 ]]; then
			__msg+="$1 "
			shift
			___s=$((___s+1))
		else
			shift ${___res}
			___s=$((___s+___res))
		fi
	done
	return ${___s}
}

trap_term_cryptdisksd_cmd()
{
	trap 'echo "${RED}${MYNAME} unclean finish${NOR}"; exit 1' SIGINT SIGTERM

	# Kill socat coproc if still active and remove the socket if still present. Restore stdin to the tty.
	if [[ ! -z "${__pid_socat}" && "$(cat /proc/${__pid_socat}/comm 2>/dev/null)" == "socat" ]]; then
		kill -SIGTERM ${__pid_socat}
		[[ ${conf[LOGLEVEL]} -gt 2 ]] && echo -e "\rKilled ${__pid_socat}"
	fi
	if [[ -e ${conf[CRYPTDISKSDDIR]}/${__sock} ]]; then
		rm -f ${conf[CRYPTDISKSDDIR]}/${__sock}
		echo -e "\rRemoved ${conf[CRYPTDISKSDDIR]}/${__sock}\r\n"
	fi
	exec 0<&${stdin}-; stty sane; echo -e "${NOR}\n"
	exit 1
}

do_cryptdisksd_cmd()
{
	trap 'trap_term_cryptdisksd_cmd' SIGINT SIGTERM

	# Request status from daemon. Detach stdin and assign it to socat coproc, which will attach it to daemon stdout.
	if [[ ! "$(NOTIFY_SOCKET systemctl is-active ${MYNAME}.service 2>&1)" =~ activating|active ]]; then
		echo "${MYNAME} not Running"
		exit 1
	fi
	
	# Parse the options to the command and store the nr. of paramters to shift in __s.
	local __crypttab=0 __confirm=0 __smartall=0 __smarttest=0 __add_pp="" __add_trim=0 __msg="$1 " __stty_opt=""
	do_cmd_parseopt $@; local __s=$?
	local __sock=${conf[CRYPTDISKSDDIR]}/${MYNAME}-${BASHPID}.sock __pid_socat

	case ${__command} in
		add)
			if [[ ${__crypttab} -eq 1 ]]; then
				[[ $(wc -w <<<"${__msg}") -ne 3 ]] && do_echo_use "${__command}"
			else
				[[ $(wc -w <<<"${__msg}") -ne 2 ]] && do_echo_use "${__command}"
			fi
			__msg+="${__add_pp} ${__add_trim} ${__confirm} ${__crypttab}"
			__stty_opt="raw -echo isig"
			;;
		del)
			[[ $(wc -w <<<"${__msg}") -ne 2 ]] && do_echo_use "${__command}"
			__msg+="${__confirm} ${__crypttab}"
			__stty_opt="raw -echo isig"
			;;
		status)
			[[ $(wc -w <<<"${__msg}") -ne 1 ]] && do_echo_use "${__command}"
			__stty_opt="raw -echo isig"
			;;
		smart)
			[[ $(wc -w <<<"${__msg}") -ne 2 ]] && do_echo_use "${__command}"
			__msg+="${__smartall} ${__smarttest}"
			__stty_opt="-echo isig"
			;;
		shell)
			[[ $(wc -w <<<"${__msg}") -ne 1 ]] && do_echo_use "${__command}"
			__stty_opt="raw -echo -isig"
			;;
		*)
			[[ $(wc -w <<<"${__msg}") -ne 2 ]] && do_echo_use "${__command}"
			__msg+="${__confirm}"
			__stty_opt="raw -echo isig"
			;;
	esac

	# Set tty options, redirect STDIN
	stty ${__stty_opt}
	local stdin
	exec {stdin}<&0-

	[[ ${conf[LOGLEVEL]} -gt 2 ]] && echo -e "Requesting \"$@\" from ${MYNAME}\r"

	# Start socat in background and attach stdin, listen on a socket in RUNDIR. 
	# The daemon will spawn a worker which will connect and start interactive session.
	socat -t1 - UNIX-LISTEN:${__sock},unlink-early,unlink-close,group=${conf[CRYPTDISKSD_GROUP]},mode=600 0<&${stdin}- &
	__pid_socat=$!

	# Notify the daemon to connect to the socket and wait until it's finished. Then restore stdin and exit.
	sleep .05
	echo "control ${BASHPID} ${__msg}" >${conf[FIFO]}
	wait ${__pid_socat}

	# Restore stdin, remove socket and exit.
	exec 0<&${stdin}-
	stty sane
	[[ -e ${__sock} ]] && rm -f ${__sock}

	[[ ${conf[LOGLEVEL]} -gt 3 ]] && echo "Done requesting \"$@\" from ${MYNAME}"
	return ${__s}
}

# [END OF INTERACTIVE CONTROL FUNCTIONS]

# [BEGIN OF EXECUTION FUNCTIONS]

do_systemd_start()
{
	# Check if we are started from systemd (PID 1).
	[[ ! "${UID}" -eq 0 || ! ${PPID} -eq 1 ]] && do_echo_use

	do_init_conf || exit 1

	# Link the session to the user key. So all functions etc have access to it for storing and retreiving cached passphrases.
	keyctl new_session
	keyctl link @us @s

	systemd_daemon
}

do_cryptdisksd_cli()
{
	local _i=0 _nr=$# _cmd=0 _conf=0
	# Enter a loop to evaluate all command line options and commands specified.
	while true; do
		local _i=$((_i+1)) _res 
		# Parse options, the return code will be the nr of parameters to shift or 0 if all options parsed.
		# Continue with processing commands fase if all options parsed.
		if [[ ${_cmd} -eq 0 ]]; then 
			do_parse_opt $@
			_res=$?
			shift ${_res}
			[[ ${_res} -ne 0 ]] && continue
		fi
		# Command line options are parsed, evaluate and execute commands specified. Return code will be nr of arguments to shift.
		# If after shifting there are no more commands to process we can exit.
		_cmd=1; do_parse_cmd $@
		_res=$?
		shift ${_res}
		[[ -z "$1" ]] && return 0
	done
}

MYNAME="$(basename $0)" FOREGROUND=0 PATH=/bin:/sbin
[[ ! -z "${LC_NUMERIC}" ]] && unset LC_NUMERIC

# Check if we're started interactively (options must be specified) or from systemd (run without any options from PID 1).
if [[ $# -eq 0 ]]; then
	# No command line options specified. check if we're started from systemd, start daemon if so.
	do_systemd_start
	exit 1
else
	# Command line options present, run in interactive mode.
	do_cryptdisksd_cli $@
	# Exit if there are no more commands to execute.
	exit $?
fi

# [END OF EXECUTION FUNCTIONS]

# We should never get here, error exit if we do.
echo "${MYNAME} Reached End of the Line, Bye Bye"
exit 1
