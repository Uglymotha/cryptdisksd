#!/bin/bash
trap 'problem "Caught SIGINT or SIGTERM"' SIGINT SIGTERM
set -o pipefail

PATH=/bin:/sbin

# Initialize System Paramters. Parameters from boot.conf are CAPS.
masterpp="system:master"
network=0
version="$(< /version)"
tmpdir="/tmp"
fwdir="/sys/firmware/efi/efivars"
fwguid="ca25478a-acb8-44ac-8c55-d5d45dfe25c5"
fwbootconf="${fwdir}/UglyLinuxBootCFG-${fwguid}"
bootconfinfw=0
rootdir="/.root"
libmd="/dev/md/lib"
libsz=0
etcmd="/dev/md/etc"
etcsz=0
etcdir="${rootdir}/etc"
logdev="/dev/zram0"
logsz="1GiB"
logdir="${rootdir}/var/log"
storagedir="storage"
storagepool="storage"
storageprefix="storage"
storagetrim=0
storagepp="${masterpp}"
timeout=30
sysimg="/sysimg-uglylinux-${version}.sqfs"
init=/lib/systemd/systemd
recovery="no"

log()
{
	echo "uglylinux-boot: $@" >dev/kmsg
}

cecho()
{
	echo "$@" >/dev/console
}

problem()
{
	log "$@"
	cecho -e "\033[9C\033[91m\033[1mEncountered a problem! Dropping you to a shell\033[0m"
	cecho -e "\033[9C\033[91m\033[1mThe error encountered (if any given):\033[0m"
	cecho -e "\033[9C\033[93m\033[1m$@\033[0m"
	setsid cttyhack bash -i
}

reset()
{
	log "RESETTING"
	cecho -e "\n\033[9C\033[91m\033[1m$1\n\033[9CResetting!\033[0m"
	sleep 5
	echo 1 >/proc/sys/kernel/sysrq
	echo b >/proc/sysrq-trigger
}

echodo()
{
	local _msg="$1"
	local _cmd="$2"
	local _output=""
	local _result=1
	shift 2
	cecho -ne "\033[9C\033[1m${_msg}\033[0m"
	${_cmd} $@
	_result=$?
	if [[ ${_result} -eq 0 ]]; then
		log "${_cmd} ${_msg} - OK"
		cecho -e "\033[200D\033[92m\033[1m[  OK  ]\033[0m"
	elif [[ ${_result} -eq 2 ]]; then
		log "${_cmd} ${_msg} - WARN"
		cecho -e "\033[200D\033[93m\033[1m[ WARN ]\033[0m"
	else 
		log "${_cmd} ${_msg} - FAIL"
		cecho -e "\033[200D\033[91m\033[1m[ FAIL ]\033[0m"
	fi
	[[ ! -z "${_output}" ]] && echo "${_output}"
	return ${_result}
}

do_make_zram_fs()
{
	# Create zram filesystem
	local __status=0
	local __num_fs=$#
	local __i=1
	while [[ "${__i}" -le "${__num_fs}" ]]; do
		local __zr="zram$((__i-1))"
		local __alg=$(echo ${!__i} |cut -d "," -s -f 1)
		local __size=$(echo ${!__i} |cut -d "," -s -f 2)
		local __fs=$(echo ${!__i} |cut -d "," -s -f 3)
		if [[ -b /dev/${__zr} ]]; then
			echo "1" > /sys/block/${__zr}/reset
			echo "${__alg}" > /sys/block/${__zr}/comp_algorithm
			echo "${__size}" > /sys/block/${__zr}/disksize
		else
			zramctl ${__zr} -a ${__alg} -s ${__size} || problem "Cannot Create ${__zr}"
		fi
		if [[ -n "${__fs}" ]]; then 
			if [[ ! "${__fs}" == "etc" && ! "${__fs}" == "lib" ]]; then
				mkfs.ext4 -F /dev/${__zr} > /dev/null 2>&1 || problem "Cannot Create Filesystem on ${__zr}"
				e2label /dev/${__zr} ${__fs} > /dev/null 2>&1 || problem "Cannot label ${__fs} on ${__zr}"
			else if [[ ! -f /default ]]; then
				mdadm --add /dev/md/${__fs} /dev/${__zr} >/dev/null 2>&1 || { log "unable to add ram backing device for ${__fs}"; __status=2; }
			     fi
			fi
		fi
		__i=$((__i+1))
	done
	return ${__status}
}

do_parse_fwconf()
{
	[[ ! -s ${fwbootconf} ]] && touch /default && cecho -ne "\033[93m Not found. Starting with default config." && return 2
	local __bootconftmp="$(cat ${fwbootconf} | tail -c +5 |grep -ve "^\s*#")"
	echo "${__bootconftmp}" >/tmp/boot.conf
	declare -gA bootconf
	local __var __val 
	while IFS="=" read -r __var __val; do
		bootconf[${__var}]="${__val}"
	done <<<"${__bootconftmp}"
	[[ -z "${bootconf[BOOTUSER]}" || -z "${bootconf[BOOTSERVERS]}" ]] && return 1
	[[ -n "${bootconf[STORAGEPOOL]}" ]] && storagepool="${bootconf[STORAGEPOOL]}"
	[[ "${bootconf[STORAGETRIM]}" == "1" || "${bootconf[STORAGETRIM],,}" == "y" || "${bootconf[STORAGETRIM],,}" == "yes" ]] && storagetrim=1
	[[ -n "${bootconf[STORAGEPREFIX]}" ]] && storageprefix="${bootconf[STORAGEPREFIX]}"
	if [[ -n "${bootconf[STORAGEPP]}" ]]; then
	   storagepp="${bootconf[STORAGEPP],,}"
		[[ ! "${storagepp}" =~ ^cryptdisks: ]] && storagepp="cryptdisks:${storagepp}"
	fi
	[[ -n "${bootconf[TIMEOUT]}" ]] && timeout="${bootconf[TIMEOUT]}"
	[[ -n "${bootconf[LOGSIZE]}" ]] && logsz="${bootconf[LOGSIZE]}"
	if [[ -s ${fwdir}/UglyLinux${bootconf[BOOTSERVERKEYS]}-${fwguid} ]]; then 
		cat ${fwdir}/UglyLinux${bootconf[BOOTSERVERKEYS]}-${fwguid} | tail -c +5 > ${tmpdir}/${bootconf[BOOTSERVERKEYS]}
		if [[ -s ${fwdir}/UglyLinux${bootconf[BOOTUSERKEY]}-${fwguid} ]]; then
			cat ${fwdir}/UglyLinux${bootconf[BOOTUSERKEY]}-${fwguid} | tail -c +5 > ${tmpdir}/${bootconf[BOOTUSERKEY]}
			chmod 400 ${tmpdir}/${bootconf[BOOTUSERKEY]}
		else
			network = 2
			return 2
		fi
	else
		network = 2
		return 2
	fi
	return 0
}

do_mount_boot()
{
    [[ ! -d /boot ]] && mkdir /boot
    mount /dev/disk/by-label/boot /boot || problem "Unable to mount boot"
}

do_mount_root()
{
	mkdir /squashfs
	mount -t tmpfs tmpfs -o size="$(($(stat -c%s ${sysimg})+1))" /squashfs
	if [[ -n "$1" ]]; then
		openssl aes-256-cbc -salt -d -pbkdf2 -in ${sysimg} -out /squashfs/${sysimg##*/} -k "$1"
	else 
		cp ${sysimg} /squashfs/${sysimg##*/}
	fi
   	mount -t squashfs /squashfs/${sysimg##*/} ${rootdir} > /dev/null 2>&1 || problem "Unable to mount Squashfs root"
}

do_mount_etc()
{
   [[ ! -d ${etcdir} ]] && mkdir ${etcdir}
   mount -n ${etcmd} ${etcdir} > /dev/null 2>&1 || problem "Unable to Mount etc"
}

do_init_log()
{
   mkdir -p ${logdir}
   mount -n ${logdev} ${logdir} > /dev/null 2>&1 || problem "Unable to Mount log ram drive"
   ln -s /var/storage/logarchive ${logdir}/archive
   mkdir ${logdir}/samba
   chmod 750 ${logdir}/samba
   mkdir ${logdir}/journal
   chgrp 10 ${logdir}/journal
   chmod 2755 ${logdir}/journal
   mkdir ${logdir}/sa
   chmod 750 ${logdir}/sa
   mkdir ${logdir}/clamav
   chown clamav:clamav ${logdir}/clamav
   chmod 750 ${logdir}/clamav
   umount ${logdir}
}

do_start_network()
{
	if [[ ! -f ${tmpdir}/network ]]; then
		return 1
	fi
	return 0
}

do_write_keyfile()
{
	printf "\x07\x00\x00\x00\x00" > ${fwdir}/UglyLinux$1.key-${fwguid} || return 1
	head -c256 /dev/urandom |openssl aes-256-cbc -e -salt -pbkdf2 -in - -out ${tmpdir}/$1.key -k "$2" >/dev/null 2>&1 || return 1
	efivar -n ${fwguid}-UglyLinux$1.key -w -f ${tmpdir}/$1.key >/dev/null 2>&1 || return 1
	return 0
}

do_check_passphrase()
{
	if [[ -f ${fwdir}/UglyLinux$1.key-${fwguid} ]]; then
		if  $(cat ${fwdir}/UglyLinux$1.key-${fwguid} | tail -c +5 | openssl aes-256-cbc -d -salt -pbkdf2 -in - -out /dev/null -k "$2" >/dev/null 2>&1); then 
			log "$1 passphrase checked - OK"
			return 0
		else
			log "$1 passphrase checked - FAIL"
			return 1
		fi
	else
		log "$1 passphrase NOT checked"
		return 2
	fi
	return 1
}

trap_term_do_get_passphrase()
{
	for __i in ${!__pid[@]}; do kill -SIGTERM ${__pid[${__i}]} >/dev/null 2>&1; done
	echo ".done" >&4
	exit 0
}

do_get_passphrase()
{
	trap 'trap_term_do_get_passphrase' SIGINT SIGTERM
	local __res="" __i=""
	declare -A __pid
	for __i in ${bootconf[BOOTSERVERS]}; do 
		do_ssh_passphrase "$1" &
		__pid[${__i}]=$!
	done
	wait
	echo ".done" >&4
	exit 0
}

trap_term_do_ssh_passphrase()
{
	[[ ! -z "${__pid}" ]] && kill -SIGTERM ${__pid} >/dev/null 2>&1
	exec {__fd}>&-
	exit 0
}

do_ssh_passphrase()
{
	trap 'trap_term_do_ssh_passphrase' SIGINT SIGTERM
	local __passphrase="" __fd __pid __res
	exec {__fd}< <(ssh -fi ${tmpdir}/${bootconf[BOOTUSERKEY]} -o UserKnownHostsFile=${tmpdir}/${bootconf[BOOTSERVERKEYS]} ${bootconf[BOOTUSER]}@${__i} "GET "$1"" 2>/dev/null)
	__pid=$!
	IFS= read -ru ${__fd} __passphrase
	if [[ -z "${__passphrase}" ]] || [[ $(do_check_passphrase "$1" "${__passphrase}")$? -eq 1 ]]; then
		log "get $1 key from ${__i} - FAIL"
		echo "${__i}||" >&4
		exec {__fd}>&-
		exit 1
	else
		log "get $1 key from ${__i} - OK"
		echo "${__i}||${__passphrase}" >&4
		exec {__fd}>&-
		exit 0
	fi
}

do_net_passphrase()
{
	local __fd __srv __res __passphrase="" __pid
	exec 3>&1 {__fd}< <(echodo "Requesting $1 Passphrase from Boot Servers: " do_get_passphrase "$1" 4>&1- 1>&3-); __pid=$! 
	while IFS="|" read -t${timeout} -ru${__fd} __srv __passphrase; __res=$?; [[ ${__res} -eq 0 && ! "${__srv,,}" == ".done" ]]; do
		__passphrase="${__passphrase:1}"
		if [[ -z "${__passphrase}" ]]; then
			cecho -ne "\033[91m${__srv}\033[0m "
		else
			log "do_get_passphrase requesting $1 passphrase from boot servers: - OK"
			cecho -e "\033[92m${__srv}\033[200D\033[1m[  OK  ]\033[0m"
			echo "${__passphrase}"
			exec {__fd}>&-
			kill -SIGTERM ${__pid} >/dev/null 2>&1
			exit 0
		fi
	done
	if [[ ${__res} -gt 128 ]]; then
		kill -SIGTERM ${__pid} >/dev/null 2>&1
		log "do_get_passphrase requesting $1 passphrase from boot servers: - TIMEOUT"
	else
		log "do_get_passphrase requesting $1 passphrase from boot servers: - FAIL"
	fi
	exec {__fd}>&-
	cecho -e "\033[200D\033[91m\033[1m[ FAIL ]\033[0m"
	exit 1
}

do_ask_passphrase()
{
	local __passphrase=""
	local REPLY="x"
	local DEL="$(printf "\x7F")"
	until [[ -z "${REPLY}" ]]; do 
		read -t ${timeout} -rsn1 -d $'\012'
		[[ "$?" -gt 128 ]] && reset "Query Passphrase Timeout"
		if [[ "${REPLY}" == "${DEL}" ]]; then
			if [[ "${#__passphrase}" -ne 0 ]]; then
				cecho -ne "\b \b"
				__passphrase="${__passphrase::-1}"
			fi
			continue
		fi
		__passphrase+="${REPLY}"
		[[ -n "${REPLY}" ]] && cecho -n "*"
	done;
	if [[ -z "$2" ]]; then
		local __r=$(do_check_passphrase "$1" "${__passphrase}")$?
		if [[ ${__r} -ne 1 ]]; then
			_output="${__passphrase}"
			return ${__r}
		fi
	elif [[ "$2" == "${__passphrase}" ]]; then
		_output="${__passphrase}"
		return 0
	fi
	return 1
}

do_query_passphrase()
{
	local __passphrase=""
	__passphrase="$(echodo "Enter $1 Passphrase: " do_ask_passphrase "$1")" 
	case $? in
		1)
		until __passphrase="$(echodo "Incorrect $1 Passphrase, Retry: " do_ask_passphrase "$1")"; do :; done;;
		2)
		until __passphrase="$(echodo "Key File not Found, Creating. Confirm $1 Passphrase: " do_ask_passphrase "$1" "${__passphrase}")"; do
			__passphrase="$(echodo "Passphrases do not Match. Enter $1 Passphrase: " do_ask_passphrase "$1" "${__passphrase}")"
		done
	esac
	echo "${__passphrase}"
	return 0
}

do_read_passphrase()
{
	local _passphrase="" _key="" 
	_key="$(keyctl request user $1 2>/dev/null)"
	if [[ -n "${_key}" ]]; then
		_passphrase="$(keyctl print ${_key} 2>/dev/null)"
	else
		[[ "${network}" -eq 1 ]] && _passphrase="$(do_net_passphrase "$1")"
		[[ -z "${_passphrase}" ]] && _passphrase="$(do_query_passphrase "$1")"
		_key=$(keyctl add user "$1" "${_passphrase}" @u 2>/dev/null)
		keyctl timeout ${_key} 300 2>/dev/null
	fi
	[[ ! -f "${fwdir}/UglyLinux$1.key-${fwguid}" ]] && $(echodo "Writing $1 key to Fimware" do_write_keyfile "$1" "${_passphrase}")
	echo "${_passphrase}"
	return 0
}

do_import_storage()
{
	if [[ ! -z "${bootconf[STORAGEDEVS]}" ]]; then
		local __nr=1 __i=0 __storagedev __storagetrim  __status=0
		for __storagedev in ${bootconf[STORAGEDEVS]}; do
			local ___dev="$(findfs ${__storagedev} 2>/dev/null)" 
			if [[ $? -ne 0 ]] ; then
				log "incorrect storage device entry (${__storagedev}) in bootconf"
			elif [[ ! -b /dev/mapper/${2}${__nr} ]]; then
				[[ ${storagetrim} -eq 1 && "$(lsblk -rD ${___dev} |head -n2 |tail -n1| cut -d " " -f3)" != "0B" ]] && __storagetrim="--allow-discards"
				/sbin/cryptsetup open --type plain ${__storagetrim} ${___dev} ${2}${__nr} <<<"$3" >/dev/null 2>&1
				if [[ "$?" -eq 0 ]]; then
					__nr=$((__nr+1))
				else
					log "cannot unlock persistent storage device ${__storagedev}"
					__status=2
				fi
			else
				log "persistent storage device /dev/mapper/${2}${__nr} already present"
				__status=2
			fi
		done 
		if [[ "${__nr}" -eq 1 ]]; then
			log "no usable storage devices in bootconf, starting with default config"
			cecho -ne "\033[91mNo Usable Storage Devices in Bootconf, Starting with Default Config\033[0m"
			return 1
		else
			if ! zpool import $1 -f >/dev/null 2>&1; then
				log "unable to import storage pool $1, starting with default config"
				cecho -ne "\033[91mUnable to Import Storage Pool $1, Starting with Default Config\033[0m"
				return 1
			fi
			while [[ "${__i}" -le ${timeout} ]]; do
				[[ -b /dev/zvol/$1/etc || -b /dev/zvol/$1/lib ]] && mdadm --assemble --scan >/dev/null 2>&1
				[[ -b ${etcmd} && -b ${libmd} ]] && break
				sleep 1
				__i=$((__i+1))
			done
			if [[ ! -b ${etcmd} || ! -b ${libmd} ]]; then
				log "etc or lib zvol not found starting with default config"
				cecho -ne "\033[91mNo lib or etc Zvol Found. Starting with Default Config\033[0m"
				return 1
			fi
			etcsz=$(($(blockdev --getsize64 /dev/zvol/$1/etc) + 1))
			libsz=$(($(blockdev --getsize64 /dev/zvol/$1/lib) + 1))
		fi
	else
		log "no persistent storage devices in bootconf. starting with default config"
		cecho -ne "\033[91mNo Persistent Storage Devices in Bootconf. Starting with Default Config\033[0m"
		return 1
	fi
	return ${__status}
}

do_make_default_config()
{
    local _passphrase=""
    mount -t tmpfs tmpfs -o size=1G,mode=0750,nosuid,noexec,nodev ${rootdir}/root
    ln -s /etc/bashrc ${rootdir}/root/.bashrc
    mkdir ${rootdir}/root/quarantine
    echodo "Mounting boot filesystem." do_mount_boot
    [[ "${imgtype,,}" =~ ^openssl ]] &&  _passphrase="$(do_read_passphrase "${masterpp}")"
    if [[ ! -f /boot/storage ]]; then
        touch /boot/storage
        truncate -s 1G /boot/storage
        cryptsetup create --type plain storage /boot/storage <<<"${_passphrase}" >/dev/null 2>&1
        echodo "Creating new storage filesystem on /boot." mkfs.ext4 /dev/mapper/storage
        mount /dev/mapper/storage /mnt
        cp -a ${rootdir}/var/storage/* /mnt
        cp -a ${rootdir}/etc /mnt
        cp -a ${rootdir}/var/lib /mnt
        ssh-keygen -A -f /mnt >/dev/null 2>&1
        ${rootdir}/bin/systemd-machine-id-setup >/dev/null 2>&1
        cp /etc/machine-id /mnt/etc/
        umount /mnt
    else
        cryptsetup open --type plain /boot/storage storage <<<"${_passphrase}" >/dev/null 2>&1
    fi
    echodo "Mounting storage filesystem." mount /dev/mapper/storage ${rootdir}/var/storage
    mount -o bind ${rootdir}/var/storage/etc ${rootdir}/etc
    mount -o bind ${rootdir}/var/storage/lib ${rootdir}/var/lib
}

do_stop_network()
{
	local _interface="$(</tmp/network)"
	ip route del default via ${bootconf[GATEWAY]} >/dev/null 2>&1 || return 1
	ip addr del ${bootconf[IP]} dev ${_interface} >/dev/null 2>&1 || return 1
	ip link set dev ${_interface} down >/dev/null 2>&1 || return 1
	return 0
}

do_unmount()
{
	cd /
	/bin/umount /sys/firmware/efi/efivars || problem "Could not unmount efivarfs"
}

# Start init
log "starting system initialization"
cecho -e "\033[9C\033[1mStarting System Initialization\033[0m"

touch /etc/mtab
dmesg -n 1
mount -n -t devtmpfs devtmpfs /dev
mount -n -t proc     proc     /proc
mount -n -t sysfs    sysfs    /sys
mount -n -t tmpfs    tmpfs    /run
mount -n -t efivarfs efivarfs /sys/firmware/efi/efivars
[[ ! -L /dev/fd ]] && ln -s /proc/self/fd /dev/fd
exec 1>&- 2>&- {fd}< <(haveged -F 1>&- 2>&- 0<&-) >/dev/null 2>&1

read -r cmdline < /proc/cmdline

for param in $cmdline ; do
  case $param in
    recovery    ) recovery="yes"		  ;;
  esac
done

echodo "Reading Boot Config from Firmware" do_parse_fwconf && bootconfinfw=1

/lib/systemd/systemd-udevd --daemon --resolve-names=never 2>/dev/null
udevadm trigger && udevadm settle
mdadm --assemble --scan >/dev/null 2>&1

if [[ network -eq 0 && ${bootconfinfw} -eq 1 ]]; then
	echodo "Starting Network" do_start_network && network=1
fi

if [[ $recovery = yes ]] ; then
   cecho -e "\033[9C\033[91m\033[1mEntering Recovery Mode.\033[0m"
   setsid cttyhack bash -i
fi

if [[ ! -f /default ]]; then
	echodo "Importing Persistent Storage Pool ${storagepool} " do_import_storage "${storagepool}" "${storageprefix}" "$(do_read_passphrase "${storagepp}")"
	[[ $? -eq 1 ]] && touch /default
fi

echodo "Creating zram Drives" do_make_zram_fs "lz4hc,${logsz},log" "lz4hc,${etcsz},etc" "lz4hc,${libsz},lib"
do_init_log

imgtype="$(file -b ${sysimg})"
if [[ "${imgtype,,}" =~ ^openssl ]]; then
	echodo "Mounting ${sysimg##*/}" do_mount_root "$(do_read_passphrase "${masterpp}")"
elif [[ "${imgtype,,}" =~ ^squashfs ]]; then
	echodo "Mounting ${sysimg##*/}" do_mount_root 
else
	log "unsupported system image type"
	problem "Unsupported System Image Type"
fi

# Check for default config
if [[ -f /default ]]; then
    do_make_default_config
else
    do_mount_etc
fi

[[ "${network}" -eq 1 ]] && echodo "Stopping Network" do_stop_network && network=0

killall -15 ssh systemd-udevd haveged >/dev/null 2>&1

do_unmount

echo 3 >/proc/sys/vm/drop_caches

exec switch_root /.root "${init}" "$@"
